
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderProduct
 * 
 */
export type OrderProduct = $Result.DefaultSelection<Prisma.$OrderProductPayload>
/**
 * Model MaterialMovement
 * 
 */
export type MaterialMovement = $Result.DefaultSelection<Prisma.$MaterialMovementPayload>
/**
 * Model ProgressReport
 * 
 */
export type ProgressReport = $Result.DefaultSelection<Prisma.$ProgressReportPayload>
/**
 * Model ProductProgressReport
 * 
 */
export type ProductProgressReport = $Result.DefaultSelection<Prisma.$ProductProgressReportPayload>
/**
 * Model ProductProgressPhoto
 * 
 */
export type ProductProgressPhoto = $Result.DefaultSelection<Prisma.$ProductProgressPhotoPayload>
/**
 * Model RemainingMaterial
 * 
 */
export type RemainingMaterial = $Result.DefaultSelection<Prisma.$RemainingMaterialPayload>
/**
 * Model Inventaris
 * 
 */
export type Inventaris = $Result.DefaultSelection<Prisma.$InventarisPayload>
/**
 * Model OrderLink
 * 
 */
export type OrderLink = $Result.DefaultSelection<Prisma.$OrderLinkPayload>
/**
 * Model ProductMaterial
 * 
 */
export type ProductMaterial = $Result.DefaultSelection<Prisma.$ProductMaterialPayload>
/**
 * Model Shipment
 * 
 */
export type Shipment = $Result.DefaultSelection<Prisma.$ShipmentPayload>
/**
 * Model RecurringPlan
 * 
 */
export type RecurringPlan = $Result.DefaultSelection<Prisma.$RecurringPlanPayload>
/**
 * Model StatusChange
 * 
 */
export type StatusChange = $Result.DefaultSelection<Prisma.$StatusChangePayload>
/**
 * Model ProductColour
 * 
 */
export type ProductColour = $Result.DefaultSelection<Prisma.$ProductColourPayload>
/**
 * Model ProductVariation
 * 
 */
export type ProductVariation = $Result.DefaultSelection<Prisma.$ProductVariationPayload>
/**
 * Model ProductPhoto
 * 
 */
export type ProductPhoto = $Result.DefaultSelection<Prisma.$ProductPhotoPayload>
/**
 * Model MaterialPurchaseAlert
 * 
 */
export type MaterialPurchaseAlert = $Result.DefaultSelection<Prisma.$MaterialPurchaseAlertPayload>
/**
 * Model PurchaseLog
 * 
 */
export type PurchaseLog = $Result.DefaultSelection<Prisma.$PurchaseLogPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model ContactNote
 * 
 */
export type ContactNote = $Result.DefaultSelection<Prisma.$ContactNotePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  OPERATOR: 'OPERATOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const OrderStatus: {
  CREATED: 'CREATED',
  NEED_MATERIAL: 'NEED_MATERIAL',
  CONFIRMED: 'CONFIRMED',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const OrderProductStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type OrderProductStatus = (typeof OrderProductStatus)[keyof typeof OrderProductStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const MaterialMovementType: {
  IN: 'IN',
  OUT: 'OUT',
  ADJUST: 'ADJUST'
};

export type MaterialMovementType = (typeof MaterialMovementType)[keyof typeof MaterialMovementType]


export const ShipmentStatus: {
  PENDING: 'PENDING',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED'
};

export type ShipmentStatus = (typeof ShipmentStatus)[keyof typeof ShipmentStatus]


export const MaterialPurchaseAlertType: {
  LOW_STOCK: 'LOW_STOCK',
  OUT_OF_STOCK: 'OUT_OF_STOCK',
  UPCOMING_NEED: 'UPCOMING_NEED',
  EMERGENCY_NEED: 'EMERGENCY_NEED'
};

export type MaterialPurchaseAlertType = (typeof MaterialPurchaseAlertType)[keyof typeof MaterialPurchaseAlertType]


export const UrgencyLevel: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type UrgencyLevel = (typeof UrgencyLevel)[keyof typeof UrgencyLevel]


export const AlertStatus: {
  ACTIVE: 'ACTIVE',
  RESOLVED: 'RESOLVED',
  DISMISSED: 'DISMISSED'
};

export type AlertStatus = (typeof AlertStatus)[keyof typeof AlertStatus]


export const PurchaseStatus: {
  PENDING: 'PENDING',
  ORDERED: 'ORDERED',
  RECEIVED: 'RECEIVED',
  CANCELLED: 'CANCELLED'
};

export type PurchaseStatus = (typeof PurchaseStatus)[keyof typeof PurchaseStatus]


export const ContactType: {
  CUSTOMER: 'CUSTOMER',
  SUPPLIER: 'SUPPLIER',
  WORKER: 'WORKER',
  OTHER: 'OTHER'
};

export type ContactType = (typeof ContactType)[keyof typeof ContactType]


export const NoteType: {
  GENERAL: 'GENERAL',
  FOLLOW_UP: 'FOLLOW_UP',
  COMPLAINT: 'COMPLAINT',
  ORDER: 'ORDER',
  PURCHASE: 'PURCHASE',
  PAYMENT: 'PAYMENT'
};

export type NoteType = (typeof NoteType)[keyof typeof NoteType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type OrderProductStatus = $Enums.OrderProductStatus

export const OrderProductStatus: typeof $Enums.OrderProductStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type MaterialMovementType = $Enums.MaterialMovementType

export const MaterialMovementType: typeof $Enums.MaterialMovementType

export type ShipmentStatus = $Enums.ShipmentStatus

export const ShipmentStatus: typeof $Enums.ShipmentStatus

export type MaterialPurchaseAlertType = $Enums.MaterialPurchaseAlertType

export const MaterialPurchaseAlertType: typeof $Enums.MaterialPurchaseAlertType

export type UrgencyLevel = $Enums.UrgencyLevel

export const UrgencyLevel: typeof $Enums.UrgencyLevel

export type AlertStatus = $Enums.AlertStatus

export const AlertStatus: typeof $Enums.AlertStatus

export type PurchaseStatus = $Enums.PurchaseStatus

export const PurchaseStatus: typeof $Enums.PurchaseStatus

export type ContactType = $Enums.ContactType

export const ContactType: typeof $Enums.ContactType

export type NoteType = $Enums.NoteType

export const NoteType: typeof $Enums.NoteType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderProduct`: Exposes CRUD operations for the **OrderProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderProducts
    * const orderProducts = await prisma.orderProduct.findMany()
    * ```
    */
  get orderProduct(): Prisma.OrderProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materialMovement`: Exposes CRUD operations for the **MaterialMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialMovements
    * const materialMovements = await prisma.materialMovement.findMany()
    * ```
    */
  get materialMovement(): Prisma.MaterialMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.progressReport`: Exposes CRUD operations for the **ProgressReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgressReports
    * const progressReports = await prisma.progressReport.findMany()
    * ```
    */
  get progressReport(): Prisma.ProgressReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productProgressReport`: Exposes CRUD operations for the **ProductProgressReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductProgressReports
    * const productProgressReports = await prisma.productProgressReport.findMany()
    * ```
    */
  get productProgressReport(): Prisma.ProductProgressReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productProgressPhoto`: Exposes CRUD operations for the **ProductProgressPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductProgressPhotos
    * const productProgressPhotos = await prisma.productProgressPhoto.findMany()
    * ```
    */
  get productProgressPhoto(): Prisma.ProductProgressPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.remainingMaterial`: Exposes CRUD operations for the **RemainingMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RemainingMaterials
    * const remainingMaterials = await prisma.remainingMaterial.findMany()
    * ```
    */
  get remainingMaterial(): Prisma.RemainingMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventaris`: Exposes CRUD operations for the **Inventaris** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventarises
    * const inventarises = await prisma.inventaris.findMany()
    * ```
    */
  get inventaris(): Prisma.InventarisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderLink`: Exposes CRUD operations for the **OrderLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderLinks
    * const orderLinks = await prisma.orderLink.findMany()
    * ```
    */
  get orderLink(): Prisma.OrderLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productMaterial`: Exposes CRUD operations for the **ProductMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductMaterials
    * const productMaterials = await prisma.productMaterial.findMany()
    * ```
    */
  get productMaterial(): Prisma.ProductMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shipment`: Exposes CRUD operations for the **Shipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shipments
    * const shipments = await prisma.shipment.findMany()
    * ```
    */
  get shipment(): Prisma.ShipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurringPlan`: Exposes CRUD operations for the **RecurringPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringPlans
    * const recurringPlans = await prisma.recurringPlan.findMany()
    * ```
    */
  get recurringPlan(): Prisma.RecurringPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.statusChange`: Exposes CRUD operations for the **StatusChange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusChanges
    * const statusChanges = await prisma.statusChange.findMany()
    * ```
    */
  get statusChange(): Prisma.StatusChangeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productColour`: Exposes CRUD operations for the **ProductColour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductColours
    * const productColours = await prisma.productColour.findMany()
    * ```
    */
  get productColour(): Prisma.ProductColourDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productVariation`: Exposes CRUD operations for the **ProductVariation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariations
    * const productVariations = await prisma.productVariation.findMany()
    * ```
    */
  get productVariation(): Prisma.ProductVariationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productPhoto`: Exposes CRUD operations for the **ProductPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductPhotos
    * const productPhotos = await prisma.productPhoto.findMany()
    * ```
    */
  get productPhoto(): Prisma.ProductPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materialPurchaseAlert`: Exposes CRUD operations for the **MaterialPurchaseAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialPurchaseAlerts
    * const materialPurchaseAlerts = await prisma.materialPurchaseAlert.findMany()
    * ```
    */
  get materialPurchaseAlert(): Prisma.MaterialPurchaseAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseLog`: Exposes CRUD operations for the **PurchaseLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseLogs
    * const purchaseLogs = await prisma.purchaseLog.findMany()
    * ```
    */
  get purchaseLog(): Prisma.PurchaseLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactNote`: Exposes CRUD operations for the **ContactNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactNotes
    * const contactNotes = await prisma.contactNote.findMany()
    * ```
    */
  get contactNote(): Prisma.ContactNoteDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Material: 'Material',
    Product: 'Product',
    Order: 'Order',
    OrderProduct: 'OrderProduct',
    MaterialMovement: 'MaterialMovement',
    ProgressReport: 'ProgressReport',
    ProductProgressReport: 'ProductProgressReport',
    ProductProgressPhoto: 'ProductProgressPhoto',
    RemainingMaterial: 'RemainingMaterial',
    Inventaris: 'Inventaris',
    OrderLink: 'OrderLink',
    ProductMaterial: 'ProductMaterial',
    Shipment: 'Shipment',
    RecurringPlan: 'RecurringPlan',
    StatusChange: 'StatusChange',
    ProductColour: 'ProductColour',
    ProductVariation: 'ProductVariation',
    ProductPhoto: 'ProductPhoto',
    MaterialPurchaseAlert: 'MaterialPurchaseAlert',
    PurchaseLog: 'PurchaseLog',
    Contact: 'Contact',
    ContactNote: 'ContactNote'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "material" | "product" | "order" | "orderProduct" | "materialMovement" | "progressReport" | "productProgressReport" | "productProgressPhoto" | "remainingMaterial" | "inventaris" | "orderLink" | "productMaterial" | "shipment" | "recurringPlan" | "statusChange" | "productColour" | "productVariation" | "productPhoto" | "materialPurchaseAlert" | "purchaseLog" | "contact" | "contactNote"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderProduct: {
        payload: Prisma.$OrderProductPayload<ExtArgs>
        fields: Prisma.OrderProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          findFirst: {
            args: Prisma.OrderProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          findMany: {
            args: Prisma.OrderProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>[]
          }
          create: {
            args: Prisma.OrderProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          createMany: {
            args: Prisma.OrderProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>[]
          }
          delete: {
            args: Prisma.OrderProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          update: {
            args: Prisma.OrderProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          deleteMany: {
            args: Prisma.OrderProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>[]
          }
          upsert: {
            args: Prisma.OrderProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          aggregate: {
            args: Prisma.OrderProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderProduct>
          }
          groupBy: {
            args: Prisma.OrderProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderProductCountArgs<ExtArgs>
            result: $Utils.Optional<OrderProductCountAggregateOutputType> | number
          }
        }
      }
      MaterialMovement: {
        payload: Prisma.$MaterialMovementPayload<ExtArgs>
        fields: Prisma.MaterialMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialMovementPayload>
          }
          findFirst: {
            args: Prisma.MaterialMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialMovementPayload>
          }
          findMany: {
            args: Prisma.MaterialMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialMovementPayload>[]
          }
          create: {
            args: Prisma.MaterialMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialMovementPayload>
          }
          createMany: {
            args: Prisma.MaterialMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialMovementPayload>[]
          }
          delete: {
            args: Prisma.MaterialMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialMovementPayload>
          }
          update: {
            args: Prisma.MaterialMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialMovementPayload>
          }
          deleteMany: {
            args: Prisma.MaterialMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialMovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialMovementPayload>[]
          }
          upsert: {
            args: Prisma.MaterialMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialMovementPayload>
          }
          aggregate: {
            args: Prisma.MaterialMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialMovement>
          }
          groupBy: {
            args: Prisma.MaterialMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialMovementCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialMovementCountAggregateOutputType> | number
          }
        }
      }
      ProgressReport: {
        payload: Prisma.$ProgressReportPayload<ExtArgs>
        fields: Prisma.ProgressReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgressReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgressReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>
          }
          findFirst: {
            args: Prisma.ProgressReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgressReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>
          }
          findMany: {
            args: Prisma.ProgressReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>[]
          }
          create: {
            args: Prisma.ProgressReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>
          }
          createMany: {
            args: Prisma.ProgressReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgressReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>[]
          }
          delete: {
            args: Prisma.ProgressReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>
          }
          update: {
            args: Prisma.ProgressReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>
          }
          deleteMany: {
            args: Prisma.ProgressReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgressReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgressReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>[]
          }
          upsert: {
            args: Prisma.ProgressReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressReportPayload>
          }
          aggregate: {
            args: Prisma.ProgressReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgressReport>
          }
          groupBy: {
            args: Prisma.ProgressReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgressReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgressReportCountArgs<ExtArgs>
            result: $Utils.Optional<ProgressReportCountAggregateOutputType> | number
          }
        }
      }
      ProductProgressReport: {
        payload: Prisma.$ProductProgressReportPayload<ExtArgs>
        fields: Prisma.ProductProgressReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductProgressReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductProgressReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressReportPayload>
          }
          findFirst: {
            args: Prisma.ProductProgressReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductProgressReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressReportPayload>
          }
          findMany: {
            args: Prisma.ProductProgressReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressReportPayload>[]
          }
          create: {
            args: Prisma.ProductProgressReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressReportPayload>
          }
          createMany: {
            args: Prisma.ProductProgressReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductProgressReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressReportPayload>[]
          }
          delete: {
            args: Prisma.ProductProgressReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressReportPayload>
          }
          update: {
            args: Prisma.ProductProgressReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressReportPayload>
          }
          deleteMany: {
            args: Prisma.ProductProgressReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductProgressReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductProgressReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressReportPayload>[]
          }
          upsert: {
            args: Prisma.ProductProgressReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressReportPayload>
          }
          aggregate: {
            args: Prisma.ProductProgressReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductProgressReport>
          }
          groupBy: {
            args: Prisma.ProductProgressReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductProgressReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductProgressReportCountArgs<ExtArgs>
            result: $Utils.Optional<ProductProgressReportCountAggregateOutputType> | number
          }
        }
      }
      ProductProgressPhoto: {
        payload: Prisma.$ProductProgressPhotoPayload<ExtArgs>
        fields: Prisma.ProductProgressPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductProgressPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductProgressPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressPhotoPayload>
          }
          findFirst: {
            args: Prisma.ProductProgressPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductProgressPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressPhotoPayload>
          }
          findMany: {
            args: Prisma.ProductProgressPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressPhotoPayload>[]
          }
          create: {
            args: Prisma.ProductProgressPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressPhotoPayload>
          }
          createMany: {
            args: Prisma.ProductProgressPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductProgressPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressPhotoPayload>[]
          }
          delete: {
            args: Prisma.ProductProgressPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressPhotoPayload>
          }
          update: {
            args: Prisma.ProductProgressPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressPhotoPayload>
          }
          deleteMany: {
            args: Prisma.ProductProgressPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductProgressPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductProgressPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressPhotoPayload>[]
          }
          upsert: {
            args: Prisma.ProductProgressPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductProgressPhotoPayload>
          }
          aggregate: {
            args: Prisma.ProductProgressPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductProgressPhoto>
          }
          groupBy: {
            args: Prisma.ProductProgressPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductProgressPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductProgressPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<ProductProgressPhotoCountAggregateOutputType> | number
          }
        }
      }
      RemainingMaterial: {
        payload: Prisma.$RemainingMaterialPayload<ExtArgs>
        fields: Prisma.RemainingMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RemainingMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemainingMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RemainingMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemainingMaterialPayload>
          }
          findFirst: {
            args: Prisma.RemainingMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemainingMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RemainingMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemainingMaterialPayload>
          }
          findMany: {
            args: Prisma.RemainingMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemainingMaterialPayload>[]
          }
          create: {
            args: Prisma.RemainingMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemainingMaterialPayload>
          }
          createMany: {
            args: Prisma.RemainingMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RemainingMaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemainingMaterialPayload>[]
          }
          delete: {
            args: Prisma.RemainingMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemainingMaterialPayload>
          }
          update: {
            args: Prisma.RemainingMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemainingMaterialPayload>
          }
          deleteMany: {
            args: Prisma.RemainingMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RemainingMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RemainingMaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemainingMaterialPayload>[]
          }
          upsert: {
            args: Prisma.RemainingMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemainingMaterialPayload>
          }
          aggregate: {
            args: Prisma.RemainingMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRemainingMaterial>
          }
          groupBy: {
            args: Prisma.RemainingMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<RemainingMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.RemainingMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<RemainingMaterialCountAggregateOutputType> | number
          }
        }
      }
      Inventaris: {
        payload: Prisma.$InventarisPayload<ExtArgs>
        fields: Prisma.InventarisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventarisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventarisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarisPayload>
          }
          findFirst: {
            args: Prisma.InventarisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventarisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarisPayload>
          }
          findMany: {
            args: Prisma.InventarisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarisPayload>[]
          }
          create: {
            args: Prisma.InventarisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarisPayload>
          }
          createMany: {
            args: Prisma.InventarisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventarisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarisPayload>[]
          }
          delete: {
            args: Prisma.InventarisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarisPayload>
          }
          update: {
            args: Prisma.InventarisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarisPayload>
          }
          deleteMany: {
            args: Prisma.InventarisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventarisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventarisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarisPayload>[]
          }
          upsert: {
            args: Prisma.InventarisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventarisPayload>
          }
          aggregate: {
            args: Prisma.InventarisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventaris>
          }
          groupBy: {
            args: Prisma.InventarisGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventarisGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventarisCountArgs<ExtArgs>
            result: $Utils.Optional<InventarisCountAggregateOutputType> | number
          }
        }
      }
      OrderLink: {
        payload: Prisma.$OrderLinkPayload<ExtArgs>
        fields: Prisma.OrderLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderLinkPayload>
          }
          findFirst: {
            args: Prisma.OrderLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderLinkPayload>
          }
          findMany: {
            args: Prisma.OrderLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderLinkPayload>[]
          }
          create: {
            args: Prisma.OrderLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderLinkPayload>
          }
          createMany: {
            args: Prisma.OrderLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderLinkPayload>[]
          }
          delete: {
            args: Prisma.OrderLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderLinkPayload>
          }
          update: {
            args: Prisma.OrderLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderLinkPayload>
          }
          deleteMany: {
            args: Prisma.OrderLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderLinkPayload>[]
          }
          upsert: {
            args: Prisma.OrderLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderLinkPayload>
          }
          aggregate: {
            args: Prisma.OrderLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderLink>
          }
          groupBy: {
            args: Prisma.OrderLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderLinkCountArgs<ExtArgs>
            result: $Utils.Optional<OrderLinkCountAggregateOutputType> | number
          }
        }
      }
      ProductMaterial: {
        payload: Prisma.$ProductMaterialPayload<ExtArgs>
        fields: Prisma.ProductMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMaterialPayload>
          }
          findFirst: {
            args: Prisma.ProductMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMaterialPayload>
          }
          findMany: {
            args: Prisma.ProductMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMaterialPayload>[]
          }
          create: {
            args: Prisma.ProductMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMaterialPayload>
          }
          createMany: {
            args: Prisma.ProductMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductMaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMaterialPayload>[]
          }
          delete: {
            args: Prisma.ProductMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMaterialPayload>
          }
          update: {
            args: Prisma.ProductMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMaterialPayload>
          }
          deleteMany: {
            args: Prisma.ProductMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductMaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMaterialPayload>[]
          }
          upsert: {
            args: Prisma.ProductMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMaterialPayload>
          }
          aggregate: {
            args: Prisma.ProductMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductMaterial>
          }
          groupBy: {
            args: Prisma.ProductMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<ProductMaterialCountAggregateOutputType> | number
          }
        }
      }
      Shipment: {
        payload: Prisma.$ShipmentPayload<ExtArgs>
        fields: Prisma.ShipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          findFirst: {
            args: Prisma.ShipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          findMany: {
            args: Prisma.ShipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          create: {
            args: Prisma.ShipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          createMany: {
            args: Prisma.ShipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          delete: {
            args: Prisma.ShipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          update: {
            args: Prisma.ShipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          deleteMany: {
            args: Prisma.ShipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          upsert: {
            args: Prisma.ShipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          aggregate: {
            args: Prisma.ShipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShipment>
          }
          groupBy: {
            args: Prisma.ShipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShipmentCountArgs<ExtArgs>
            result: $Utils.Optional<ShipmentCountAggregateOutputType> | number
          }
        }
      }
      RecurringPlan: {
        payload: Prisma.$RecurringPlanPayload<ExtArgs>
        fields: Prisma.RecurringPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPlanPayload>
          }
          findFirst: {
            args: Prisma.RecurringPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPlanPayload>
          }
          findMany: {
            args: Prisma.RecurringPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPlanPayload>[]
          }
          create: {
            args: Prisma.RecurringPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPlanPayload>
          }
          createMany: {
            args: Prisma.RecurringPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurringPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPlanPayload>[]
          }
          delete: {
            args: Prisma.RecurringPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPlanPayload>
          }
          update: {
            args: Prisma.RecurringPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPlanPayload>
          }
          deleteMany: {
            args: Prisma.RecurringPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecurringPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPlanPayload>[]
          }
          upsert: {
            args: Prisma.RecurringPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringPlanPayload>
          }
          aggregate: {
            args: Prisma.RecurringPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringPlan>
          }
          groupBy: {
            args: Prisma.RecurringPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurringPlanCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringPlanCountAggregateOutputType> | number
          }
        }
      }
      StatusChange: {
        payload: Prisma.$StatusChangePayload<ExtArgs>
        fields: Prisma.StatusChangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatusChangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatusChangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>
          }
          findFirst: {
            args: Prisma.StatusChangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatusChangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>
          }
          findMany: {
            args: Prisma.StatusChangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>[]
          }
          create: {
            args: Prisma.StatusChangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>
          }
          createMany: {
            args: Prisma.StatusChangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatusChangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>[]
          }
          delete: {
            args: Prisma.StatusChangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>
          }
          update: {
            args: Prisma.StatusChangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>
          }
          deleteMany: {
            args: Prisma.StatusChangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatusChangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StatusChangeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>[]
          }
          upsert: {
            args: Prisma.StatusChangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>
          }
          aggregate: {
            args: Prisma.StatusChangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatusChange>
          }
          groupBy: {
            args: Prisma.StatusChangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusChangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatusChangeCountArgs<ExtArgs>
            result: $Utils.Optional<StatusChangeCountAggregateOutputType> | number
          }
        }
      }
      ProductColour: {
        payload: Prisma.$ProductColourPayload<ExtArgs>
        fields: Prisma.ProductColourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductColourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductColourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColourPayload>
          }
          findFirst: {
            args: Prisma.ProductColourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductColourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColourPayload>
          }
          findMany: {
            args: Prisma.ProductColourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColourPayload>[]
          }
          create: {
            args: Prisma.ProductColourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColourPayload>
          }
          createMany: {
            args: Prisma.ProductColourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductColourCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColourPayload>[]
          }
          delete: {
            args: Prisma.ProductColourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColourPayload>
          }
          update: {
            args: Prisma.ProductColourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColourPayload>
          }
          deleteMany: {
            args: Prisma.ProductColourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductColourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductColourUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColourPayload>[]
          }
          upsert: {
            args: Prisma.ProductColourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColourPayload>
          }
          aggregate: {
            args: Prisma.ProductColourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductColour>
          }
          groupBy: {
            args: Prisma.ProductColourGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductColourGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductColourCountArgs<ExtArgs>
            result: $Utils.Optional<ProductColourCountAggregateOutputType> | number
          }
        }
      }
      ProductVariation: {
        payload: Prisma.$ProductVariationPayload<ExtArgs>
        fields: Prisma.ProductVariationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>
          }
          findFirst: {
            args: Prisma.ProductVariationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>
          }
          findMany: {
            args: Prisma.ProductVariationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>[]
          }
          create: {
            args: Prisma.ProductVariationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>
          }
          createMany: {
            args: Prisma.ProductVariationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductVariationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>[]
          }
          delete: {
            args: Prisma.ProductVariationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>
          }
          update: {
            args: Prisma.ProductVariationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>
          }
          deleteMany: {
            args: Prisma.ProductVariationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductVariationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>[]
          }
          upsert: {
            args: Prisma.ProductVariationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>
          }
          aggregate: {
            args: Prisma.ProductVariationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariation>
          }
          groupBy: {
            args: Prisma.ProductVariationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVariationCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariationCountAggregateOutputType> | number
          }
        }
      }
      ProductPhoto: {
        payload: Prisma.$ProductPhotoPayload<ExtArgs>
        fields: Prisma.ProductPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPhotoPayload>
          }
          findFirst: {
            args: Prisma.ProductPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPhotoPayload>
          }
          findMany: {
            args: Prisma.ProductPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPhotoPayload>[]
          }
          create: {
            args: Prisma.ProductPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPhotoPayload>
          }
          createMany: {
            args: Prisma.ProductPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPhotoPayload>[]
          }
          delete: {
            args: Prisma.ProductPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPhotoPayload>
          }
          update: {
            args: Prisma.ProductPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPhotoPayload>
          }
          deleteMany: {
            args: Prisma.ProductPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPhotoPayload>[]
          }
          upsert: {
            args: Prisma.ProductPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPhotoPayload>
          }
          aggregate: {
            args: Prisma.ProductPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductPhoto>
          }
          groupBy: {
            args: Prisma.ProductPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<ProductPhotoCountAggregateOutputType> | number
          }
        }
      }
      MaterialPurchaseAlert: {
        payload: Prisma.$MaterialPurchaseAlertPayload<ExtArgs>
        fields: Prisma.MaterialPurchaseAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialPurchaseAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPurchaseAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialPurchaseAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPurchaseAlertPayload>
          }
          findFirst: {
            args: Prisma.MaterialPurchaseAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPurchaseAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialPurchaseAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPurchaseAlertPayload>
          }
          findMany: {
            args: Prisma.MaterialPurchaseAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPurchaseAlertPayload>[]
          }
          create: {
            args: Prisma.MaterialPurchaseAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPurchaseAlertPayload>
          }
          createMany: {
            args: Prisma.MaterialPurchaseAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialPurchaseAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPurchaseAlertPayload>[]
          }
          delete: {
            args: Prisma.MaterialPurchaseAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPurchaseAlertPayload>
          }
          update: {
            args: Prisma.MaterialPurchaseAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPurchaseAlertPayload>
          }
          deleteMany: {
            args: Prisma.MaterialPurchaseAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialPurchaseAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialPurchaseAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPurchaseAlertPayload>[]
          }
          upsert: {
            args: Prisma.MaterialPurchaseAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPurchaseAlertPayload>
          }
          aggregate: {
            args: Prisma.MaterialPurchaseAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialPurchaseAlert>
          }
          groupBy: {
            args: Prisma.MaterialPurchaseAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialPurchaseAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialPurchaseAlertCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialPurchaseAlertCountAggregateOutputType> | number
          }
        }
      }
      PurchaseLog: {
        payload: Prisma.$PurchaseLogPayload<ExtArgs>
        fields: Prisma.PurchaseLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLogPayload>
          }
          findFirst: {
            args: Prisma.PurchaseLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLogPayload>
          }
          findMany: {
            args: Prisma.PurchaseLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLogPayload>[]
          }
          create: {
            args: Prisma.PurchaseLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLogPayload>
          }
          createMany: {
            args: Prisma.PurchaseLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLogPayload>[]
          }
          delete: {
            args: Prisma.PurchaseLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLogPayload>
          }
          update: {
            args: Prisma.PurchaseLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLogPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLogPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLogPayload>
          }
          aggregate: {
            args: Prisma.PurchaseLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseLog>
          }
          groupBy: {
            args: Prisma.PurchaseLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseLogCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseLogCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      ContactNote: {
        payload: Prisma.$ContactNotePayload<ExtArgs>
        fields: Prisma.ContactNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>
          }
          findFirst: {
            args: Prisma.ContactNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>
          }
          findMany: {
            args: Prisma.ContactNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>[]
          }
          create: {
            args: Prisma.ContactNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>
          }
          createMany: {
            args: Prisma.ContactNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>[]
          }
          delete: {
            args: Prisma.ContactNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>
          }
          update: {
            args: Prisma.ContactNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>
          }
          deleteMany: {
            args: Prisma.ContactNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>[]
          }
          upsert: {
            args: Prisma.ContactNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>
          }
          aggregate: {
            args: Prisma.ContactNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactNote>
          }
          groupBy: {
            args: Prisma.ContactNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactNoteCountArgs<ExtArgs>
            result: $Utils.Optional<ContactNoteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    material?: MaterialOmit
    product?: ProductOmit
    order?: OrderOmit
    orderProduct?: OrderProductOmit
    materialMovement?: MaterialMovementOmit
    progressReport?: ProgressReportOmit
    productProgressReport?: ProductProgressReportOmit
    productProgressPhoto?: ProductProgressPhotoOmit
    remainingMaterial?: RemainingMaterialOmit
    inventaris?: InventarisOmit
    orderLink?: OrderLinkOmit
    productMaterial?: ProductMaterialOmit
    shipment?: ShipmentOmit
    recurringPlan?: RecurringPlanOmit
    statusChange?: StatusChangeOmit
    productColour?: ProductColourOmit
    productVariation?: ProductVariationOmit
    productPhoto?: ProductPhotoOmit
    materialPurchaseAlert?: MaterialPurchaseAlertOmit
    purchaseLog?: PurchaseLogOmit
    contact?: ContactOmit
    contactNote?: ContactNoteOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    orders: number
    workerOrders: number
    materialMovements: number
    progressReports: number
    orderLinks: number
    statusChanges: number
    createdAlerts: number
    resolvedAlerts: number
    createdContactNotes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    workerOrders?: boolean | UserCountOutputTypeCountWorkerOrdersArgs
    materialMovements?: boolean | UserCountOutputTypeCountMaterialMovementsArgs
    progressReports?: boolean | UserCountOutputTypeCountProgressReportsArgs
    orderLinks?: boolean | UserCountOutputTypeCountOrderLinksArgs
    statusChanges?: boolean | UserCountOutputTypeCountStatusChangesArgs
    createdAlerts?: boolean | UserCountOutputTypeCountCreatedAlertsArgs
    resolvedAlerts?: boolean | UserCountOutputTypeCountResolvedAlertsArgs
    createdContactNotes?: boolean | UserCountOutputTypeCountCreatedContactNotesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkerOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMaterialMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialMovementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProgressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderLinkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStatusChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusChangeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialPurchaseAlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResolvedAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialPurchaseAlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedContactNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactNoteWhereInput
  }


  /**
   * Count Type MaterialCountOutputType
   */

  export type MaterialCountOutputType = {
    materialMovements: number
    productMaterials: number
    remainingMaterials: number
    products: number
    purchaseAlerts: number
    purchaseLogs: number
  }

  export type MaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materialMovements?: boolean | MaterialCountOutputTypeCountMaterialMovementsArgs
    productMaterials?: boolean | MaterialCountOutputTypeCountProductMaterialsArgs
    remainingMaterials?: boolean | MaterialCountOutputTypeCountRemainingMaterialsArgs
    products?: boolean | MaterialCountOutputTypeCountProductsArgs
    purchaseAlerts?: boolean | MaterialCountOutputTypeCountPurchaseAlertsArgs
    purchaseLogs?: boolean | MaterialCountOutputTypeCountPurchaseLogsArgs
  }

  // Custom InputTypes
  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCountOutputType
     */
    select?: MaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountMaterialMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialMovementWhereInput
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountProductMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductMaterialWhereInput
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountRemainingMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemainingMaterialWhereInput
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountPurchaseAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialPurchaseAlertWhereInput
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountPurchaseLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseLogWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderProducts: number
    productMaterials: number
    recurringPlans: number
    colours: number
    variations: number
    photos: number
    individualProgressReports: number
    productProgressReports: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderProducts?: boolean | ProductCountOutputTypeCountOrderProductsArgs
    productMaterials?: boolean | ProductCountOutputTypeCountProductMaterialsArgs
    recurringPlans?: boolean | ProductCountOutputTypeCountRecurringPlansArgs
    colours?: boolean | ProductCountOutputTypeCountColoursArgs
    variations?: boolean | ProductCountOutputTypeCountVariationsArgs
    photos?: boolean | ProductCountOutputTypeCountPhotosArgs
    individualProgressReports?: boolean | ProductCountOutputTypeCountIndividualProgressReportsArgs
    productProgressReports?: boolean | ProductCountOutputTypeCountProductProgressReportsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductMaterialWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRecurringPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringPlanWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountColoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductColourWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVariationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariationWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductPhotoWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountIndividualProgressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressReportWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductProgressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductProgressReportWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    orderProducts: number
    materialMovements: number
    progressReports: number
    statusChanges: number
    purchaseAlerts: number
    contactNotes: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderProducts?: boolean | OrderCountOutputTypeCountOrderProductsArgs
    materialMovements?: boolean | OrderCountOutputTypeCountMaterialMovementsArgs
    progressReports?: boolean | OrderCountOutputTypeCountProgressReportsArgs
    statusChanges?: boolean | OrderCountOutputTypeCountStatusChangesArgs
    purchaseAlerts?: boolean | OrderCountOutputTypeCountPurchaseAlertsArgs
    contactNotes?: boolean | OrderCountOutputTypeCountContactNotesArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderProductWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountMaterialMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialMovementWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountProgressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressReportWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountStatusChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusChangeWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPurchaseAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialPurchaseAlertWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountContactNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactNoteWhereInput
  }


  /**
   * Count Type OrderProductCountOutputType
   */

  export type OrderProductCountOutputType = {
    individualProgressReports: number
    productProgressReports: number
  }

  export type OrderProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    individualProgressReports?: boolean | OrderProductCountOutputTypeCountIndividualProgressReportsArgs
    productProgressReports?: boolean | OrderProductCountOutputTypeCountProductProgressReportsArgs
  }

  // Custom InputTypes
  /**
   * OrderProductCountOutputType without action
   */
  export type OrderProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProductCountOutputType
     */
    select?: OrderProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderProductCountOutputType without action
   */
  export type OrderProductCountOutputTypeCountIndividualProgressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressReportWhereInput
  }

  /**
   * OrderProductCountOutputType without action
   */
  export type OrderProductCountOutputTypeCountProductProgressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductProgressReportWhereInput
  }


  /**
   * Count Type ProgressReportCountOutputType
   */

  export type ProgressReportCountOutputType = {
    productReports: number
  }

  export type ProgressReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productReports?: boolean | ProgressReportCountOutputTypeCountProductReportsArgs
  }

  // Custom InputTypes
  /**
   * ProgressReportCountOutputType without action
   */
  export type ProgressReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReportCountOutputType
     */
    select?: ProgressReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgressReportCountOutputType without action
   */
  export type ProgressReportCountOutputTypeCountProductReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductProgressReportWhereInput
  }


  /**
   * Count Type ProductProgressReportCountOutputType
   */

  export type ProductProgressReportCountOutputType = {
    photos: number
  }

  export type ProductProgressReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | ProductProgressReportCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * ProductProgressReportCountOutputType without action
   */
  export type ProductProgressReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReportCountOutputType
     */
    select?: ProductProgressReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductProgressReportCountOutputType without action
   */
  export type ProductProgressReportCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductProgressPhotoWhereInput
  }


  /**
   * Count Type PurchaseLogCountOutputType
   */

  export type PurchaseLogCountOutputType = {
    contactNotes: number
  }

  export type PurchaseLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactNotes?: boolean | PurchaseLogCountOutputTypeCountContactNotesArgs
  }

  // Custom InputTypes
  /**
   * PurchaseLogCountOutputType without action
   */
  export type PurchaseLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLogCountOutputType
     */
    select?: PurchaseLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseLogCountOutputType without action
   */
  export type PurchaseLogCountOutputTypeCountContactNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactNoteWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    workerOrders: number
    contactNotes: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workerOrders?: boolean | ContactCountOutputTypeCountWorkerOrdersArgs
    contactNotes?: boolean | ContactCountOutputTypeCountContactNotesArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountWorkerOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountContactNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactNoteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    whatsappPhone: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    loginEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    whatsappPhone: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    loginEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    whatsappPhone: number
    passwordHash: number
    role: number
    isActive: number
    loginEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    whatsappPhone?: true
    passwordHash?: true
    role?: true
    isActive?: true
    loginEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    whatsappPhone?: true
    passwordHash?: true
    role?: true
    isActive?: true
    loginEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    whatsappPhone?: true
    passwordHash?: true
    role?: true
    isActive?: true
    loginEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    phone: string | null
    whatsappPhone: string | null
    passwordHash: string | null
    role: $Enums.UserRole
    isActive: boolean
    loginEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    whatsappPhone?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | User$ordersArgs<ExtArgs>
    workerOrders?: boolean | User$workerOrdersArgs<ExtArgs>
    materialMovements?: boolean | User$materialMovementsArgs<ExtArgs>
    progressReports?: boolean | User$progressReportsArgs<ExtArgs>
    orderLinks?: boolean | User$orderLinksArgs<ExtArgs>
    statusChanges?: boolean | User$statusChangesArgs<ExtArgs>
    createdAlerts?: boolean | User$createdAlertsArgs<ExtArgs>
    resolvedAlerts?: boolean | User$resolvedAlertsArgs<ExtArgs>
    createdContactNotes?: boolean | User$createdContactNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    whatsappPhone?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    whatsappPhone?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    whatsappPhone?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "whatsappPhone" | "passwordHash" | "role" | "isActive" | "loginEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | User$ordersArgs<ExtArgs>
    workerOrders?: boolean | User$workerOrdersArgs<ExtArgs>
    materialMovements?: boolean | User$materialMovementsArgs<ExtArgs>
    progressReports?: boolean | User$progressReportsArgs<ExtArgs>
    orderLinks?: boolean | User$orderLinksArgs<ExtArgs>
    statusChanges?: boolean | User$statusChangesArgs<ExtArgs>
    createdAlerts?: boolean | User$createdAlertsArgs<ExtArgs>
    resolvedAlerts?: boolean | User$resolvedAlertsArgs<ExtArgs>
    createdContactNotes?: boolean | User$createdContactNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      workerOrders: Prisma.$OrderPayload<ExtArgs>[]
      materialMovements: Prisma.$MaterialMovementPayload<ExtArgs>[]
      progressReports: Prisma.$ProgressReportPayload<ExtArgs>[]
      orderLinks: Prisma.$OrderLinkPayload<ExtArgs>[]
      statusChanges: Prisma.$StatusChangePayload<ExtArgs>[]
      createdAlerts: Prisma.$MaterialPurchaseAlertPayload<ExtArgs>[]
      resolvedAlerts: Prisma.$MaterialPurchaseAlertPayload<ExtArgs>[]
      createdContactNotes: Prisma.$ContactNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone: string | null
      whatsappPhone: string | null
      passwordHash: string | null
      role: $Enums.UserRole
      isActive: boolean
      loginEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workerOrders<T extends User$workerOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$workerOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materialMovements<T extends User$materialMovementsArgs<ExtArgs> = {}>(args?: Subset<T, User$materialMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progressReports<T extends User$progressReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$progressReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderLinks<T extends User$orderLinksArgs<ExtArgs> = {}>(args?: Subset<T, User$orderLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statusChanges<T extends User$statusChangesArgs<ExtArgs> = {}>(args?: Subset<T, User$statusChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdAlerts<T extends User$createdAlertsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resolvedAlerts<T extends User$resolvedAlertsArgs<ExtArgs> = {}>(args?: Subset<T, User$resolvedAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdContactNotes<T extends User$createdContactNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdContactNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly whatsappPhone: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly loginEnabled: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.workerOrders
   */
  export type User$workerOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.materialMovements
   */
  export type User$materialMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    where?: MaterialMovementWhereInput
    orderBy?: MaterialMovementOrderByWithRelationInput | MaterialMovementOrderByWithRelationInput[]
    cursor?: MaterialMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialMovementScalarFieldEnum | MaterialMovementScalarFieldEnum[]
  }

  /**
   * User.progressReports
   */
  export type User$progressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    where?: ProgressReportWhereInput
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    cursor?: ProgressReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressReportScalarFieldEnum | ProgressReportScalarFieldEnum[]
  }

  /**
   * User.orderLinks
   */
  export type User$orderLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkInclude<ExtArgs> | null
    where?: OrderLinkWhereInput
    orderBy?: OrderLinkOrderByWithRelationInput | OrderLinkOrderByWithRelationInput[]
    cursor?: OrderLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderLinkScalarFieldEnum | OrderLinkScalarFieldEnum[]
  }

  /**
   * User.statusChanges
   */
  export type User$statusChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null
    where?: StatusChangeWhereInput
    orderBy?: StatusChangeOrderByWithRelationInput | StatusChangeOrderByWithRelationInput[]
    cursor?: StatusChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatusChangeScalarFieldEnum | StatusChangeScalarFieldEnum[]
  }

  /**
   * User.createdAlerts
   */
  export type User$createdAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    where?: MaterialPurchaseAlertWhereInput
    orderBy?: MaterialPurchaseAlertOrderByWithRelationInput | MaterialPurchaseAlertOrderByWithRelationInput[]
    cursor?: MaterialPurchaseAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialPurchaseAlertScalarFieldEnum | MaterialPurchaseAlertScalarFieldEnum[]
  }

  /**
   * User.resolvedAlerts
   */
  export type User$resolvedAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    where?: MaterialPurchaseAlertWhereInput
    orderBy?: MaterialPurchaseAlertOrderByWithRelationInput | MaterialPurchaseAlertOrderByWithRelationInput[]
    cursor?: MaterialPurchaseAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialPurchaseAlertScalarFieldEnum | MaterialPurchaseAlertScalarFieldEnum[]
  }

  /**
   * User.createdContactNotes
   */
  export type User$createdContactNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    where?: ContactNoteWhereInput
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    cursor?: ContactNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactNoteScalarFieldEnum | ContactNoteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    id: number | null
    qtyOnHand: Decimal | null
    minStock: Decimal | null
    maxStock: Decimal | null
    reorderPoint: Decimal | null
    reorderQty: Decimal | null
  }

  export type MaterialSumAggregateOutputType = {
    id: number | null
    qtyOnHand: Decimal | null
    minStock: Decimal | null
    maxStock: Decimal | null
    reorderPoint: Decimal | null
    reorderQty: Decimal | null
  }

  export type MaterialMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    code: string | null
    unit: string | null
    qtyOnHand: Decimal | null
    minStock: Decimal | null
    maxStock: Decimal | null
    reorderPoint: Decimal | null
    reorderQty: Decimal | null
    location: string | null
    attributeType: string | null
    attributeValue: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    code: string | null
    unit: string | null
    qtyOnHand: Decimal | null
    minStock: Decimal | null
    maxStock: Decimal | null
    reorderPoint: Decimal | null
    reorderQty: Decimal | null
    location: string | null
    attributeType: string | null
    attributeValue: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    name: number
    description: number
    code: number
    unit: number
    qtyOnHand: number
    minStock: number
    maxStock: number
    reorderPoint: number
    reorderQty: number
    location: number
    attributeType: number
    attributeValue: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    id?: true
    qtyOnHand?: true
    minStock?: true
    maxStock?: true
    reorderPoint?: true
    reorderQty?: true
  }

  export type MaterialSumAggregateInputType = {
    id?: true
    qtyOnHand?: true
    minStock?: true
    maxStock?: true
    reorderPoint?: true
    reorderQty?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    unit?: true
    qtyOnHand?: true
    minStock?: true
    maxStock?: true
    reorderPoint?: true
    reorderQty?: true
    location?: true
    attributeType?: true
    attributeValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    unit?: true
    qtyOnHand?: true
    minStock?: true
    maxStock?: true
    reorderPoint?: true
    reorderQty?: true
    location?: true
    attributeType?: true
    attributeValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    unit?: true
    qtyOnHand?: true
    minStock?: true
    maxStock?: true
    reorderPoint?: true
    reorderQty?: true
    location?: true
    attributeType?: true
    attributeValue?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: number
    name: string
    description: string | null
    code: string
    unit: string
    qtyOnHand: Decimal
    minStock: Decimal
    maxStock: Decimal
    reorderPoint: Decimal
    reorderQty: Decimal
    location: string | null
    attributeType: string | null
    attributeValue: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    unit?: boolean
    qtyOnHand?: boolean
    minStock?: boolean
    maxStock?: boolean
    reorderPoint?: boolean
    reorderQty?: boolean
    location?: boolean
    attributeType?: boolean
    attributeValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    materialMovements?: boolean | Material$materialMovementsArgs<ExtArgs>
    productMaterials?: boolean | Material$productMaterialsArgs<ExtArgs>
    remainingMaterials?: boolean | Material$remainingMaterialsArgs<ExtArgs>
    products?: boolean | Material$productsArgs<ExtArgs>
    purchaseAlerts?: boolean | Material$purchaseAlertsArgs<ExtArgs>
    purchaseLogs?: boolean | Material$purchaseLogsArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    unit?: boolean
    qtyOnHand?: boolean
    minStock?: boolean
    maxStock?: boolean
    reorderPoint?: boolean
    reorderQty?: boolean
    location?: boolean
    attributeType?: boolean
    attributeValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    unit?: boolean
    qtyOnHand?: boolean
    minStock?: boolean
    maxStock?: boolean
    reorderPoint?: boolean
    reorderQty?: boolean
    location?: boolean
    attributeType?: boolean
    attributeValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    unit?: boolean
    qtyOnHand?: boolean
    minStock?: boolean
    maxStock?: boolean
    reorderPoint?: boolean
    reorderQty?: boolean
    location?: boolean
    attributeType?: boolean
    attributeValue?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "code" | "unit" | "qtyOnHand" | "minStock" | "maxStock" | "reorderPoint" | "reorderQty" | "location" | "attributeType" | "attributeValue" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["material"]>
  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materialMovements?: boolean | Material$materialMovementsArgs<ExtArgs>
    productMaterials?: boolean | Material$productMaterialsArgs<ExtArgs>
    remainingMaterials?: boolean | Material$remainingMaterialsArgs<ExtArgs>
    products?: boolean | Material$productsArgs<ExtArgs>
    purchaseAlerts?: boolean | Material$purchaseAlertsArgs<ExtArgs>
    purchaseLogs?: boolean | Material$purchaseLogsArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      materialMovements: Prisma.$MaterialMovementPayload<ExtArgs>[]
      productMaterials: Prisma.$ProductMaterialPayload<ExtArgs>[]
      remainingMaterials: Prisma.$RemainingMaterialPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      purchaseAlerts: Prisma.$MaterialPurchaseAlertPayload<ExtArgs>[]
      purchaseLogs: Prisma.$PurchaseLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      code: string
      unit: string
      qtyOnHand: Prisma.Decimal
      minStock: Prisma.Decimal
      maxStock: Prisma.Decimal
      reorderPoint: Prisma.Decimal
      reorderQty: Prisma.Decimal
      location: string | null
      attributeType: string | null
      attributeValue: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials and returns the data updated in the database.
     * @param {MaterialUpdateManyAndReturnArgs} args - Arguments to update many Materials.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materialMovements<T extends Material$materialMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Material$materialMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productMaterials<T extends Material$productMaterialsArgs<ExtArgs> = {}>(args?: Subset<T, Material$productMaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    remainingMaterials<T extends Material$remainingMaterialsArgs<ExtArgs> = {}>(args?: Subset<T, Material$remainingMaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemainingMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Material$productsArgs<ExtArgs> = {}>(args?: Subset<T, Material$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseAlerts<T extends Material$purchaseAlertsArgs<ExtArgs> = {}>(args?: Subset<T, Material$purchaseAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseLogs<T extends Material$purchaseLogsArgs<ExtArgs> = {}>(args?: Subset<T, Material$purchaseLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'Int'>
    readonly name: FieldRef<"Material", 'String'>
    readonly description: FieldRef<"Material", 'String'>
    readonly code: FieldRef<"Material", 'String'>
    readonly unit: FieldRef<"Material", 'String'>
    readonly qtyOnHand: FieldRef<"Material", 'Decimal'>
    readonly minStock: FieldRef<"Material", 'Decimal'>
    readonly maxStock: FieldRef<"Material", 'Decimal'>
    readonly reorderPoint: FieldRef<"Material", 'Decimal'>
    readonly reorderQty: FieldRef<"Material", 'Decimal'>
    readonly location: FieldRef<"Material", 'String'>
    readonly attributeType: FieldRef<"Material", 'String'>
    readonly attributeValue: FieldRef<"Material", 'String'>
    readonly isActive: FieldRef<"Material", 'Boolean'>
    readonly createdAt: FieldRef<"Material", 'DateTime'>
    readonly updatedAt: FieldRef<"Material", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material updateManyAndReturn
   */
  export type MaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to delete.
     */
    limit?: number
  }

  /**
   * Material.materialMovements
   */
  export type Material$materialMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    where?: MaterialMovementWhereInput
    orderBy?: MaterialMovementOrderByWithRelationInput | MaterialMovementOrderByWithRelationInput[]
    cursor?: MaterialMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialMovementScalarFieldEnum | MaterialMovementScalarFieldEnum[]
  }

  /**
   * Material.productMaterials
   */
  export type Material$productMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialInclude<ExtArgs> | null
    where?: ProductMaterialWhereInput
    orderBy?: ProductMaterialOrderByWithRelationInput | ProductMaterialOrderByWithRelationInput[]
    cursor?: ProductMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductMaterialScalarFieldEnum | ProductMaterialScalarFieldEnum[]
  }

  /**
   * Material.remainingMaterials
   */
  export type Material$remainingMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialInclude<ExtArgs> | null
    where?: RemainingMaterialWhereInput
    orderBy?: RemainingMaterialOrderByWithRelationInput | RemainingMaterialOrderByWithRelationInput[]
    cursor?: RemainingMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RemainingMaterialScalarFieldEnum | RemainingMaterialScalarFieldEnum[]
  }

  /**
   * Material.products
   */
  export type Material$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Material.purchaseAlerts
   */
  export type Material$purchaseAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    where?: MaterialPurchaseAlertWhereInput
    orderBy?: MaterialPurchaseAlertOrderByWithRelationInput | MaterialPurchaseAlertOrderByWithRelationInput[]
    cursor?: MaterialPurchaseAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialPurchaseAlertScalarFieldEnum | MaterialPurchaseAlertScalarFieldEnum[]
  }

  /**
   * Material.purchaseLogs
   */
  export type Material$purchaseLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
    where?: PurchaseLogWhereInput
    orderBy?: PurchaseLogOrderByWithRelationInput | PurchaseLogOrderByWithRelationInput[]
    cursor?: PurchaseLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseLogScalarFieldEnum | PurchaseLogScalarFieldEnum[]
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    materialId: number | null
    price: Decimal | null
    qtyOnHand: number | null
    defaultTarget: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    materialId: number | null
    price: Decimal | null
    qtyOnHand: number | null
    defaultTarget: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    materialId: number | null
    category: string | null
    price: Decimal | null
    qtyOnHand: number | null
    unit: string | null
    description: string | null
    defaultTarget: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    materialId: number | null
    category: string | null
    price: Decimal | null
    qtyOnHand: number | null
    unit: string | null
    description: string | null
    defaultTarget: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    code: number
    materialId: number
    category: number
    price: number
    qtyOnHand: number
    unit: number
    description: number
    defaultTarget: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    materialId?: true
    price?: true
    qtyOnHand?: true
    defaultTarget?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    materialId?: true
    price?: true
    qtyOnHand?: true
    defaultTarget?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    materialId?: true
    category?: true
    price?: true
    qtyOnHand?: true
    unit?: true
    description?: true
    defaultTarget?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    materialId?: true
    category?: true
    price?: true
    qtyOnHand?: true
    unit?: true
    description?: true
    defaultTarget?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    materialId?: true
    category?: true
    price?: true
    qtyOnHand?: true
    unit?: true
    description?: true
    defaultTarget?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    code: string
    materialId: number | null
    category: string | null
    price: Decimal | null
    qtyOnHand: number
    unit: string
    description: string | null
    defaultTarget: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    materialId?: boolean
    category?: boolean
    price?: boolean
    qtyOnHand?: boolean
    unit?: boolean
    description?: boolean
    defaultTarget?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    baseMaterial?: boolean | Product$baseMaterialArgs<ExtArgs>
    orderProducts?: boolean | Product$orderProductsArgs<ExtArgs>
    productMaterials?: boolean | Product$productMaterialsArgs<ExtArgs>
    recurringPlans?: boolean | Product$recurringPlansArgs<ExtArgs>
    colours?: boolean | Product$coloursArgs<ExtArgs>
    variations?: boolean | Product$variationsArgs<ExtArgs>
    photos?: boolean | Product$photosArgs<ExtArgs>
    individualProgressReports?: boolean | Product$individualProgressReportsArgs<ExtArgs>
    productProgressReports?: boolean | Product$productProgressReportsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    materialId?: boolean
    category?: boolean
    price?: boolean
    qtyOnHand?: boolean
    unit?: boolean
    description?: boolean
    defaultTarget?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    baseMaterial?: boolean | Product$baseMaterialArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    materialId?: boolean
    category?: boolean
    price?: boolean
    qtyOnHand?: boolean
    unit?: boolean
    description?: boolean
    defaultTarget?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    baseMaterial?: boolean | Product$baseMaterialArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    materialId?: boolean
    category?: boolean
    price?: boolean
    qtyOnHand?: boolean
    unit?: boolean
    description?: boolean
    defaultTarget?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "materialId" | "category" | "price" | "qtyOnHand" | "unit" | "description" | "defaultTarget" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baseMaterial?: boolean | Product$baseMaterialArgs<ExtArgs>
    orderProducts?: boolean | Product$orderProductsArgs<ExtArgs>
    productMaterials?: boolean | Product$productMaterialsArgs<ExtArgs>
    recurringPlans?: boolean | Product$recurringPlansArgs<ExtArgs>
    colours?: boolean | Product$coloursArgs<ExtArgs>
    variations?: boolean | Product$variationsArgs<ExtArgs>
    photos?: boolean | Product$photosArgs<ExtArgs>
    individualProgressReports?: boolean | Product$individualProgressReportsArgs<ExtArgs>
    productProgressReports?: boolean | Product$productProgressReportsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baseMaterial?: boolean | Product$baseMaterialArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baseMaterial?: boolean | Product$baseMaterialArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      baseMaterial: Prisma.$MaterialPayload<ExtArgs> | null
      orderProducts: Prisma.$OrderProductPayload<ExtArgs>[]
      productMaterials: Prisma.$ProductMaterialPayload<ExtArgs>[]
      recurringPlans: Prisma.$RecurringPlanPayload<ExtArgs>[]
      colours: Prisma.$ProductColourPayload<ExtArgs>[]
      variations: Prisma.$ProductVariationPayload<ExtArgs>[]
      photos: Prisma.$ProductPhotoPayload<ExtArgs>[]
      individualProgressReports: Prisma.$ProgressReportPayload<ExtArgs>[]
      productProgressReports: Prisma.$ProductProgressReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      materialId: number | null
      category: string | null
      price: Prisma.Decimal | null
      qtyOnHand: number
      unit: string
      description: string | null
      defaultTarget: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    baseMaterial<T extends Product$baseMaterialArgs<ExtArgs> = {}>(args?: Subset<T, Product$baseMaterialArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orderProducts<T extends Product$orderProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productMaterials<T extends Product$productMaterialsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productMaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringPlans<T extends Product$recurringPlansArgs<ExtArgs> = {}>(args?: Subset<T, Product$recurringPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    colours<T extends Product$coloursArgs<ExtArgs> = {}>(args?: Subset<T, Product$coloursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductColourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    variations<T extends Product$variationsArgs<ExtArgs> = {}>(args?: Subset<T, Product$variationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos<T extends Product$photosArgs<ExtArgs> = {}>(args?: Subset<T, Product$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    individualProgressReports<T extends Product$individualProgressReportsArgs<ExtArgs> = {}>(args?: Subset<T, Product$individualProgressReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productProgressReports<T extends Product$productProgressReportsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productProgressReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly code: FieldRef<"Product", 'String'>
    readonly materialId: FieldRef<"Product", 'Int'>
    readonly category: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly qtyOnHand: FieldRef<"Product", 'Int'>
    readonly unit: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly defaultTarget: FieldRef<"Product", 'Int'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.baseMaterial
   */
  export type Product$baseMaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
  }

  /**
   * Product.orderProducts
   */
  export type Product$orderProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    where?: OrderProductWhereInput
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    cursor?: OrderProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }

  /**
   * Product.productMaterials
   */
  export type Product$productMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialInclude<ExtArgs> | null
    where?: ProductMaterialWhereInput
    orderBy?: ProductMaterialOrderByWithRelationInput | ProductMaterialOrderByWithRelationInput[]
    cursor?: ProductMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductMaterialScalarFieldEnum | ProductMaterialScalarFieldEnum[]
  }

  /**
   * Product.recurringPlans
   */
  export type Product$recurringPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanInclude<ExtArgs> | null
    where?: RecurringPlanWhereInput
    orderBy?: RecurringPlanOrderByWithRelationInput | RecurringPlanOrderByWithRelationInput[]
    cursor?: RecurringPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringPlanScalarFieldEnum | RecurringPlanScalarFieldEnum[]
  }

  /**
   * Product.colours
   */
  export type Product$coloursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourInclude<ExtArgs> | null
    where?: ProductColourWhereInput
    orderBy?: ProductColourOrderByWithRelationInput | ProductColourOrderByWithRelationInput[]
    cursor?: ProductColourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductColourScalarFieldEnum | ProductColourScalarFieldEnum[]
  }

  /**
   * Product.variations
   */
  export type Product$variationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    where?: ProductVariationWhereInput
    orderBy?: ProductVariationOrderByWithRelationInput | ProductVariationOrderByWithRelationInput[]
    cursor?: ProductVariationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductVariationScalarFieldEnum | ProductVariationScalarFieldEnum[]
  }

  /**
   * Product.photos
   */
  export type Product$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoInclude<ExtArgs> | null
    where?: ProductPhotoWhereInput
    orderBy?: ProductPhotoOrderByWithRelationInput | ProductPhotoOrderByWithRelationInput[]
    cursor?: ProductPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductPhotoScalarFieldEnum | ProductPhotoScalarFieldEnum[]
  }

  /**
   * Product.individualProgressReports
   */
  export type Product$individualProgressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    where?: ProgressReportWhereInput
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    cursor?: ProgressReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressReportScalarFieldEnum | ProgressReportScalarFieldEnum[]
  }

  /**
   * Product.productProgressReports
   */
  export type Product$productProgressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
    where?: ProductProgressReportWhereInput
    orderBy?: ProductProgressReportOrderByWithRelationInput | ProductProgressReportOrderByWithRelationInput[]
    cursor?: ProductProgressReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductProgressReportScalarFieldEnum | ProductProgressReportScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    targetPcs: number | null
    completedPcs: number | null
    userId: number | null
    workerId: number | null
    workerContactId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    targetPcs: number | null
    completedPcs: number | null
    userId: number | null
    workerId: number | null
    workerContactId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    orderNumber: string | null
    status: $Enums.OrderStatus | null
    targetPcs: number | null
    completedPcs: number | null
    customerNote: string | null
    dueDate: Date | null
    userId: number | null
    workerId: number | null
    workerContactId: number | null
    description: string | null
    priority: $Enums.Priority | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    orderNumber: string | null
    status: $Enums.OrderStatus | null
    targetPcs: number | null
    completedPcs: number | null
    customerNote: string | null
    dueDate: Date | null
    userId: number | null
    workerId: number | null
    workerContactId: number | null
    description: string | null
    priority: $Enums.Priority | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    status: number
    targetPcs: number
    completedPcs: number
    customerNote: number
    dueDate: number
    userId: number
    workerId: number
    workerContactId: number
    description: number
    priority: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    targetPcs?: true
    completedPcs?: true
    userId?: true
    workerId?: true
    workerContactId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    targetPcs?: true
    completedPcs?: true
    userId?: true
    workerId?: true
    workerContactId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    status?: true
    targetPcs?: true
    completedPcs?: true
    customerNote?: true
    dueDate?: true
    userId?: true
    workerId?: true
    workerContactId?: true
    description?: true
    priority?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    status?: true
    targetPcs?: true
    completedPcs?: true
    customerNote?: true
    dueDate?: true
    userId?: true
    workerId?: true
    workerContactId?: true
    description?: true
    priority?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    status?: true
    targetPcs?: true
    completedPcs?: true
    customerNote?: true
    dueDate?: true
    userId?: true
    workerId?: true
    workerContactId?: true
    description?: true
    priority?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    orderNumber: string
    status: $Enums.OrderStatus
    targetPcs: number
    completedPcs: number
    customerNote: string | null
    dueDate: Date | null
    userId: number
    workerId: number | null
    workerContactId: number | null
    description: string | null
    priority: $Enums.Priority
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    targetPcs?: boolean
    completedPcs?: boolean
    customerNote?: boolean
    dueDate?: boolean
    userId?: boolean
    workerId?: boolean
    workerContactId?: boolean
    description?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    worker?: boolean | Order$workerArgs<ExtArgs>
    workerContact?: boolean | Order$workerContactArgs<ExtArgs>
    orderProducts?: boolean | Order$orderProductsArgs<ExtArgs>
    materialMovements?: boolean | Order$materialMovementsArgs<ExtArgs>
    progressReports?: boolean | Order$progressReportsArgs<ExtArgs>
    orderLink?: boolean | Order$orderLinkArgs<ExtArgs>
    shipment?: boolean | Order$shipmentArgs<ExtArgs>
    statusChanges?: boolean | Order$statusChangesArgs<ExtArgs>
    purchaseAlerts?: boolean | Order$purchaseAlertsArgs<ExtArgs>
    contactNotes?: boolean | Order$contactNotesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    targetPcs?: boolean
    completedPcs?: boolean
    customerNote?: boolean
    dueDate?: boolean
    userId?: boolean
    workerId?: boolean
    workerContactId?: boolean
    description?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    worker?: boolean | Order$workerArgs<ExtArgs>
    workerContact?: boolean | Order$workerContactArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    targetPcs?: boolean
    completedPcs?: boolean
    customerNote?: boolean
    dueDate?: boolean
    userId?: boolean
    workerId?: boolean
    workerContactId?: boolean
    description?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    worker?: boolean | Order$workerArgs<ExtArgs>
    workerContact?: boolean | Order$workerContactArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    targetPcs?: boolean
    completedPcs?: boolean
    customerNote?: boolean
    dueDate?: boolean
    userId?: boolean
    workerId?: boolean
    workerContactId?: boolean
    description?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "status" | "targetPcs" | "completedPcs" | "customerNote" | "dueDate" | "userId" | "workerId" | "workerContactId" | "description" | "priority" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    worker?: boolean | Order$workerArgs<ExtArgs>
    workerContact?: boolean | Order$workerContactArgs<ExtArgs>
    orderProducts?: boolean | Order$orderProductsArgs<ExtArgs>
    materialMovements?: boolean | Order$materialMovementsArgs<ExtArgs>
    progressReports?: boolean | Order$progressReportsArgs<ExtArgs>
    orderLink?: boolean | Order$orderLinkArgs<ExtArgs>
    shipment?: boolean | Order$shipmentArgs<ExtArgs>
    statusChanges?: boolean | Order$statusChangesArgs<ExtArgs>
    purchaseAlerts?: boolean | Order$purchaseAlertsArgs<ExtArgs>
    contactNotes?: boolean | Order$contactNotesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    worker?: boolean | Order$workerArgs<ExtArgs>
    workerContact?: boolean | Order$workerContactArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    worker?: boolean | Order$workerArgs<ExtArgs>
    workerContact?: boolean | Order$workerContactArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      worker: Prisma.$UserPayload<ExtArgs> | null
      workerContact: Prisma.$ContactPayload<ExtArgs> | null
      orderProducts: Prisma.$OrderProductPayload<ExtArgs>[]
      materialMovements: Prisma.$MaterialMovementPayload<ExtArgs>[]
      progressReports: Prisma.$ProgressReportPayload<ExtArgs>[]
      orderLink: Prisma.$OrderLinkPayload<ExtArgs> | null
      shipment: Prisma.$ShipmentPayload<ExtArgs> | null
      statusChanges: Prisma.$StatusChangePayload<ExtArgs>[]
      purchaseAlerts: Prisma.$MaterialPurchaseAlertPayload<ExtArgs>[]
      contactNotes: Prisma.$ContactNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderNumber: string
      status: $Enums.OrderStatus
      targetPcs: number
      completedPcs: number
      customerNote: string | null
      dueDate: Date | null
      userId: number
      workerId: number | null
      workerContactId: number | null
      description: string | null
      priority: $Enums.Priority
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    worker<T extends Order$workerArgs<ExtArgs> = {}>(args?: Subset<T, Order$workerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workerContact<T extends Order$workerContactArgs<ExtArgs> = {}>(args?: Subset<T, Order$workerContactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orderProducts<T extends Order$orderProductsArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materialMovements<T extends Order$materialMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Order$materialMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progressReports<T extends Order$progressReportsArgs<ExtArgs> = {}>(args?: Subset<T, Order$progressReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderLink<T extends Order$orderLinkArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderLinkArgs<ExtArgs>>): Prisma__OrderLinkClient<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shipment<T extends Order$shipmentArgs<ExtArgs> = {}>(args?: Subset<T, Order$shipmentArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    statusChanges<T extends Order$statusChangesArgs<ExtArgs> = {}>(args?: Subset<T, Order$statusChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseAlerts<T extends Order$purchaseAlertsArgs<ExtArgs> = {}>(args?: Subset<T, Order$purchaseAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contactNotes<T extends Order$contactNotesArgs<ExtArgs> = {}>(args?: Subset<T, Order$contactNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly targetPcs: FieldRef<"Order", 'Int'>
    readonly completedPcs: FieldRef<"Order", 'Int'>
    readonly customerNote: FieldRef<"Order", 'String'>
    readonly dueDate: FieldRef<"Order", 'DateTime'>
    readonly userId: FieldRef<"Order", 'Int'>
    readonly workerId: FieldRef<"Order", 'Int'>
    readonly workerContactId: FieldRef<"Order", 'Int'>
    readonly description: FieldRef<"Order", 'String'>
    readonly priority: FieldRef<"Order", 'Priority'>
    readonly isActive: FieldRef<"Order", 'Boolean'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.worker
   */
  export type Order$workerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.workerContact
   */
  export type Order$workerContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Order.orderProducts
   */
  export type Order$orderProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    where?: OrderProductWhereInput
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    cursor?: OrderProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }

  /**
   * Order.materialMovements
   */
  export type Order$materialMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    where?: MaterialMovementWhereInput
    orderBy?: MaterialMovementOrderByWithRelationInput | MaterialMovementOrderByWithRelationInput[]
    cursor?: MaterialMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialMovementScalarFieldEnum | MaterialMovementScalarFieldEnum[]
  }

  /**
   * Order.progressReports
   */
  export type Order$progressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    where?: ProgressReportWhereInput
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    cursor?: ProgressReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressReportScalarFieldEnum | ProgressReportScalarFieldEnum[]
  }

  /**
   * Order.orderLink
   */
  export type Order$orderLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkInclude<ExtArgs> | null
    where?: OrderLinkWhereInput
  }

  /**
   * Order.shipment
   */
  export type Order$shipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
  }

  /**
   * Order.statusChanges
   */
  export type Order$statusChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null
    where?: StatusChangeWhereInput
    orderBy?: StatusChangeOrderByWithRelationInput | StatusChangeOrderByWithRelationInput[]
    cursor?: StatusChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatusChangeScalarFieldEnum | StatusChangeScalarFieldEnum[]
  }

  /**
   * Order.purchaseAlerts
   */
  export type Order$purchaseAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    where?: MaterialPurchaseAlertWhereInput
    orderBy?: MaterialPurchaseAlertOrderByWithRelationInput | MaterialPurchaseAlertOrderByWithRelationInput[]
    cursor?: MaterialPurchaseAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialPurchaseAlertScalarFieldEnum | MaterialPurchaseAlertScalarFieldEnum[]
  }

  /**
   * Order.contactNotes
   */
  export type Order$contactNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    where?: ContactNoteWhereInput
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    cursor?: ContactNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactNoteScalarFieldEnum | ContactNoteScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderProduct
   */

  export type AggregateOrderProduct = {
    _count: OrderProductCountAggregateOutputType | null
    _avg: OrderProductAvgAggregateOutputType | null
    _sum: OrderProductSumAggregateOutputType | null
    _min: OrderProductMinAggregateOutputType | null
    _max: OrderProductMaxAggregateOutputType | null
  }

  export type OrderProductAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    completedQty: number | null
  }

  export type OrderProductSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    completedQty: number | null
  }

  export type OrderProductMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    notes: string | null
    completedQty: number | null
    status: $Enums.OrderProductStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderProductMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    notes: string | null
    completedQty: number | null
    status: $Enums.OrderProductStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderProductCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    notes: number
    completedQty: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderProductAvgAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    completedQty?: true
  }

  export type OrderProductSumAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    completedQty?: true
  }

  export type OrderProductMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    notes?: true
    completedQty?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderProductMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    notes?: true
    completedQty?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderProductCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    notes?: true
    completedQty?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderProduct to aggregate.
     */
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     */
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderProducts
    **/
    _count?: true | OrderProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderProductMaxAggregateInputType
  }

  export type GetOrderProductAggregateType<T extends OrderProductAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderProduct[P]>
      : GetScalarType<T[P], AggregateOrderProduct[P]>
  }




  export type OrderProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderProductWhereInput
    orderBy?: OrderProductOrderByWithAggregationInput | OrderProductOrderByWithAggregationInput[]
    by: OrderProductScalarFieldEnum[] | OrderProductScalarFieldEnum
    having?: OrderProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderProductCountAggregateInputType | true
    _avg?: OrderProductAvgAggregateInputType
    _sum?: OrderProductSumAggregateInputType
    _min?: OrderProductMinAggregateInputType
    _max?: OrderProductMaxAggregateInputType
  }

  export type OrderProductGroupByOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    notes: string | null
    completedQty: number
    status: $Enums.OrderProductStatus
    createdAt: Date
    updatedAt: Date
    _count: OrderProductCountAggregateOutputType | null
    _avg: OrderProductAvgAggregateOutputType | null
    _sum: OrderProductSumAggregateOutputType | null
    _min: OrderProductMinAggregateOutputType | null
    _max: OrderProductMaxAggregateOutputType | null
  }

  type GetOrderProductGroupByPayload<T extends OrderProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderProductGroupByOutputType[P]>
            : GetScalarType<T[P], OrderProductGroupByOutputType[P]>
        }
      >
    >


  export type OrderProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    notes?: boolean
    completedQty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    individualProgressReports?: boolean | OrderProduct$individualProgressReportsArgs<ExtArgs>
    productProgressReports?: boolean | OrderProduct$productProgressReportsArgs<ExtArgs>
    _count?: boolean | OrderProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderProduct"]>

  export type OrderProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    notes?: boolean
    completedQty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderProduct"]>

  export type OrderProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    notes?: boolean
    completedQty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderProduct"]>

  export type OrderProductSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    notes?: boolean
    completedQty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quantity" | "unitPrice" | "totalPrice" | "notes" | "completedQty" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["orderProduct"]>
  export type OrderProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    individualProgressReports?: boolean | OrderProduct$individualProgressReportsArgs<ExtArgs>
    productProgressReports?: boolean | OrderProduct$productProgressReportsArgs<ExtArgs>
    _count?: boolean | OrderProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderProduct"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      individualProgressReports: Prisma.$ProgressReportPayload<ExtArgs>[]
      productProgressReports: Prisma.$ProductProgressReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      productId: number
      quantity: number
      unitPrice: Prisma.Decimal | null
      totalPrice: Prisma.Decimal | null
      notes: string | null
      completedQty: number
      status: $Enums.OrderProductStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderProduct"]>
    composites: {}
  }

  type OrderProductGetPayload<S extends boolean | null | undefined | OrderProductDefaultArgs> = $Result.GetResult<Prisma.$OrderProductPayload, S>

  type OrderProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderProductCountAggregateInputType | true
    }

  export interface OrderProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderProduct'], meta: { name: 'OrderProduct' } }
    /**
     * Find zero or one OrderProduct that matches the filter.
     * @param {OrderProductFindUniqueArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderProductFindUniqueArgs>(args: SelectSubset<T, OrderProductFindUniqueArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderProductFindUniqueOrThrowArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderProductFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductFindFirstArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderProductFindFirstArgs>(args?: SelectSubset<T, OrderProductFindFirstArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductFindFirstOrThrowArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderProductFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderProducts
     * const orderProducts = await prisma.orderProduct.findMany()
     * 
     * // Get first 10 OrderProducts
     * const orderProducts = await prisma.orderProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderProductWithIdOnly = await prisma.orderProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderProductFindManyArgs>(args?: SelectSubset<T, OrderProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderProduct.
     * @param {OrderProductCreateArgs} args - Arguments to create a OrderProduct.
     * @example
     * // Create one OrderProduct
     * const OrderProduct = await prisma.orderProduct.create({
     *   data: {
     *     // ... data to create a OrderProduct
     *   }
     * })
     * 
     */
    create<T extends OrderProductCreateArgs>(args: SelectSubset<T, OrderProductCreateArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderProducts.
     * @param {OrderProductCreateManyArgs} args - Arguments to create many OrderProducts.
     * @example
     * // Create many OrderProducts
     * const orderProduct = await prisma.orderProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderProductCreateManyArgs>(args?: SelectSubset<T, OrderProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderProducts and returns the data saved in the database.
     * @param {OrderProductCreateManyAndReturnArgs} args - Arguments to create many OrderProducts.
     * @example
     * // Create many OrderProducts
     * const orderProduct = await prisma.orderProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderProducts and only return the `id`
     * const orderProductWithIdOnly = await prisma.orderProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderProductCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderProduct.
     * @param {OrderProductDeleteArgs} args - Arguments to delete one OrderProduct.
     * @example
     * // Delete one OrderProduct
     * const OrderProduct = await prisma.orderProduct.delete({
     *   where: {
     *     // ... filter to delete one OrderProduct
     *   }
     * })
     * 
     */
    delete<T extends OrderProductDeleteArgs>(args: SelectSubset<T, OrderProductDeleteArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderProduct.
     * @param {OrderProductUpdateArgs} args - Arguments to update one OrderProduct.
     * @example
     * // Update one OrderProduct
     * const orderProduct = await prisma.orderProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderProductUpdateArgs>(args: SelectSubset<T, OrderProductUpdateArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderProducts.
     * @param {OrderProductDeleteManyArgs} args - Arguments to filter OrderProducts to delete.
     * @example
     * // Delete a few OrderProducts
     * const { count } = await prisma.orderProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderProductDeleteManyArgs>(args?: SelectSubset<T, OrderProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderProducts
     * const orderProduct = await prisma.orderProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderProductUpdateManyArgs>(args: SelectSubset<T, OrderProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderProducts and returns the data updated in the database.
     * @param {OrderProductUpdateManyAndReturnArgs} args - Arguments to update many OrderProducts.
     * @example
     * // Update many OrderProducts
     * const orderProduct = await prisma.orderProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderProducts and only return the `id`
     * const orderProductWithIdOnly = await prisma.orderProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderProductUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderProduct.
     * @param {OrderProductUpsertArgs} args - Arguments to update or create a OrderProduct.
     * @example
     * // Update or create a OrderProduct
     * const orderProduct = await prisma.orderProduct.upsert({
     *   create: {
     *     // ... data to create a OrderProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderProduct we want to update
     *   }
     * })
     */
    upsert<T extends OrderProductUpsertArgs>(args: SelectSubset<T, OrderProductUpsertArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductCountArgs} args - Arguments to filter OrderProducts to count.
     * @example
     * // Count the number of OrderProducts
     * const count = await prisma.orderProduct.count({
     *   where: {
     *     // ... the filter for the OrderProducts we want to count
     *   }
     * })
    **/
    count<T extends OrderProductCountArgs>(
      args?: Subset<T, OrderProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderProductAggregateArgs>(args: Subset<T, OrderProductAggregateArgs>): Prisma.PrismaPromise<GetOrderProductAggregateType<T>>

    /**
     * Group by OrderProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderProductGroupByArgs['orderBy'] }
        : { orderBy?: OrderProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderProduct model
   */
  readonly fields: OrderProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    individualProgressReports<T extends OrderProduct$individualProgressReportsArgs<ExtArgs> = {}>(args?: Subset<T, OrderProduct$individualProgressReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productProgressReports<T extends OrderProduct$productProgressReportsArgs<ExtArgs> = {}>(args?: Subset<T, OrderProduct$productProgressReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderProduct model
   */
  interface OrderProductFieldRefs {
    readonly id: FieldRef<"OrderProduct", 'Int'>
    readonly orderId: FieldRef<"OrderProduct", 'Int'>
    readonly productId: FieldRef<"OrderProduct", 'Int'>
    readonly quantity: FieldRef<"OrderProduct", 'Int'>
    readonly unitPrice: FieldRef<"OrderProduct", 'Decimal'>
    readonly totalPrice: FieldRef<"OrderProduct", 'Decimal'>
    readonly notes: FieldRef<"OrderProduct", 'String'>
    readonly completedQty: FieldRef<"OrderProduct", 'Int'>
    readonly status: FieldRef<"OrderProduct", 'OrderProductStatus'>
    readonly createdAt: FieldRef<"OrderProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderProduct findUnique
   */
  export type OrderProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduct to fetch.
     */
    where: OrderProductWhereUniqueInput
  }

  /**
   * OrderProduct findUniqueOrThrow
   */
  export type OrderProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduct to fetch.
     */
    where: OrderProductWhereUniqueInput
  }

  /**
   * OrderProduct findFirst
   */
  export type OrderProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduct to fetch.
     */
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     */
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderProducts.
     */
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderProducts.
     */
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }

  /**
   * OrderProduct findFirstOrThrow
   */
  export type OrderProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduct to fetch.
     */
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     */
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderProducts.
     */
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderProducts.
     */
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }

  /**
   * OrderProduct findMany
   */
  export type OrderProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProducts to fetch.
     */
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     */
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderProducts.
     */
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     */
    skip?: number
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }

  /**
   * OrderProduct create
   */
  export type OrderProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderProduct.
     */
    data: XOR<OrderProductCreateInput, OrderProductUncheckedCreateInput>
  }

  /**
   * OrderProduct createMany
   */
  export type OrderProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderProducts.
     */
    data: OrderProductCreateManyInput | OrderProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderProduct createManyAndReturn
   */
  export type OrderProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * The data used to create many OrderProducts.
     */
    data: OrderProductCreateManyInput | OrderProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderProduct update
   */
  export type OrderProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderProduct.
     */
    data: XOR<OrderProductUpdateInput, OrderProductUncheckedUpdateInput>
    /**
     * Choose, which OrderProduct to update.
     */
    where: OrderProductWhereUniqueInput
  }

  /**
   * OrderProduct updateMany
   */
  export type OrderProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderProducts.
     */
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyInput>
    /**
     * Filter which OrderProducts to update
     */
    where?: OrderProductWhereInput
    /**
     * Limit how many OrderProducts to update.
     */
    limit?: number
  }

  /**
   * OrderProduct updateManyAndReturn
   */
  export type OrderProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * The data used to update OrderProducts.
     */
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyInput>
    /**
     * Filter which OrderProducts to update
     */
    where?: OrderProductWhereInput
    /**
     * Limit how many OrderProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderProduct upsert
   */
  export type OrderProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderProduct to update in case it exists.
     */
    where: OrderProductWhereUniqueInput
    /**
     * In case the OrderProduct found by the `where` argument doesn't exist, create a new OrderProduct with this data.
     */
    create: XOR<OrderProductCreateInput, OrderProductUncheckedCreateInput>
    /**
     * In case the OrderProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderProductUpdateInput, OrderProductUncheckedUpdateInput>
  }

  /**
   * OrderProduct delete
   */
  export type OrderProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter which OrderProduct to delete.
     */
    where: OrderProductWhereUniqueInput
  }

  /**
   * OrderProduct deleteMany
   */
  export type OrderProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderProducts to delete
     */
    where?: OrderProductWhereInput
    /**
     * Limit how many OrderProducts to delete.
     */
    limit?: number
  }

  /**
   * OrderProduct.individualProgressReports
   */
  export type OrderProduct$individualProgressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    where?: ProgressReportWhereInput
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    cursor?: ProgressReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressReportScalarFieldEnum | ProgressReportScalarFieldEnum[]
  }

  /**
   * OrderProduct.productProgressReports
   */
  export type OrderProduct$productProgressReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
    where?: ProductProgressReportWhereInput
    orderBy?: ProductProgressReportOrderByWithRelationInput | ProductProgressReportOrderByWithRelationInput[]
    cursor?: ProductProgressReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductProgressReportScalarFieldEnum | ProductProgressReportScalarFieldEnum[]
  }

  /**
   * OrderProduct without action
   */
  export type OrderProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
  }


  /**
   * Model MaterialMovement
   */

  export type AggregateMaterialMovement = {
    _count: MaterialMovementCountAggregateOutputType | null
    _avg: MaterialMovementAvgAggregateOutputType | null
    _sum: MaterialMovementSumAggregateOutputType | null
    _min: MaterialMovementMinAggregateOutputType | null
    _max: MaterialMovementMaxAggregateOutputType | null
  }

  export type MaterialMovementAvgAggregateOutputType = {
    id: number | null
    materialId: number | null
    orderId: number | null
    userId: number | null
    purchaseLogId: number | null
    quantity: Decimal | null
    costPerUnit: Decimal | null
    totalCost: Decimal | null
    qtyAfter: Decimal | null
  }

  export type MaterialMovementSumAggregateOutputType = {
    id: number | null
    materialId: number | null
    orderId: number | null
    userId: number | null
    purchaseLogId: number | null
    quantity: Decimal | null
    costPerUnit: Decimal | null
    totalCost: Decimal | null
    qtyAfter: Decimal | null
  }

  export type MaterialMovementMinAggregateOutputType = {
    id: number | null
    materialId: number | null
    orderId: number | null
    userId: number | null
    purchaseLogId: number | null
    movementType: $Enums.MaterialMovementType | null
    quantity: Decimal | null
    unit: string | null
    costPerUnit: Decimal | null
    totalCost: Decimal | null
    notes: string | null
    qtyAfter: Decimal | null
    movementDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialMovementMaxAggregateOutputType = {
    id: number | null
    materialId: number | null
    orderId: number | null
    userId: number | null
    purchaseLogId: number | null
    movementType: $Enums.MaterialMovementType | null
    quantity: Decimal | null
    unit: string | null
    costPerUnit: Decimal | null
    totalCost: Decimal | null
    notes: string | null
    qtyAfter: Decimal | null
    movementDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialMovementCountAggregateOutputType = {
    id: number
    materialId: number
    orderId: number
    userId: number
    purchaseLogId: number
    movementType: number
    quantity: number
    unit: number
    costPerUnit: number
    totalCost: number
    notes: number
    qtyAfter: number
    movementDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterialMovementAvgAggregateInputType = {
    id?: true
    materialId?: true
    orderId?: true
    userId?: true
    purchaseLogId?: true
    quantity?: true
    costPerUnit?: true
    totalCost?: true
    qtyAfter?: true
  }

  export type MaterialMovementSumAggregateInputType = {
    id?: true
    materialId?: true
    orderId?: true
    userId?: true
    purchaseLogId?: true
    quantity?: true
    costPerUnit?: true
    totalCost?: true
    qtyAfter?: true
  }

  export type MaterialMovementMinAggregateInputType = {
    id?: true
    materialId?: true
    orderId?: true
    userId?: true
    purchaseLogId?: true
    movementType?: true
    quantity?: true
    unit?: true
    costPerUnit?: true
    totalCost?: true
    notes?: true
    qtyAfter?: true
    movementDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialMovementMaxAggregateInputType = {
    id?: true
    materialId?: true
    orderId?: true
    userId?: true
    purchaseLogId?: true
    movementType?: true
    quantity?: true
    unit?: true
    costPerUnit?: true
    totalCost?: true
    notes?: true
    qtyAfter?: true
    movementDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialMovementCountAggregateInputType = {
    id?: true
    materialId?: true
    orderId?: true
    userId?: true
    purchaseLogId?: true
    movementType?: true
    quantity?: true
    unit?: true
    costPerUnit?: true
    totalCost?: true
    notes?: true
    qtyAfter?: true
    movementDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterialMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialMovement to aggregate.
     */
    where?: MaterialMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialMovements to fetch.
     */
    orderBy?: MaterialMovementOrderByWithRelationInput | MaterialMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialMovements
    **/
    _count?: true | MaterialMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMovementMaxAggregateInputType
  }

  export type GetMaterialMovementAggregateType<T extends MaterialMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialMovement[P]>
      : GetScalarType<T[P], AggregateMaterialMovement[P]>
  }




  export type MaterialMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialMovementWhereInput
    orderBy?: MaterialMovementOrderByWithAggregationInput | MaterialMovementOrderByWithAggregationInput[]
    by: MaterialMovementScalarFieldEnum[] | MaterialMovementScalarFieldEnum
    having?: MaterialMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialMovementCountAggregateInputType | true
    _avg?: MaterialMovementAvgAggregateInputType
    _sum?: MaterialMovementSumAggregateInputType
    _min?: MaterialMovementMinAggregateInputType
    _max?: MaterialMovementMaxAggregateInputType
  }

  export type MaterialMovementGroupByOutputType = {
    id: number
    materialId: number
    orderId: number | null
    userId: number
    purchaseLogId: number | null
    movementType: $Enums.MaterialMovementType
    quantity: Decimal
    unit: string
    costPerUnit: Decimal | null
    totalCost: Decimal | null
    notes: string | null
    qtyAfter: Decimal
    movementDate: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MaterialMovementCountAggregateOutputType | null
    _avg: MaterialMovementAvgAggregateOutputType | null
    _sum: MaterialMovementSumAggregateOutputType | null
    _min: MaterialMovementMinAggregateOutputType | null
    _max: MaterialMovementMaxAggregateOutputType | null
  }

  type GetMaterialMovementGroupByPayload<T extends MaterialMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialMovementGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialMovementGroupByOutputType[P]>
        }
      >
    >


  export type MaterialMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    orderId?: boolean
    userId?: boolean
    purchaseLogId?: boolean
    movementType?: boolean
    quantity?: boolean
    unit?: boolean
    costPerUnit?: boolean
    totalCost?: boolean
    notes?: boolean
    qtyAfter?: boolean
    movementDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    order?: boolean | MaterialMovement$orderArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    purchaseLog?: boolean | MaterialMovement$purchaseLogArgs<ExtArgs>
  }, ExtArgs["result"]["materialMovement"]>

  export type MaterialMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    orderId?: boolean
    userId?: boolean
    purchaseLogId?: boolean
    movementType?: boolean
    quantity?: boolean
    unit?: boolean
    costPerUnit?: boolean
    totalCost?: boolean
    notes?: boolean
    qtyAfter?: boolean
    movementDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    order?: boolean | MaterialMovement$orderArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    purchaseLog?: boolean | MaterialMovement$purchaseLogArgs<ExtArgs>
  }, ExtArgs["result"]["materialMovement"]>

  export type MaterialMovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    orderId?: boolean
    userId?: boolean
    purchaseLogId?: boolean
    movementType?: boolean
    quantity?: boolean
    unit?: boolean
    costPerUnit?: boolean
    totalCost?: boolean
    notes?: boolean
    qtyAfter?: boolean
    movementDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    order?: boolean | MaterialMovement$orderArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    purchaseLog?: boolean | MaterialMovement$purchaseLogArgs<ExtArgs>
  }, ExtArgs["result"]["materialMovement"]>

  export type MaterialMovementSelectScalar = {
    id?: boolean
    materialId?: boolean
    orderId?: boolean
    userId?: boolean
    purchaseLogId?: boolean
    movementType?: boolean
    quantity?: boolean
    unit?: boolean
    costPerUnit?: boolean
    totalCost?: boolean
    notes?: boolean
    qtyAfter?: boolean
    movementDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaterialMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "materialId" | "orderId" | "userId" | "purchaseLogId" | "movementType" | "quantity" | "unit" | "costPerUnit" | "totalCost" | "notes" | "qtyAfter" | "movementDate" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["materialMovement"]>
  export type MaterialMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    order?: boolean | MaterialMovement$orderArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    purchaseLog?: boolean | MaterialMovement$purchaseLogArgs<ExtArgs>
  }
  export type MaterialMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    order?: boolean | MaterialMovement$orderArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    purchaseLog?: boolean | MaterialMovement$purchaseLogArgs<ExtArgs>
  }
  export type MaterialMovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    order?: boolean | MaterialMovement$orderArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    purchaseLog?: boolean | MaterialMovement$purchaseLogArgs<ExtArgs>
  }

  export type $MaterialMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialMovement"
    objects: {
      material: Prisma.$MaterialPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      purchaseLog: Prisma.$PurchaseLogPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materialId: number
      orderId: number | null
      userId: number
      purchaseLogId: number | null
      movementType: $Enums.MaterialMovementType
      quantity: Prisma.Decimal
      unit: string
      costPerUnit: Prisma.Decimal | null
      totalCost: Prisma.Decimal | null
      notes: string | null
      qtyAfter: Prisma.Decimal
      movementDate: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["materialMovement"]>
    composites: {}
  }

  type MaterialMovementGetPayload<S extends boolean | null | undefined | MaterialMovementDefaultArgs> = $Result.GetResult<Prisma.$MaterialMovementPayload, S>

  type MaterialMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialMovementCountAggregateInputType | true
    }

  export interface MaterialMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialMovement'], meta: { name: 'MaterialMovement' } }
    /**
     * Find zero or one MaterialMovement that matches the filter.
     * @param {MaterialMovementFindUniqueArgs} args - Arguments to find a MaterialMovement
     * @example
     * // Get one MaterialMovement
     * const materialMovement = await prisma.materialMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialMovementFindUniqueArgs>(args: SelectSubset<T, MaterialMovementFindUniqueArgs<ExtArgs>>): Prisma__MaterialMovementClient<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaterialMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialMovementFindUniqueOrThrowArgs} args - Arguments to find a MaterialMovement
     * @example
     * // Get one MaterialMovement
     * const materialMovement = await prisma.materialMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialMovementClient<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialMovementFindFirstArgs} args - Arguments to find a MaterialMovement
     * @example
     * // Get one MaterialMovement
     * const materialMovement = await prisma.materialMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialMovementFindFirstArgs>(args?: SelectSubset<T, MaterialMovementFindFirstArgs<ExtArgs>>): Prisma__MaterialMovementClient<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialMovementFindFirstOrThrowArgs} args - Arguments to find a MaterialMovement
     * @example
     * // Get one MaterialMovement
     * const materialMovement = await prisma.materialMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialMovementClient<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaterialMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialMovements
     * const materialMovements = await prisma.materialMovement.findMany()
     * 
     * // Get first 10 MaterialMovements
     * const materialMovements = await prisma.materialMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialMovementWithIdOnly = await prisma.materialMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialMovementFindManyArgs>(args?: SelectSubset<T, MaterialMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaterialMovement.
     * @param {MaterialMovementCreateArgs} args - Arguments to create a MaterialMovement.
     * @example
     * // Create one MaterialMovement
     * const MaterialMovement = await prisma.materialMovement.create({
     *   data: {
     *     // ... data to create a MaterialMovement
     *   }
     * })
     * 
     */
    create<T extends MaterialMovementCreateArgs>(args: SelectSubset<T, MaterialMovementCreateArgs<ExtArgs>>): Prisma__MaterialMovementClient<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaterialMovements.
     * @param {MaterialMovementCreateManyArgs} args - Arguments to create many MaterialMovements.
     * @example
     * // Create many MaterialMovements
     * const materialMovement = await prisma.materialMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialMovementCreateManyArgs>(args?: SelectSubset<T, MaterialMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaterialMovements and returns the data saved in the database.
     * @param {MaterialMovementCreateManyAndReturnArgs} args - Arguments to create many MaterialMovements.
     * @example
     * // Create many MaterialMovements
     * const materialMovement = await prisma.materialMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaterialMovements and only return the `id`
     * const materialMovementWithIdOnly = await prisma.materialMovement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaterialMovement.
     * @param {MaterialMovementDeleteArgs} args - Arguments to delete one MaterialMovement.
     * @example
     * // Delete one MaterialMovement
     * const MaterialMovement = await prisma.materialMovement.delete({
     *   where: {
     *     // ... filter to delete one MaterialMovement
     *   }
     * })
     * 
     */
    delete<T extends MaterialMovementDeleteArgs>(args: SelectSubset<T, MaterialMovementDeleteArgs<ExtArgs>>): Prisma__MaterialMovementClient<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaterialMovement.
     * @param {MaterialMovementUpdateArgs} args - Arguments to update one MaterialMovement.
     * @example
     * // Update one MaterialMovement
     * const materialMovement = await prisma.materialMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialMovementUpdateArgs>(args: SelectSubset<T, MaterialMovementUpdateArgs<ExtArgs>>): Prisma__MaterialMovementClient<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaterialMovements.
     * @param {MaterialMovementDeleteManyArgs} args - Arguments to filter MaterialMovements to delete.
     * @example
     * // Delete a few MaterialMovements
     * const { count } = await prisma.materialMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialMovementDeleteManyArgs>(args?: SelectSubset<T, MaterialMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialMovements
     * const materialMovement = await prisma.materialMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialMovementUpdateManyArgs>(args: SelectSubset<T, MaterialMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialMovements and returns the data updated in the database.
     * @param {MaterialMovementUpdateManyAndReturnArgs} args - Arguments to update many MaterialMovements.
     * @example
     * // Update many MaterialMovements
     * const materialMovement = await prisma.materialMovement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaterialMovements and only return the `id`
     * const materialMovementWithIdOnly = await prisma.materialMovement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialMovementUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialMovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaterialMovement.
     * @param {MaterialMovementUpsertArgs} args - Arguments to update or create a MaterialMovement.
     * @example
     * // Update or create a MaterialMovement
     * const materialMovement = await prisma.materialMovement.upsert({
     *   create: {
     *     // ... data to create a MaterialMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialMovement we want to update
     *   }
     * })
     */
    upsert<T extends MaterialMovementUpsertArgs>(args: SelectSubset<T, MaterialMovementUpsertArgs<ExtArgs>>): Prisma__MaterialMovementClient<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaterialMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialMovementCountArgs} args - Arguments to filter MaterialMovements to count.
     * @example
     * // Count the number of MaterialMovements
     * const count = await prisma.materialMovement.count({
     *   where: {
     *     // ... the filter for the MaterialMovements we want to count
     *   }
     * })
    **/
    count<T extends MaterialMovementCountArgs>(
      args?: Subset<T, MaterialMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialMovementAggregateArgs>(args: Subset<T, MaterialMovementAggregateArgs>): Prisma.PrismaPromise<GetMaterialMovementAggregateType<T>>

    /**
     * Group by MaterialMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialMovementGroupByArgs['orderBy'] }
        : { orderBy?: MaterialMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialMovement model
   */
  readonly fields: MaterialMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends MaterialMovement$orderArgs<ExtArgs> = {}>(args?: Subset<T, MaterialMovement$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseLog<T extends MaterialMovement$purchaseLogArgs<ExtArgs> = {}>(args?: Subset<T, MaterialMovement$purchaseLogArgs<ExtArgs>>): Prisma__PurchaseLogClient<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialMovement model
   */
  interface MaterialMovementFieldRefs {
    readonly id: FieldRef<"MaterialMovement", 'Int'>
    readonly materialId: FieldRef<"MaterialMovement", 'Int'>
    readonly orderId: FieldRef<"MaterialMovement", 'Int'>
    readonly userId: FieldRef<"MaterialMovement", 'Int'>
    readonly purchaseLogId: FieldRef<"MaterialMovement", 'Int'>
    readonly movementType: FieldRef<"MaterialMovement", 'MaterialMovementType'>
    readonly quantity: FieldRef<"MaterialMovement", 'Decimal'>
    readonly unit: FieldRef<"MaterialMovement", 'String'>
    readonly costPerUnit: FieldRef<"MaterialMovement", 'Decimal'>
    readonly totalCost: FieldRef<"MaterialMovement", 'Decimal'>
    readonly notes: FieldRef<"MaterialMovement", 'String'>
    readonly qtyAfter: FieldRef<"MaterialMovement", 'Decimal'>
    readonly movementDate: FieldRef<"MaterialMovement", 'DateTime'>
    readonly isActive: FieldRef<"MaterialMovement", 'Boolean'>
    readonly createdAt: FieldRef<"MaterialMovement", 'DateTime'>
    readonly updatedAt: FieldRef<"MaterialMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaterialMovement findUnique
   */
  export type MaterialMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    /**
     * Filter, which MaterialMovement to fetch.
     */
    where: MaterialMovementWhereUniqueInput
  }

  /**
   * MaterialMovement findUniqueOrThrow
   */
  export type MaterialMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    /**
     * Filter, which MaterialMovement to fetch.
     */
    where: MaterialMovementWhereUniqueInput
  }

  /**
   * MaterialMovement findFirst
   */
  export type MaterialMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    /**
     * Filter, which MaterialMovement to fetch.
     */
    where?: MaterialMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialMovements to fetch.
     */
    orderBy?: MaterialMovementOrderByWithRelationInput | MaterialMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialMovements.
     */
    cursor?: MaterialMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialMovements.
     */
    distinct?: MaterialMovementScalarFieldEnum | MaterialMovementScalarFieldEnum[]
  }

  /**
   * MaterialMovement findFirstOrThrow
   */
  export type MaterialMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    /**
     * Filter, which MaterialMovement to fetch.
     */
    where?: MaterialMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialMovements to fetch.
     */
    orderBy?: MaterialMovementOrderByWithRelationInput | MaterialMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialMovements.
     */
    cursor?: MaterialMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialMovements.
     */
    distinct?: MaterialMovementScalarFieldEnum | MaterialMovementScalarFieldEnum[]
  }

  /**
   * MaterialMovement findMany
   */
  export type MaterialMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    /**
     * Filter, which MaterialMovements to fetch.
     */
    where?: MaterialMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialMovements to fetch.
     */
    orderBy?: MaterialMovementOrderByWithRelationInput | MaterialMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialMovements.
     */
    cursor?: MaterialMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialMovements.
     */
    skip?: number
    distinct?: MaterialMovementScalarFieldEnum | MaterialMovementScalarFieldEnum[]
  }

  /**
   * MaterialMovement create
   */
  export type MaterialMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialMovement.
     */
    data: XOR<MaterialMovementCreateInput, MaterialMovementUncheckedCreateInput>
  }

  /**
   * MaterialMovement createMany
   */
  export type MaterialMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialMovements.
     */
    data: MaterialMovementCreateManyInput | MaterialMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialMovement createManyAndReturn
   */
  export type MaterialMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * The data used to create many MaterialMovements.
     */
    data: MaterialMovementCreateManyInput | MaterialMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialMovement update
   */
  export type MaterialMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialMovement.
     */
    data: XOR<MaterialMovementUpdateInput, MaterialMovementUncheckedUpdateInput>
    /**
     * Choose, which MaterialMovement to update.
     */
    where: MaterialMovementWhereUniqueInput
  }

  /**
   * MaterialMovement updateMany
   */
  export type MaterialMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialMovements.
     */
    data: XOR<MaterialMovementUpdateManyMutationInput, MaterialMovementUncheckedUpdateManyInput>
    /**
     * Filter which MaterialMovements to update
     */
    where?: MaterialMovementWhereInput
    /**
     * Limit how many MaterialMovements to update.
     */
    limit?: number
  }

  /**
   * MaterialMovement updateManyAndReturn
   */
  export type MaterialMovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * The data used to update MaterialMovements.
     */
    data: XOR<MaterialMovementUpdateManyMutationInput, MaterialMovementUncheckedUpdateManyInput>
    /**
     * Filter which MaterialMovements to update
     */
    where?: MaterialMovementWhereInput
    /**
     * Limit how many MaterialMovements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialMovement upsert
   */
  export type MaterialMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialMovement to update in case it exists.
     */
    where: MaterialMovementWhereUniqueInput
    /**
     * In case the MaterialMovement found by the `where` argument doesn't exist, create a new MaterialMovement with this data.
     */
    create: XOR<MaterialMovementCreateInput, MaterialMovementUncheckedCreateInput>
    /**
     * In case the MaterialMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialMovementUpdateInput, MaterialMovementUncheckedUpdateInput>
  }

  /**
   * MaterialMovement delete
   */
  export type MaterialMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    /**
     * Filter which MaterialMovement to delete.
     */
    where: MaterialMovementWhereUniqueInput
  }

  /**
   * MaterialMovement deleteMany
   */
  export type MaterialMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialMovements to delete
     */
    where?: MaterialMovementWhereInput
    /**
     * Limit how many MaterialMovements to delete.
     */
    limit?: number
  }

  /**
   * MaterialMovement.order
   */
  export type MaterialMovement$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * MaterialMovement.purchaseLog
   */
  export type MaterialMovement$purchaseLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
    where?: PurchaseLogWhereInput
  }

  /**
   * MaterialMovement without action
   */
  export type MaterialMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
  }


  /**
   * Model ProgressReport
   */

  export type AggregateProgressReport = {
    _count: ProgressReportCountAggregateOutputType | null
    _avg: ProgressReportAvgAggregateOutputType | null
    _sum: ProgressReportSumAggregateOutputType | null
    _min: ProgressReportMinAggregateOutputType | null
    _max: ProgressReportMaxAggregateOutputType | null
  }

  export type ProgressReportAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    orderProductId: number | null
    productId: number | null
    userId: number | null
    percentage: number | null
  }

  export type ProgressReportSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    orderProductId: number | null
    productId: number | null
    userId: number | null
    percentage: number | null
  }

  export type ProgressReportMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    orderProductId: number | null
    productId: number | null
    userId: number | null
    reportText: string | null
    photoPath: string | null
    percentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgressReportMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    orderProductId: number | null
    productId: number | null
    userId: number | null
    reportText: string | null
    photoPath: string | null
    percentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgressReportCountAggregateOutputType = {
    id: number
    orderId: number
    orderProductId: number
    productId: number
    userId: number
    reportText: number
    photoPath: number
    percentage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgressReportAvgAggregateInputType = {
    id?: true
    orderId?: true
    orderProductId?: true
    productId?: true
    userId?: true
    percentage?: true
  }

  export type ProgressReportSumAggregateInputType = {
    id?: true
    orderId?: true
    orderProductId?: true
    productId?: true
    userId?: true
    percentage?: true
  }

  export type ProgressReportMinAggregateInputType = {
    id?: true
    orderId?: true
    orderProductId?: true
    productId?: true
    userId?: true
    reportText?: true
    photoPath?: true
    percentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgressReportMaxAggregateInputType = {
    id?: true
    orderId?: true
    orderProductId?: true
    productId?: true
    userId?: true
    reportText?: true
    photoPath?: true
    percentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgressReportCountAggregateInputType = {
    id?: true
    orderId?: true
    orderProductId?: true
    productId?: true
    userId?: true
    reportText?: true
    photoPath?: true
    percentage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgressReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgressReport to aggregate.
     */
    where?: ProgressReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressReports to fetch.
     */
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgressReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgressReports
    **/
    _count?: true | ProgressReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgressReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgressReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgressReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgressReportMaxAggregateInputType
  }

  export type GetProgressReportAggregateType<T extends ProgressReportAggregateArgs> = {
        [P in keyof T & keyof AggregateProgressReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgressReport[P]>
      : GetScalarType<T[P], AggregateProgressReport[P]>
  }




  export type ProgressReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressReportWhereInput
    orderBy?: ProgressReportOrderByWithAggregationInput | ProgressReportOrderByWithAggregationInput[]
    by: ProgressReportScalarFieldEnum[] | ProgressReportScalarFieldEnum
    having?: ProgressReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgressReportCountAggregateInputType | true
    _avg?: ProgressReportAvgAggregateInputType
    _sum?: ProgressReportSumAggregateInputType
    _min?: ProgressReportMinAggregateInputType
    _max?: ProgressReportMaxAggregateInputType
  }

  export type ProgressReportGroupByOutputType = {
    id: number
    orderId: number | null
    orderProductId: number | null
    productId: number | null
    userId: number
    reportText: string
    photoPath: string | null
    percentage: number
    createdAt: Date
    updatedAt: Date
    _count: ProgressReportCountAggregateOutputType | null
    _avg: ProgressReportAvgAggregateOutputType | null
    _sum: ProgressReportSumAggregateOutputType | null
    _min: ProgressReportMinAggregateOutputType | null
    _max: ProgressReportMaxAggregateOutputType | null
  }

  type GetProgressReportGroupByPayload<T extends ProgressReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgressReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgressReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgressReportGroupByOutputType[P]>
            : GetScalarType<T[P], ProgressReportGroupByOutputType[P]>
        }
      >
    >


  export type ProgressReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    orderProductId?: boolean
    productId?: boolean
    userId?: boolean
    reportText?: boolean
    photoPath?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | ProgressReport$orderArgs<ExtArgs>
    orderProduct?: boolean | ProgressReport$orderProductArgs<ExtArgs>
    product?: boolean | ProgressReport$productArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    productReports?: boolean | ProgressReport$productReportsArgs<ExtArgs>
    _count?: boolean | ProgressReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressReport"]>

  export type ProgressReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    orderProductId?: boolean
    productId?: boolean
    userId?: boolean
    reportText?: boolean
    photoPath?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | ProgressReport$orderArgs<ExtArgs>
    orderProduct?: boolean | ProgressReport$orderProductArgs<ExtArgs>
    product?: boolean | ProgressReport$productArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressReport"]>

  export type ProgressReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    orderProductId?: boolean
    productId?: boolean
    userId?: boolean
    reportText?: boolean
    photoPath?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | ProgressReport$orderArgs<ExtArgs>
    orderProduct?: boolean | ProgressReport$orderProductArgs<ExtArgs>
    product?: boolean | ProgressReport$productArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressReport"]>

  export type ProgressReportSelectScalar = {
    id?: boolean
    orderId?: boolean
    orderProductId?: boolean
    productId?: boolean
    userId?: boolean
    reportText?: boolean
    photoPath?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgressReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "orderProductId" | "productId" | "userId" | "reportText" | "photoPath" | "percentage" | "createdAt" | "updatedAt", ExtArgs["result"]["progressReport"]>
  export type ProgressReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ProgressReport$orderArgs<ExtArgs>
    orderProduct?: boolean | ProgressReport$orderProductArgs<ExtArgs>
    product?: boolean | ProgressReport$productArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    productReports?: boolean | ProgressReport$productReportsArgs<ExtArgs>
    _count?: boolean | ProgressReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgressReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ProgressReport$orderArgs<ExtArgs>
    orderProduct?: boolean | ProgressReport$orderProductArgs<ExtArgs>
    product?: boolean | ProgressReport$productArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProgressReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ProgressReport$orderArgs<ExtArgs>
    orderProduct?: boolean | ProgressReport$orderProductArgs<ExtArgs>
    product?: boolean | ProgressReport$productArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProgressReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgressReport"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs> | null
      orderProduct: Prisma.$OrderProductPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      productReports: Prisma.$ProductProgressReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number | null
      orderProductId: number | null
      productId: number | null
      userId: number
      reportText: string
      photoPath: string | null
      percentage: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["progressReport"]>
    composites: {}
  }

  type ProgressReportGetPayload<S extends boolean | null | undefined | ProgressReportDefaultArgs> = $Result.GetResult<Prisma.$ProgressReportPayload, S>

  type ProgressReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgressReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgressReportCountAggregateInputType | true
    }

  export interface ProgressReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgressReport'], meta: { name: 'ProgressReport' } }
    /**
     * Find zero or one ProgressReport that matches the filter.
     * @param {ProgressReportFindUniqueArgs} args - Arguments to find a ProgressReport
     * @example
     * // Get one ProgressReport
     * const progressReport = await prisma.progressReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgressReportFindUniqueArgs>(args: SelectSubset<T, ProgressReportFindUniqueArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgressReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgressReportFindUniqueOrThrowArgs} args - Arguments to find a ProgressReport
     * @example
     * // Get one ProgressReport
     * const progressReport = await prisma.progressReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgressReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgressReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgressReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportFindFirstArgs} args - Arguments to find a ProgressReport
     * @example
     * // Get one ProgressReport
     * const progressReport = await prisma.progressReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgressReportFindFirstArgs>(args?: SelectSubset<T, ProgressReportFindFirstArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgressReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportFindFirstOrThrowArgs} args - Arguments to find a ProgressReport
     * @example
     * // Get one ProgressReport
     * const progressReport = await prisma.progressReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgressReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgressReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgressReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgressReports
     * const progressReports = await prisma.progressReport.findMany()
     * 
     * // Get first 10 ProgressReports
     * const progressReports = await prisma.progressReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const progressReportWithIdOnly = await prisma.progressReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgressReportFindManyArgs>(args?: SelectSubset<T, ProgressReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgressReport.
     * @param {ProgressReportCreateArgs} args - Arguments to create a ProgressReport.
     * @example
     * // Create one ProgressReport
     * const ProgressReport = await prisma.progressReport.create({
     *   data: {
     *     // ... data to create a ProgressReport
     *   }
     * })
     * 
     */
    create<T extends ProgressReportCreateArgs>(args: SelectSubset<T, ProgressReportCreateArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgressReports.
     * @param {ProgressReportCreateManyArgs} args - Arguments to create many ProgressReports.
     * @example
     * // Create many ProgressReports
     * const progressReport = await prisma.progressReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgressReportCreateManyArgs>(args?: SelectSubset<T, ProgressReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgressReports and returns the data saved in the database.
     * @param {ProgressReportCreateManyAndReturnArgs} args - Arguments to create many ProgressReports.
     * @example
     * // Create many ProgressReports
     * const progressReport = await prisma.progressReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgressReports and only return the `id`
     * const progressReportWithIdOnly = await prisma.progressReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgressReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgressReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProgressReport.
     * @param {ProgressReportDeleteArgs} args - Arguments to delete one ProgressReport.
     * @example
     * // Delete one ProgressReport
     * const ProgressReport = await prisma.progressReport.delete({
     *   where: {
     *     // ... filter to delete one ProgressReport
     *   }
     * })
     * 
     */
    delete<T extends ProgressReportDeleteArgs>(args: SelectSubset<T, ProgressReportDeleteArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgressReport.
     * @param {ProgressReportUpdateArgs} args - Arguments to update one ProgressReport.
     * @example
     * // Update one ProgressReport
     * const progressReport = await prisma.progressReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgressReportUpdateArgs>(args: SelectSubset<T, ProgressReportUpdateArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgressReports.
     * @param {ProgressReportDeleteManyArgs} args - Arguments to filter ProgressReports to delete.
     * @example
     * // Delete a few ProgressReports
     * const { count } = await prisma.progressReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgressReportDeleteManyArgs>(args?: SelectSubset<T, ProgressReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgressReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgressReports
     * const progressReport = await prisma.progressReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgressReportUpdateManyArgs>(args: SelectSubset<T, ProgressReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgressReports and returns the data updated in the database.
     * @param {ProgressReportUpdateManyAndReturnArgs} args - Arguments to update many ProgressReports.
     * @example
     * // Update many ProgressReports
     * const progressReport = await prisma.progressReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProgressReports and only return the `id`
     * const progressReportWithIdOnly = await prisma.progressReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgressReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgressReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProgressReport.
     * @param {ProgressReportUpsertArgs} args - Arguments to update or create a ProgressReport.
     * @example
     * // Update or create a ProgressReport
     * const progressReport = await prisma.progressReport.upsert({
     *   create: {
     *     // ... data to create a ProgressReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgressReport we want to update
     *   }
     * })
     */
    upsert<T extends ProgressReportUpsertArgs>(args: SelectSubset<T, ProgressReportUpsertArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgressReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportCountArgs} args - Arguments to filter ProgressReports to count.
     * @example
     * // Count the number of ProgressReports
     * const count = await prisma.progressReport.count({
     *   where: {
     *     // ... the filter for the ProgressReports we want to count
     *   }
     * })
    **/
    count<T extends ProgressReportCountArgs>(
      args?: Subset<T, ProgressReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgressReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgressReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgressReportAggregateArgs>(args: Subset<T, ProgressReportAggregateArgs>): Prisma.PrismaPromise<GetProgressReportAggregateType<T>>

    /**
     * Group by ProgressReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgressReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgressReportGroupByArgs['orderBy'] }
        : { orderBy?: ProgressReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgressReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgressReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgressReport model
   */
  readonly fields: ProgressReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgressReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgressReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends ProgressReport$orderArgs<ExtArgs> = {}>(args?: Subset<T, ProgressReport$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orderProduct<T extends ProgressReport$orderProductArgs<ExtArgs> = {}>(args?: Subset<T, ProgressReport$orderProductArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends ProgressReport$productArgs<ExtArgs> = {}>(args?: Subset<T, ProgressReport$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productReports<T extends ProgressReport$productReportsArgs<ExtArgs> = {}>(args?: Subset<T, ProgressReport$productReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgressReport model
   */
  interface ProgressReportFieldRefs {
    readonly id: FieldRef<"ProgressReport", 'Int'>
    readonly orderId: FieldRef<"ProgressReport", 'Int'>
    readonly orderProductId: FieldRef<"ProgressReport", 'Int'>
    readonly productId: FieldRef<"ProgressReport", 'Int'>
    readonly userId: FieldRef<"ProgressReport", 'Int'>
    readonly reportText: FieldRef<"ProgressReport", 'String'>
    readonly photoPath: FieldRef<"ProgressReport", 'String'>
    readonly percentage: FieldRef<"ProgressReport", 'Int'>
    readonly createdAt: FieldRef<"ProgressReport", 'DateTime'>
    readonly updatedAt: FieldRef<"ProgressReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgressReport findUnique
   */
  export type ProgressReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProgressReport to fetch.
     */
    where: ProgressReportWhereUniqueInput
  }

  /**
   * ProgressReport findUniqueOrThrow
   */
  export type ProgressReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProgressReport to fetch.
     */
    where: ProgressReportWhereUniqueInput
  }

  /**
   * ProgressReport findFirst
   */
  export type ProgressReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProgressReport to fetch.
     */
    where?: ProgressReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressReports to fetch.
     */
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgressReports.
     */
    cursor?: ProgressReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgressReports.
     */
    distinct?: ProgressReportScalarFieldEnum | ProgressReportScalarFieldEnum[]
  }

  /**
   * ProgressReport findFirstOrThrow
   */
  export type ProgressReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProgressReport to fetch.
     */
    where?: ProgressReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressReports to fetch.
     */
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgressReports.
     */
    cursor?: ProgressReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgressReports.
     */
    distinct?: ProgressReportScalarFieldEnum | ProgressReportScalarFieldEnum[]
  }

  /**
   * ProgressReport findMany
   */
  export type ProgressReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProgressReports to fetch.
     */
    where?: ProgressReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressReports to fetch.
     */
    orderBy?: ProgressReportOrderByWithRelationInput | ProgressReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgressReports.
     */
    cursor?: ProgressReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressReports.
     */
    skip?: number
    distinct?: ProgressReportScalarFieldEnum | ProgressReportScalarFieldEnum[]
  }

  /**
   * ProgressReport create
   */
  export type ProgressReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgressReport.
     */
    data: XOR<ProgressReportCreateInput, ProgressReportUncheckedCreateInput>
  }

  /**
   * ProgressReport createMany
   */
  export type ProgressReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgressReports.
     */
    data: ProgressReportCreateManyInput | ProgressReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgressReport createManyAndReturn
   */
  export type ProgressReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * The data used to create many ProgressReports.
     */
    data: ProgressReportCreateManyInput | ProgressReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgressReport update
   */
  export type ProgressReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgressReport.
     */
    data: XOR<ProgressReportUpdateInput, ProgressReportUncheckedUpdateInput>
    /**
     * Choose, which ProgressReport to update.
     */
    where: ProgressReportWhereUniqueInput
  }

  /**
   * ProgressReport updateMany
   */
  export type ProgressReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgressReports.
     */
    data: XOR<ProgressReportUpdateManyMutationInput, ProgressReportUncheckedUpdateManyInput>
    /**
     * Filter which ProgressReports to update
     */
    where?: ProgressReportWhereInput
    /**
     * Limit how many ProgressReports to update.
     */
    limit?: number
  }

  /**
   * ProgressReport updateManyAndReturn
   */
  export type ProgressReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * The data used to update ProgressReports.
     */
    data: XOR<ProgressReportUpdateManyMutationInput, ProgressReportUncheckedUpdateManyInput>
    /**
     * Filter which ProgressReports to update
     */
    where?: ProgressReportWhereInput
    /**
     * Limit how many ProgressReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgressReport upsert
   */
  export type ProgressReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgressReport to update in case it exists.
     */
    where: ProgressReportWhereUniqueInput
    /**
     * In case the ProgressReport found by the `where` argument doesn't exist, create a new ProgressReport with this data.
     */
    create: XOR<ProgressReportCreateInput, ProgressReportUncheckedCreateInput>
    /**
     * In case the ProgressReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgressReportUpdateInput, ProgressReportUncheckedUpdateInput>
  }

  /**
   * ProgressReport delete
   */
  export type ProgressReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
    /**
     * Filter which ProgressReport to delete.
     */
    where: ProgressReportWhereUniqueInput
  }

  /**
   * ProgressReport deleteMany
   */
  export type ProgressReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgressReports to delete
     */
    where?: ProgressReportWhereInput
    /**
     * Limit how many ProgressReports to delete.
     */
    limit?: number
  }

  /**
   * ProgressReport.order
   */
  export type ProgressReport$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * ProgressReport.orderProduct
   */
  export type ProgressReport$orderProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    where?: OrderProductWhereInput
  }

  /**
   * ProgressReport.product
   */
  export type ProgressReport$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * ProgressReport.productReports
   */
  export type ProgressReport$productReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
    where?: ProductProgressReportWhereInput
    orderBy?: ProductProgressReportOrderByWithRelationInput | ProductProgressReportOrderByWithRelationInput[]
    cursor?: ProductProgressReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductProgressReportScalarFieldEnum | ProductProgressReportScalarFieldEnum[]
  }

  /**
   * ProgressReport without action
   */
  export type ProgressReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressReport
     */
    select?: ProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressReport
     */
    omit?: ProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressReportInclude<ExtArgs> | null
  }


  /**
   * Model ProductProgressReport
   */

  export type AggregateProductProgressReport = {
    _count: ProductProgressReportCountAggregateOutputType | null
    _avg: ProductProgressReportAvgAggregateOutputType | null
    _sum: ProductProgressReportSumAggregateOutputType | null
    _min: ProductProgressReportMinAggregateOutputType | null
    _max: ProductProgressReportMaxAggregateOutputType | null
  }

  export type ProductProgressReportAvgAggregateOutputType = {
    id: number | null
    progressReportId: number | null
    productId: number | null
    orderProductId: number | null
    itemsCompleted: number | null
    itemsTarget: number | null
  }

  export type ProductProgressReportSumAggregateOutputType = {
    id: number | null
    progressReportId: number | null
    productId: number | null
    orderProductId: number | null
    itemsCompleted: number | null
    itemsTarget: number | null
  }

  export type ProductProgressReportMinAggregateOutputType = {
    id: number | null
    progressReportId: number | null
    productId: number | null
    orderProductId: number | null
    itemsCompleted: number | null
    itemsTarget: number | null
    status: string | null
    notes: string | null
    completionDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductProgressReportMaxAggregateOutputType = {
    id: number | null
    progressReportId: number | null
    productId: number | null
    orderProductId: number | null
    itemsCompleted: number | null
    itemsTarget: number | null
    status: string | null
    notes: string | null
    completionDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductProgressReportCountAggregateOutputType = {
    id: number
    progressReportId: number
    productId: number
    orderProductId: number
    itemsCompleted: number
    itemsTarget: number
    status: number
    notes: number
    completionDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductProgressReportAvgAggregateInputType = {
    id?: true
    progressReportId?: true
    productId?: true
    orderProductId?: true
    itemsCompleted?: true
    itemsTarget?: true
  }

  export type ProductProgressReportSumAggregateInputType = {
    id?: true
    progressReportId?: true
    productId?: true
    orderProductId?: true
    itemsCompleted?: true
    itemsTarget?: true
  }

  export type ProductProgressReportMinAggregateInputType = {
    id?: true
    progressReportId?: true
    productId?: true
    orderProductId?: true
    itemsCompleted?: true
    itemsTarget?: true
    status?: true
    notes?: true
    completionDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductProgressReportMaxAggregateInputType = {
    id?: true
    progressReportId?: true
    productId?: true
    orderProductId?: true
    itemsCompleted?: true
    itemsTarget?: true
    status?: true
    notes?: true
    completionDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductProgressReportCountAggregateInputType = {
    id?: true
    progressReportId?: true
    productId?: true
    orderProductId?: true
    itemsCompleted?: true
    itemsTarget?: true
    status?: true
    notes?: true
    completionDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductProgressReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductProgressReport to aggregate.
     */
    where?: ProductProgressReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductProgressReports to fetch.
     */
    orderBy?: ProductProgressReportOrderByWithRelationInput | ProductProgressReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductProgressReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductProgressReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductProgressReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductProgressReports
    **/
    _count?: true | ProductProgressReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductProgressReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductProgressReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductProgressReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductProgressReportMaxAggregateInputType
  }

  export type GetProductProgressReportAggregateType<T extends ProductProgressReportAggregateArgs> = {
        [P in keyof T & keyof AggregateProductProgressReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductProgressReport[P]>
      : GetScalarType<T[P], AggregateProductProgressReport[P]>
  }




  export type ProductProgressReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductProgressReportWhereInput
    orderBy?: ProductProgressReportOrderByWithAggregationInput | ProductProgressReportOrderByWithAggregationInput[]
    by: ProductProgressReportScalarFieldEnum[] | ProductProgressReportScalarFieldEnum
    having?: ProductProgressReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductProgressReportCountAggregateInputType | true
    _avg?: ProductProgressReportAvgAggregateInputType
    _sum?: ProductProgressReportSumAggregateInputType
    _min?: ProductProgressReportMinAggregateInputType
    _max?: ProductProgressReportMaxAggregateInputType
  }

  export type ProductProgressReportGroupByOutputType = {
    id: number
    progressReportId: number
    productId: number
    orderProductId: number | null
    itemsCompleted: number
    itemsTarget: number
    status: string
    notes: string | null
    completionDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProductProgressReportCountAggregateOutputType | null
    _avg: ProductProgressReportAvgAggregateOutputType | null
    _sum: ProductProgressReportSumAggregateOutputType | null
    _min: ProductProgressReportMinAggregateOutputType | null
    _max: ProductProgressReportMaxAggregateOutputType | null
  }

  type GetProductProgressReportGroupByPayload<T extends ProductProgressReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductProgressReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductProgressReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductProgressReportGroupByOutputType[P]>
            : GetScalarType<T[P], ProductProgressReportGroupByOutputType[P]>
        }
      >
    >


  export type ProductProgressReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progressReportId?: boolean
    productId?: boolean
    orderProductId?: boolean
    itemsCompleted?: boolean
    itemsTarget?: boolean
    status?: boolean
    notes?: boolean
    completionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    progressReport?: boolean | ProgressReportDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderProduct?: boolean | ProductProgressReport$orderProductArgs<ExtArgs>
    photos?: boolean | ProductProgressReport$photosArgs<ExtArgs>
    _count?: boolean | ProductProgressReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productProgressReport"]>

  export type ProductProgressReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progressReportId?: boolean
    productId?: boolean
    orderProductId?: boolean
    itemsCompleted?: boolean
    itemsTarget?: boolean
    status?: boolean
    notes?: boolean
    completionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    progressReport?: boolean | ProgressReportDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderProduct?: boolean | ProductProgressReport$orderProductArgs<ExtArgs>
  }, ExtArgs["result"]["productProgressReport"]>

  export type ProductProgressReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progressReportId?: boolean
    productId?: boolean
    orderProductId?: boolean
    itemsCompleted?: boolean
    itemsTarget?: boolean
    status?: boolean
    notes?: boolean
    completionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    progressReport?: boolean | ProgressReportDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderProduct?: boolean | ProductProgressReport$orderProductArgs<ExtArgs>
  }, ExtArgs["result"]["productProgressReport"]>

  export type ProductProgressReportSelectScalar = {
    id?: boolean
    progressReportId?: boolean
    productId?: boolean
    orderProductId?: boolean
    itemsCompleted?: boolean
    itemsTarget?: boolean
    status?: boolean
    notes?: boolean
    completionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductProgressReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "progressReportId" | "productId" | "orderProductId" | "itemsCompleted" | "itemsTarget" | "status" | "notes" | "completionDate" | "createdAt" | "updatedAt", ExtArgs["result"]["productProgressReport"]>
  export type ProductProgressReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progressReport?: boolean | ProgressReportDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderProduct?: boolean | ProductProgressReport$orderProductArgs<ExtArgs>
    photos?: boolean | ProductProgressReport$photosArgs<ExtArgs>
    _count?: boolean | ProductProgressReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductProgressReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progressReport?: boolean | ProgressReportDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderProduct?: boolean | ProductProgressReport$orderProductArgs<ExtArgs>
  }
  export type ProductProgressReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progressReport?: boolean | ProgressReportDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    orderProduct?: boolean | ProductProgressReport$orderProductArgs<ExtArgs>
  }

  export type $ProductProgressReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductProgressReport"
    objects: {
      progressReport: Prisma.$ProgressReportPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      orderProduct: Prisma.$OrderProductPayload<ExtArgs> | null
      photos: Prisma.$ProductProgressPhotoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      progressReportId: number
      productId: number
      orderProductId: number | null
      itemsCompleted: number
      itemsTarget: number
      status: string
      notes: string | null
      completionDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productProgressReport"]>
    composites: {}
  }

  type ProductProgressReportGetPayload<S extends boolean | null | undefined | ProductProgressReportDefaultArgs> = $Result.GetResult<Prisma.$ProductProgressReportPayload, S>

  type ProductProgressReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductProgressReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductProgressReportCountAggregateInputType | true
    }

  export interface ProductProgressReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductProgressReport'], meta: { name: 'ProductProgressReport' } }
    /**
     * Find zero or one ProductProgressReport that matches the filter.
     * @param {ProductProgressReportFindUniqueArgs} args - Arguments to find a ProductProgressReport
     * @example
     * // Get one ProductProgressReport
     * const productProgressReport = await prisma.productProgressReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductProgressReportFindUniqueArgs>(args: SelectSubset<T, ProductProgressReportFindUniqueArgs<ExtArgs>>): Prisma__ProductProgressReportClient<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductProgressReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductProgressReportFindUniqueOrThrowArgs} args - Arguments to find a ProductProgressReport
     * @example
     * // Get one ProductProgressReport
     * const productProgressReport = await prisma.productProgressReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductProgressReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductProgressReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductProgressReportClient<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductProgressReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressReportFindFirstArgs} args - Arguments to find a ProductProgressReport
     * @example
     * // Get one ProductProgressReport
     * const productProgressReport = await prisma.productProgressReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductProgressReportFindFirstArgs>(args?: SelectSubset<T, ProductProgressReportFindFirstArgs<ExtArgs>>): Prisma__ProductProgressReportClient<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductProgressReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressReportFindFirstOrThrowArgs} args - Arguments to find a ProductProgressReport
     * @example
     * // Get one ProductProgressReport
     * const productProgressReport = await prisma.productProgressReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductProgressReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductProgressReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductProgressReportClient<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductProgressReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductProgressReports
     * const productProgressReports = await prisma.productProgressReport.findMany()
     * 
     * // Get first 10 ProductProgressReports
     * const productProgressReports = await prisma.productProgressReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productProgressReportWithIdOnly = await prisma.productProgressReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductProgressReportFindManyArgs>(args?: SelectSubset<T, ProductProgressReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductProgressReport.
     * @param {ProductProgressReportCreateArgs} args - Arguments to create a ProductProgressReport.
     * @example
     * // Create one ProductProgressReport
     * const ProductProgressReport = await prisma.productProgressReport.create({
     *   data: {
     *     // ... data to create a ProductProgressReport
     *   }
     * })
     * 
     */
    create<T extends ProductProgressReportCreateArgs>(args: SelectSubset<T, ProductProgressReportCreateArgs<ExtArgs>>): Prisma__ProductProgressReportClient<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductProgressReports.
     * @param {ProductProgressReportCreateManyArgs} args - Arguments to create many ProductProgressReports.
     * @example
     * // Create many ProductProgressReports
     * const productProgressReport = await prisma.productProgressReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductProgressReportCreateManyArgs>(args?: SelectSubset<T, ProductProgressReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductProgressReports and returns the data saved in the database.
     * @param {ProductProgressReportCreateManyAndReturnArgs} args - Arguments to create many ProductProgressReports.
     * @example
     * // Create many ProductProgressReports
     * const productProgressReport = await prisma.productProgressReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductProgressReports and only return the `id`
     * const productProgressReportWithIdOnly = await prisma.productProgressReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductProgressReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductProgressReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductProgressReport.
     * @param {ProductProgressReportDeleteArgs} args - Arguments to delete one ProductProgressReport.
     * @example
     * // Delete one ProductProgressReport
     * const ProductProgressReport = await prisma.productProgressReport.delete({
     *   where: {
     *     // ... filter to delete one ProductProgressReport
     *   }
     * })
     * 
     */
    delete<T extends ProductProgressReportDeleteArgs>(args: SelectSubset<T, ProductProgressReportDeleteArgs<ExtArgs>>): Prisma__ProductProgressReportClient<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductProgressReport.
     * @param {ProductProgressReportUpdateArgs} args - Arguments to update one ProductProgressReport.
     * @example
     * // Update one ProductProgressReport
     * const productProgressReport = await prisma.productProgressReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductProgressReportUpdateArgs>(args: SelectSubset<T, ProductProgressReportUpdateArgs<ExtArgs>>): Prisma__ProductProgressReportClient<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductProgressReports.
     * @param {ProductProgressReportDeleteManyArgs} args - Arguments to filter ProductProgressReports to delete.
     * @example
     * // Delete a few ProductProgressReports
     * const { count } = await prisma.productProgressReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductProgressReportDeleteManyArgs>(args?: SelectSubset<T, ProductProgressReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductProgressReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductProgressReports
     * const productProgressReport = await prisma.productProgressReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductProgressReportUpdateManyArgs>(args: SelectSubset<T, ProductProgressReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductProgressReports and returns the data updated in the database.
     * @param {ProductProgressReportUpdateManyAndReturnArgs} args - Arguments to update many ProductProgressReports.
     * @example
     * // Update many ProductProgressReports
     * const productProgressReport = await prisma.productProgressReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductProgressReports and only return the `id`
     * const productProgressReportWithIdOnly = await prisma.productProgressReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductProgressReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductProgressReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductProgressReport.
     * @param {ProductProgressReportUpsertArgs} args - Arguments to update or create a ProductProgressReport.
     * @example
     * // Update or create a ProductProgressReport
     * const productProgressReport = await prisma.productProgressReport.upsert({
     *   create: {
     *     // ... data to create a ProductProgressReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductProgressReport we want to update
     *   }
     * })
     */
    upsert<T extends ProductProgressReportUpsertArgs>(args: SelectSubset<T, ProductProgressReportUpsertArgs<ExtArgs>>): Prisma__ProductProgressReportClient<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductProgressReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressReportCountArgs} args - Arguments to filter ProductProgressReports to count.
     * @example
     * // Count the number of ProductProgressReports
     * const count = await prisma.productProgressReport.count({
     *   where: {
     *     // ... the filter for the ProductProgressReports we want to count
     *   }
     * })
    **/
    count<T extends ProductProgressReportCountArgs>(
      args?: Subset<T, ProductProgressReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductProgressReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductProgressReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductProgressReportAggregateArgs>(args: Subset<T, ProductProgressReportAggregateArgs>): Prisma.PrismaPromise<GetProductProgressReportAggregateType<T>>

    /**
     * Group by ProductProgressReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductProgressReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductProgressReportGroupByArgs['orderBy'] }
        : { orderBy?: ProductProgressReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductProgressReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductProgressReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductProgressReport model
   */
  readonly fields: ProductProgressReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductProgressReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductProgressReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    progressReport<T extends ProgressReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgressReportDefaultArgs<ExtArgs>>): Prisma__ProgressReportClient<$Result.GetResult<Prisma.$ProgressReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderProduct<T extends ProductProgressReport$orderProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductProgressReport$orderProductArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    photos<T extends ProductProgressReport$photosArgs<ExtArgs> = {}>(args?: Subset<T, ProductProgressReport$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductProgressPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductProgressReport model
   */
  interface ProductProgressReportFieldRefs {
    readonly id: FieldRef<"ProductProgressReport", 'Int'>
    readonly progressReportId: FieldRef<"ProductProgressReport", 'Int'>
    readonly productId: FieldRef<"ProductProgressReport", 'Int'>
    readonly orderProductId: FieldRef<"ProductProgressReport", 'Int'>
    readonly itemsCompleted: FieldRef<"ProductProgressReport", 'Int'>
    readonly itemsTarget: FieldRef<"ProductProgressReport", 'Int'>
    readonly status: FieldRef<"ProductProgressReport", 'String'>
    readonly notes: FieldRef<"ProductProgressReport", 'String'>
    readonly completionDate: FieldRef<"ProductProgressReport", 'DateTime'>
    readonly createdAt: FieldRef<"ProductProgressReport", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductProgressReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductProgressReport findUnique
   */
  export type ProductProgressReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductProgressReport to fetch.
     */
    where: ProductProgressReportWhereUniqueInput
  }

  /**
   * ProductProgressReport findUniqueOrThrow
   */
  export type ProductProgressReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductProgressReport to fetch.
     */
    where: ProductProgressReportWhereUniqueInput
  }

  /**
   * ProductProgressReport findFirst
   */
  export type ProductProgressReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductProgressReport to fetch.
     */
    where?: ProductProgressReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductProgressReports to fetch.
     */
    orderBy?: ProductProgressReportOrderByWithRelationInput | ProductProgressReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductProgressReports.
     */
    cursor?: ProductProgressReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductProgressReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductProgressReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductProgressReports.
     */
    distinct?: ProductProgressReportScalarFieldEnum | ProductProgressReportScalarFieldEnum[]
  }

  /**
   * ProductProgressReport findFirstOrThrow
   */
  export type ProductProgressReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductProgressReport to fetch.
     */
    where?: ProductProgressReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductProgressReports to fetch.
     */
    orderBy?: ProductProgressReportOrderByWithRelationInput | ProductProgressReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductProgressReports.
     */
    cursor?: ProductProgressReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductProgressReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductProgressReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductProgressReports.
     */
    distinct?: ProductProgressReportScalarFieldEnum | ProductProgressReportScalarFieldEnum[]
  }

  /**
   * ProductProgressReport findMany
   */
  export type ProductProgressReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductProgressReports to fetch.
     */
    where?: ProductProgressReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductProgressReports to fetch.
     */
    orderBy?: ProductProgressReportOrderByWithRelationInput | ProductProgressReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductProgressReports.
     */
    cursor?: ProductProgressReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductProgressReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductProgressReports.
     */
    skip?: number
    distinct?: ProductProgressReportScalarFieldEnum | ProductProgressReportScalarFieldEnum[]
  }

  /**
   * ProductProgressReport create
   */
  export type ProductProgressReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductProgressReport.
     */
    data: XOR<ProductProgressReportCreateInput, ProductProgressReportUncheckedCreateInput>
  }

  /**
   * ProductProgressReport createMany
   */
  export type ProductProgressReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductProgressReports.
     */
    data: ProductProgressReportCreateManyInput | ProductProgressReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductProgressReport createManyAndReturn
   */
  export type ProductProgressReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * The data used to create many ProductProgressReports.
     */
    data: ProductProgressReportCreateManyInput | ProductProgressReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductProgressReport update
   */
  export type ProductProgressReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductProgressReport.
     */
    data: XOR<ProductProgressReportUpdateInput, ProductProgressReportUncheckedUpdateInput>
    /**
     * Choose, which ProductProgressReport to update.
     */
    where: ProductProgressReportWhereUniqueInput
  }

  /**
   * ProductProgressReport updateMany
   */
  export type ProductProgressReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductProgressReports.
     */
    data: XOR<ProductProgressReportUpdateManyMutationInput, ProductProgressReportUncheckedUpdateManyInput>
    /**
     * Filter which ProductProgressReports to update
     */
    where?: ProductProgressReportWhereInput
    /**
     * Limit how many ProductProgressReports to update.
     */
    limit?: number
  }

  /**
   * ProductProgressReport updateManyAndReturn
   */
  export type ProductProgressReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * The data used to update ProductProgressReports.
     */
    data: XOR<ProductProgressReportUpdateManyMutationInput, ProductProgressReportUncheckedUpdateManyInput>
    /**
     * Filter which ProductProgressReports to update
     */
    where?: ProductProgressReportWhereInput
    /**
     * Limit how many ProductProgressReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductProgressReport upsert
   */
  export type ProductProgressReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductProgressReport to update in case it exists.
     */
    where: ProductProgressReportWhereUniqueInput
    /**
     * In case the ProductProgressReport found by the `where` argument doesn't exist, create a new ProductProgressReport with this data.
     */
    create: XOR<ProductProgressReportCreateInput, ProductProgressReportUncheckedCreateInput>
    /**
     * In case the ProductProgressReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductProgressReportUpdateInput, ProductProgressReportUncheckedUpdateInput>
  }

  /**
   * ProductProgressReport delete
   */
  export type ProductProgressReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
    /**
     * Filter which ProductProgressReport to delete.
     */
    where: ProductProgressReportWhereUniqueInput
  }

  /**
   * ProductProgressReport deleteMany
   */
  export type ProductProgressReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductProgressReports to delete
     */
    where?: ProductProgressReportWhereInput
    /**
     * Limit how many ProductProgressReports to delete.
     */
    limit?: number
  }

  /**
   * ProductProgressReport.orderProduct
   */
  export type ProductProgressReport$orderProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    where?: OrderProductWhereInput
  }

  /**
   * ProductProgressReport.photos
   */
  export type ProductProgressReport$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoInclude<ExtArgs> | null
    where?: ProductProgressPhotoWhereInput
    orderBy?: ProductProgressPhotoOrderByWithRelationInput | ProductProgressPhotoOrderByWithRelationInput[]
    cursor?: ProductProgressPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductProgressPhotoScalarFieldEnum | ProductProgressPhotoScalarFieldEnum[]
  }

  /**
   * ProductProgressReport without action
   */
  export type ProductProgressReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressReport
     */
    select?: ProductProgressReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressReport
     */
    omit?: ProductProgressReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressReportInclude<ExtArgs> | null
  }


  /**
   * Model ProductProgressPhoto
   */

  export type AggregateProductProgressPhoto = {
    _count: ProductProgressPhotoCountAggregateOutputType | null
    _avg: ProductProgressPhotoAvgAggregateOutputType | null
    _sum: ProductProgressPhotoSumAggregateOutputType | null
    _min: ProductProgressPhotoMinAggregateOutputType | null
    _max: ProductProgressPhotoMaxAggregateOutputType | null
  }

  export type ProductProgressPhotoAvgAggregateOutputType = {
    id: number | null
    productProgressReportId: number | null
    fileSize: number | null
  }

  export type ProductProgressPhotoSumAggregateOutputType = {
    id: number | null
    productProgressReportId: number | null
    fileSize: number | null
  }

  export type ProductProgressPhotoMinAggregateOutputType = {
    id: number | null
    productProgressReportId: number | null
    photoPath: string | null
    thumbnailPath: string | null
    description: string | null
    uploadDate: Date | null
    fileSize: number | null
    mimeType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductProgressPhotoMaxAggregateOutputType = {
    id: number | null
    productProgressReportId: number | null
    photoPath: string | null
    thumbnailPath: string | null
    description: string | null
    uploadDate: Date | null
    fileSize: number | null
    mimeType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductProgressPhotoCountAggregateOutputType = {
    id: number
    productProgressReportId: number
    photoPath: number
    thumbnailPath: number
    description: number
    uploadDate: number
    fileSize: number
    mimeType: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductProgressPhotoAvgAggregateInputType = {
    id?: true
    productProgressReportId?: true
    fileSize?: true
  }

  export type ProductProgressPhotoSumAggregateInputType = {
    id?: true
    productProgressReportId?: true
    fileSize?: true
  }

  export type ProductProgressPhotoMinAggregateInputType = {
    id?: true
    productProgressReportId?: true
    photoPath?: true
    thumbnailPath?: true
    description?: true
    uploadDate?: true
    fileSize?: true
    mimeType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductProgressPhotoMaxAggregateInputType = {
    id?: true
    productProgressReportId?: true
    photoPath?: true
    thumbnailPath?: true
    description?: true
    uploadDate?: true
    fileSize?: true
    mimeType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductProgressPhotoCountAggregateInputType = {
    id?: true
    productProgressReportId?: true
    photoPath?: true
    thumbnailPath?: true
    description?: true
    uploadDate?: true
    fileSize?: true
    mimeType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductProgressPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductProgressPhoto to aggregate.
     */
    where?: ProductProgressPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductProgressPhotos to fetch.
     */
    orderBy?: ProductProgressPhotoOrderByWithRelationInput | ProductProgressPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductProgressPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductProgressPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductProgressPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductProgressPhotos
    **/
    _count?: true | ProductProgressPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductProgressPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductProgressPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductProgressPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductProgressPhotoMaxAggregateInputType
  }

  export type GetProductProgressPhotoAggregateType<T extends ProductProgressPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateProductProgressPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductProgressPhoto[P]>
      : GetScalarType<T[P], AggregateProductProgressPhoto[P]>
  }




  export type ProductProgressPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductProgressPhotoWhereInput
    orderBy?: ProductProgressPhotoOrderByWithAggregationInput | ProductProgressPhotoOrderByWithAggregationInput[]
    by: ProductProgressPhotoScalarFieldEnum[] | ProductProgressPhotoScalarFieldEnum
    having?: ProductProgressPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductProgressPhotoCountAggregateInputType | true
    _avg?: ProductProgressPhotoAvgAggregateInputType
    _sum?: ProductProgressPhotoSumAggregateInputType
    _min?: ProductProgressPhotoMinAggregateInputType
    _max?: ProductProgressPhotoMaxAggregateInputType
  }

  export type ProductProgressPhotoGroupByOutputType = {
    id: number
    productProgressReportId: number
    photoPath: string
    thumbnailPath: string | null
    description: string | null
    uploadDate: Date
    fileSize: number | null
    mimeType: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductProgressPhotoCountAggregateOutputType | null
    _avg: ProductProgressPhotoAvgAggregateOutputType | null
    _sum: ProductProgressPhotoSumAggregateOutputType | null
    _min: ProductProgressPhotoMinAggregateOutputType | null
    _max: ProductProgressPhotoMaxAggregateOutputType | null
  }

  type GetProductProgressPhotoGroupByPayload<T extends ProductProgressPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductProgressPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductProgressPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductProgressPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductProgressPhotoGroupByOutputType[P]>
        }
      >
    >


  export type ProductProgressPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productProgressReportId?: boolean
    photoPath?: boolean
    thumbnailPath?: boolean
    description?: boolean
    uploadDate?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productProgressReport?: boolean | ProductProgressReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productProgressPhoto"]>

  export type ProductProgressPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productProgressReportId?: boolean
    photoPath?: boolean
    thumbnailPath?: boolean
    description?: boolean
    uploadDate?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productProgressReport?: boolean | ProductProgressReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productProgressPhoto"]>

  export type ProductProgressPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productProgressReportId?: boolean
    photoPath?: boolean
    thumbnailPath?: boolean
    description?: boolean
    uploadDate?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productProgressReport?: boolean | ProductProgressReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productProgressPhoto"]>

  export type ProductProgressPhotoSelectScalar = {
    id?: boolean
    productProgressReportId?: boolean
    photoPath?: boolean
    thumbnailPath?: boolean
    description?: boolean
    uploadDate?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductProgressPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productProgressReportId" | "photoPath" | "thumbnailPath" | "description" | "uploadDate" | "fileSize" | "mimeType" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["productProgressPhoto"]>
  export type ProductProgressPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productProgressReport?: boolean | ProductProgressReportDefaultArgs<ExtArgs>
  }
  export type ProductProgressPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productProgressReport?: boolean | ProductProgressReportDefaultArgs<ExtArgs>
  }
  export type ProductProgressPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productProgressReport?: boolean | ProductProgressReportDefaultArgs<ExtArgs>
  }

  export type $ProductProgressPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductProgressPhoto"
    objects: {
      productProgressReport: Prisma.$ProductProgressReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productProgressReportId: number
      photoPath: string
      thumbnailPath: string | null
      description: string | null
      uploadDate: Date
      fileSize: number | null
      mimeType: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productProgressPhoto"]>
    composites: {}
  }

  type ProductProgressPhotoGetPayload<S extends boolean | null | undefined | ProductProgressPhotoDefaultArgs> = $Result.GetResult<Prisma.$ProductProgressPhotoPayload, S>

  type ProductProgressPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductProgressPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductProgressPhotoCountAggregateInputType | true
    }

  export interface ProductProgressPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductProgressPhoto'], meta: { name: 'ProductProgressPhoto' } }
    /**
     * Find zero or one ProductProgressPhoto that matches the filter.
     * @param {ProductProgressPhotoFindUniqueArgs} args - Arguments to find a ProductProgressPhoto
     * @example
     * // Get one ProductProgressPhoto
     * const productProgressPhoto = await prisma.productProgressPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductProgressPhotoFindUniqueArgs>(args: SelectSubset<T, ProductProgressPhotoFindUniqueArgs<ExtArgs>>): Prisma__ProductProgressPhotoClient<$Result.GetResult<Prisma.$ProductProgressPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductProgressPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductProgressPhotoFindUniqueOrThrowArgs} args - Arguments to find a ProductProgressPhoto
     * @example
     * // Get one ProductProgressPhoto
     * const productProgressPhoto = await prisma.productProgressPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductProgressPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductProgressPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductProgressPhotoClient<$Result.GetResult<Prisma.$ProductProgressPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductProgressPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressPhotoFindFirstArgs} args - Arguments to find a ProductProgressPhoto
     * @example
     * // Get one ProductProgressPhoto
     * const productProgressPhoto = await prisma.productProgressPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductProgressPhotoFindFirstArgs>(args?: SelectSubset<T, ProductProgressPhotoFindFirstArgs<ExtArgs>>): Prisma__ProductProgressPhotoClient<$Result.GetResult<Prisma.$ProductProgressPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductProgressPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressPhotoFindFirstOrThrowArgs} args - Arguments to find a ProductProgressPhoto
     * @example
     * // Get one ProductProgressPhoto
     * const productProgressPhoto = await prisma.productProgressPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductProgressPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductProgressPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductProgressPhotoClient<$Result.GetResult<Prisma.$ProductProgressPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductProgressPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductProgressPhotos
     * const productProgressPhotos = await prisma.productProgressPhoto.findMany()
     * 
     * // Get first 10 ProductProgressPhotos
     * const productProgressPhotos = await prisma.productProgressPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productProgressPhotoWithIdOnly = await prisma.productProgressPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductProgressPhotoFindManyArgs>(args?: SelectSubset<T, ProductProgressPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductProgressPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductProgressPhoto.
     * @param {ProductProgressPhotoCreateArgs} args - Arguments to create a ProductProgressPhoto.
     * @example
     * // Create one ProductProgressPhoto
     * const ProductProgressPhoto = await prisma.productProgressPhoto.create({
     *   data: {
     *     // ... data to create a ProductProgressPhoto
     *   }
     * })
     * 
     */
    create<T extends ProductProgressPhotoCreateArgs>(args: SelectSubset<T, ProductProgressPhotoCreateArgs<ExtArgs>>): Prisma__ProductProgressPhotoClient<$Result.GetResult<Prisma.$ProductProgressPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductProgressPhotos.
     * @param {ProductProgressPhotoCreateManyArgs} args - Arguments to create many ProductProgressPhotos.
     * @example
     * // Create many ProductProgressPhotos
     * const productProgressPhoto = await prisma.productProgressPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductProgressPhotoCreateManyArgs>(args?: SelectSubset<T, ProductProgressPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductProgressPhotos and returns the data saved in the database.
     * @param {ProductProgressPhotoCreateManyAndReturnArgs} args - Arguments to create many ProductProgressPhotos.
     * @example
     * // Create many ProductProgressPhotos
     * const productProgressPhoto = await prisma.productProgressPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductProgressPhotos and only return the `id`
     * const productProgressPhotoWithIdOnly = await prisma.productProgressPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductProgressPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductProgressPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductProgressPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductProgressPhoto.
     * @param {ProductProgressPhotoDeleteArgs} args - Arguments to delete one ProductProgressPhoto.
     * @example
     * // Delete one ProductProgressPhoto
     * const ProductProgressPhoto = await prisma.productProgressPhoto.delete({
     *   where: {
     *     // ... filter to delete one ProductProgressPhoto
     *   }
     * })
     * 
     */
    delete<T extends ProductProgressPhotoDeleteArgs>(args: SelectSubset<T, ProductProgressPhotoDeleteArgs<ExtArgs>>): Prisma__ProductProgressPhotoClient<$Result.GetResult<Prisma.$ProductProgressPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductProgressPhoto.
     * @param {ProductProgressPhotoUpdateArgs} args - Arguments to update one ProductProgressPhoto.
     * @example
     * // Update one ProductProgressPhoto
     * const productProgressPhoto = await prisma.productProgressPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductProgressPhotoUpdateArgs>(args: SelectSubset<T, ProductProgressPhotoUpdateArgs<ExtArgs>>): Prisma__ProductProgressPhotoClient<$Result.GetResult<Prisma.$ProductProgressPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductProgressPhotos.
     * @param {ProductProgressPhotoDeleteManyArgs} args - Arguments to filter ProductProgressPhotos to delete.
     * @example
     * // Delete a few ProductProgressPhotos
     * const { count } = await prisma.productProgressPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductProgressPhotoDeleteManyArgs>(args?: SelectSubset<T, ProductProgressPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductProgressPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductProgressPhotos
     * const productProgressPhoto = await prisma.productProgressPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductProgressPhotoUpdateManyArgs>(args: SelectSubset<T, ProductProgressPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductProgressPhotos and returns the data updated in the database.
     * @param {ProductProgressPhotoUpdateManyAndReturnArgs} args - Arguments to update many ProductProgressPhotos.
     * @example
     * // Update many ProductProgressPhotos
     * const productProgressPhoto = await prisma.productProgressPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductProgressPhotos and only return the `id`
     * const productProgressPhotoWithIdOnly = await prisma.productProgressPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductProgressPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductProgressPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductProgressPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductProgressPhoto.
     * @param {ProductProgressPhotoUpsertArgs} args - Arguments to update or create a ProductProgressPhoto.
     * @example
     * // Update or create a ProductProgressPhoto
     * const productProgressPhoto = await prisma.productProgressPhoto.upsert({
     *   create: {
     *     // ... data to create a ProductProgressPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductProgressPhoto we want to update
     *   }
     * })
     */
    upsert<T extends ProductProgressPhotoUpsertArgs>(args: SelectSubset<T, ProductProgressPhotoUpsertArgs<ExtArgs>>): Prisma__ProductProgressPhotoClient<$Result.GetResult<Prisma.$ProductProgressPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductProgressPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressPhotoCountArgs} args - Arguments to filter ProductProgressPhotos to count.
     * @example
     * // Count the number of ProductProgressPhotos
     * const count = await prisma.productProgressPhoto.count({
     *   where: {
     *     // ... the filter for the ProductProgressPhotos we want to count
     *   }
     * })
    **/
    count<T extends ProductProgressPhotoCountArgs>(
      args?: Subset<T, ProductProgressPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductProgressPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductProgressPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductProgressPhotoAggregateArgs>(args: Subset<T, ProductProgressPhotoAggregateArgs>): Prisma.PrismaPromise<GetProductProgressPhotoAggregateType<T>>

    /**
     * Group by ProductProgressPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProgressPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductProgressPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductProgressPhotoGroupByArgs['orderBy'] }
        : { orderBy?: ProductProgressPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductProgressPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductProgressPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductProgressPhoto model
   */
  readonly fields: ProductProgressPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductProgressPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductProgressPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productProgressReport<T extends ProductProgressReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductProgressReportDefaultArgs<ExtArgs>>): Prisma__ProductProgressReportClient<$Result.GetResult<Prisma.$ProductProgressReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductProgressPhoto model
   */
  interface ProductProgressPhotoFieldRefs {
    readonly id: FieldRef<"ProductProgressPhoto", 'Int'>
    readonly productProgressReportId: FieldRef<"ProductProgressPhoto", 'Int'>
    readonly photoPath: FieldRef<"ProductProgressPhoto", 'String'>
    readonly thumbnailPath: FieldRef<"ProductProgressPhoto", 'String'>
    readonly description: FieldRef<"ProductProgressPhoto", 'String'>
    readonly uploadDate: FieldRef<"ProductProgressPhoto", 'DateTime'>
    readonly fileSize: FieldRef<"ProductProgressPhoto", 'Int'>
    readonly mimeType: FieldRef<"ProductProgressPhoto", 'String'>
    readonly isActive: FieldRef<"ProductProgressPhoto", 'Boolean'>
    readonly createdAt: FieldRef<"ProductProgressPhoto", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductProgressPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductProgressPhoto findUnique
   */
  export type ProductProgressPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProductProgressPhoto to fetch.
     */
    where: ProductProgressPhotoWhereUniqueInput
  }

  /**
   * ProductProgressPhoto findUniqueOrThrow
   */
  export type ProductProgressPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProductProgressPhoto to fetch.
     */
    where: ProductProgressPhotoWhereUniqueInput
  }

  /**
   * ProductProgressPhoto findFirst
   */
  export type ProductProgressPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProductProgressPhoto to fetch.
     */
    where?: ProductProgressPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductProgressPhotos to fetch.
     */
    orderBy?: ProductProgressPhotoOrderByWithRelationInput | ProductProgressPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductProgressPhotos.
     */
    cursor?: ProductProgressPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductProgressPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductProgressPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductProgressPhotos.
     */
    distinct?: ProductProgressPhotoScalarFieldEnum | ProductProgressPhotoScalarFieldEnum[]
  }

  /**
   * ProductProgressPhoto findFirstOrThrow
   */
  export type ProductProgressPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProductProgressPhoto to fetch.
     */
    where?: ProductProgressPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductProgressPhotos to fetch.
     */
    orderBy?: ProductProgressPhotoOrderByWithRelationInput | ProductProgressPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductProgressPhotos.
     */
    cursor?: ProductProgressPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductProgressPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductProgressPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductProgressPhotos.
     */
    distinct?: ProductProgressPhotoScalarFieldEnum | ProductProgressPhotoScalarFieldEnum[]
  }

  /**
   * ProductProgressPhoto findMany
   */
  export type ProductProgressPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProductProgressPhotos to fetch.
     */
    where?: ProductProgressPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductProgressPhotos to fetch.
     */
    orderBy?: ProductProgressPhotoOrderByWithRelationInput | ProductProgressPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductProgressPhotos.
     */
    cursor?: ProductProgressPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductProgressPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductProgressPhotos.
     */
    skip?: number
    distinct?: ProductProgressPhotoScalarFieldEnum | ProductProgressPhotoScalarFieldEnum[]
  }

  /**
   * ProductProgressPhoto create
   */
  export type ProductProgressPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductProgressPhoto.
     */
    data: XOR<ProductProgressPhotoCreateInput, ProductProgressPhotoUncheckedCreateInput>
  }

  /**
   * ProductProgressPhoto createMany
   */
  export type ProductProgressPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductProgressPhotos.
     */
    data: ProductProgressPhotoCreateManyInput | ProductProgressPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductProgressPhoto createManyAndReturn
   */
  export type ProductProgressPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many ProductProgressPhotos.
     */
    data: ProductProgressPhotoCreateManyInput | ProductProgressPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductProgressPhoto update
   */
  export type ProductProgressPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductProgressPhoto.
     */
    data: XOR<ProductProgressPhotoUpdateInput, ProductProgressPhotoUncheckedUpdateInput>
    /**
     * Choose, which ProductProgressPhoto to update.
     */
    where: ProductProgressPhotoWhereUniqueInput
  }

  /**
   * ProductProgressPhoto updateMany
   */
  export type ProductProgressPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductProgressPhotos.
     */
    data: XOR<ProductProgressPhotoUpdateManyMutationInput, ProductProgressPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ProductProgressPhotos to update
     */
    where?: ProductProgressPhotoWhereInput
    /**
     * Limit how many ProductProgressPhotos to update.
     */
    limit?: number
  }

  /**
   * ProductProgressPhoto updateManyAndReturn
   */
  export type ProductProgressPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * The data used to update ProductProgressPhotos.
     */
    data: XOR<ProductProgressPhotoUpdateManyMutationInput, ProductProgressPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ProductProgressPhotos to update
     */
    where?: ProductProgressPhotoWhereInput
    /**
     * Limit how many ProductProgressPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductProgressPhoto upsert
   */
  export type ProductProgressPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductProgressPhoto to update in case it exists.
     */
    where: ProductProgressPhotoWhereUniqueInput
    /**
     * In case the ProductProgressPhoto found by the `where` argument doesn't exist, create a new ProductProgressPhoto with this data.
     */
    create: XOR<ProductProgressPhotoCreateInput, ProductProgressPhotoUncheckedCreateInput>
    /**
     * In case the ProductProgressPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductProgressPhotoUpdateInput, ProductProgressPhotoUncheckedUpdateInput>
  }

  /**
   * ProductProgressPhoto delete
   */
  export type ProductProgressPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoInclude<ExtArgs> | null
    /**
     * Filter which ProductProgressPhoto to delete.
     */
    where: ProductProgressPhotoWhereUniqueInput
  }

  /**
   * ProductProgressPhoto deleteMany
   */
  export type ProductProgressPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductProgressPhotos to delete
     */
    where?: ProductProgressPhotoWhereInput
    /**
     * Limit how many ProductProgressPhotos to delete.
     */
    limit?: number
  }

  /**
   * ProductProgressPhoto without action
   */
  export type ProductProgressPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductProgressPhoto
     */
    select?: ProductProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductProgressPhoto
     */
    omit?: ProductProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductProgressPhotoInclude<ExtArgs> | null
  }


  /**
   * Model RemainingMaterial
   */

  export type AggregateRemainingMaterial = {
    _count: RemainingMaterialCountAggregateOutputType | null
    _avg: RemainingMaterialAvgAggregateOutputType | null
    _sum: RemainingMaterialSumAggregateOutputType | null
    _min: RemainingMaterialMinAggregateOutputType | null
    _max: RemainingMaterialMaxAggregateOutputType | null
  }

  export type RemainingMaterialAvgAggregateOutputType = {
    id: number | null
    materialId: number | null
    quantity: Decimal | null
  }

  export type RemainingMaterialSumAggregateOutputType = {
    id: number | null
    materialId: number | null
    quantity: Decimal | null
  }

  export type RemainingMaterialMinAggregateOutputType = {
    id: number | null
    materialId: number | null
    quantity: Decimal | null
    unit: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RemainingMaterialMaxAggregateOutputType = {
    id: number | null
    materialId: number | null
    quantity: Decimal | null
    unit: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RemainingMaterialCountAggregateOutputType = {
    id: number
    materialId: number
    quantity: number
    unit: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RemainingMaterialAvgAggregateInputType = {
    id?: true
    materialId?: true
    quantity?: true
  }

  export type RemainingMaterialSumAggregateInputType = {
    id?: true
    materialId?: true
    quantity?: true
  }

  export type RemainingMaterialMinAggregateInputType = {
    id?: true
    materialId?: true
    quantity?: true
    unit?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RemainingMaterialMaxAggregateInputType = {
    id?: true
    materialId?: true
    quantity?: true
    unit?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RemainingMaterialCountAggregateInputType = {
    id?: true
    materialId?: true
    quantity?: true
    unit?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RemainingMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RemainingMaterial to aggregate.
     */
    where?: RemainingMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemainingMaterials to fetch.
     */
    orderBy?: RemainingMaterialOrderByWithRelationInput | RemainingMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RemainingMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemainingMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemainingMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RemainingMaterials
    **/
    _count?: true | RemainingMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RemainingMaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RemainingMaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RemainingMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RemainingMaterialMaxAggregateInputType
  }

  export type GetRemainingMaterialAggregateType<T extends RemainingMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateRemainingMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRemainingMaterial[P]>
      : GetScalarType<T[P], AggregateRemainingMaterial[P]>
  }




  export type RemainingMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemainingMaterialWhereInput
    orderBy?: RemainingMaterialOrderByWithAggregationInput | RemainingMaterialOrderByWithAggregationInput[]
    by: RemainingMaterialScalarFieldEnum[] | RemainingMaterialScalarFieldEnum
    having?: RemainingMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RemainingMaterialCountAggregateInputType | true
    _avg?: RemainingMaterialAvgAggregateInputType
    _sum?: RemainingMaterialSumAggregateInputType
    _min?: RemainingMaterialMinAggregateInputType
    _max?: RemainingMaterialMaxAggregateInputType
  }

  export type RemainingMaterialGroupByOutputType = {
    id: number
    materialId: number
    quantity: Decimal
    unit: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: RemainingMaterialCountAggregateOutputType | null
    _avg: RemainingMaterialAvgAggregateOutputType | null
    _sum: RemainingMaterialSumAggregateOutputType | null
    _min: RemainingMaterialMinAggregateOutputType | null
    _max: RemainingMaterialMaxAggregateOutputType | null
  }

  type GetRemainingMaterialGroupByPayload<T extends RemainingMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RemainingMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RemainingMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RemainingMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], RemainingMaterialGroupByOutputType[P]>
        }
      >
    >


  export type RemainingMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    quantity?: boolean
    unit?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remainingMaterial"]>

  export type RemainingMaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    quantity?: boolean
    unit?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remainingMaterial"]>

  export type RemainingMaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    quantity?: boolean
    unit?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remainingMaterial"]>

  export type RemainingMaterialSelectScalar = {
    id?: boolean
    materialId?: boolean
    quantity?: boolean
    unit?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RemainingMaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "materialId" | "quantity" | "unit" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["remainingMaterial"]>
  export type RemainingMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type RemainingMaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type RemainingMaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }

  export type $RemainingMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RemainingMaterial"
    objects: {
      material: Prisma.$MaterialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materialId: number
      quantity: Prisma.Decimal
      unit: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["remainingMaterial"]>
    composites: {}
  }

  type RemainingMaterialGetPayload<S extends boolean | null | undefined | RemainingMaterialDefaultArgs> = $Result.GetResult<Prisma.$RemainingMaterialPayload, S>

  type RemainingMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RemainingMaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RemainingMaterialCountAggregateInputType | true
    }

  export interface RemainingMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RemainingMaterial'], meta: { name: 'RemainingMaterial' } }
    /**
     * Find zero or one RemainingMaterial that matches the filter.
     * @param {RemainingMaterialFindUniqueArgs} args - Arguments to find a RemainingMaterial
     * @example
     * // Get one RemainingMaterial
     * const remainingMaterial = await prisma.remainingMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RemainingMaterialFindUniqueArgs>(args: SelectSubset<T, RemainingMaterialFindUniqueArgs<ExtArgs>>): Prisma__RemainingMaterialClient<$Result.GetResult<Prisma.$RemainingMaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RemainingMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RemainingMaterialFindUniqueOrThrowArgs} args - Arguments to find a RemainingMaterial
     * @example
     * // Get one RemainingMaterial
     * const remainingMaterial = await prisma.remainingMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RemainingMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, RemainingMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RemainingMaterialClient<$Result.GetResult<Prisma.$RemainingMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RemainingMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemainingMaterialFindFirstArgs} args - Arguments to find a RemainingMaterial
     * @example
     * // Get one RemainingMaterial
     * const remainingMaterial = await prisma.remainingMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RemainingMaterialFindFirstArgs>(args?: SelectSubset<T, RemainingMaterialFindFirstArgs<ExtArgs>>): Prisma__RemainingMaterialClient<$Result.GetResult<Prisma.$RemainingMaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RemainingMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemainingMaterialFindFirstOrThrowArgs} args - Arguments to find a RemainingMaterial
     * @example
     * // Get one RemainingMaterial
     * const remainingMaterial = await prisma.remainingMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RemainingMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, RemainingMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__RemainingMaterialClient<$Result.GetResult<Prisma.$RemainingMaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RemainingMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemainingMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RemainingMaterials
     * const remainingMaterials = await prisma.remainingMaterial.findMany()
     * 
     * // Get first 10 RemainingMaterials
     * const remainingMaterials = await prisma.remainingMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const remainingMaterialWithIdOnly = await prisma.remainingMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RemainingMaterialFindManyArgs>(args?: SelectSubset<T, RemainingMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemainingMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RemainingMaterial.
     * @param {RemainingMaterialCreateArgs} args - Arguments to create a RemainingMaterial.
     * @example
     * // Create one RemainingMaterial
     * const RemainingMaterial = await prisma.remainingMaterial.create({
     *   data: {
     *     // ... data to create a RemainingMaterial
     *   }
     * })
     * 
     */
    create<T extends RemainingMaterialCreateArgs>(args: SelectSubset<T, RemainingMaterialCreateArgs<ExtArgs>>): Prisma__RemainingMaterialClient<$Result.GetResult<Prisma.$RemainingMaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RemainingMaterials.
     * @param {RemainingMaterialCreateManyArgs} args - Arguments to create many RemainingMaterials.
     * @example
     * // Create many RemainingMaterials
     * const remainingMaterial = await prisma.remainingMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RemainingMaterialCreateManyArgs>(args?: SelectSubset<T, RemainingMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RemainingMaterials and returns the data saved in the database.
     * @param {RemainingMaterialCreateManyAndReturnArgs} args - Arguments to create many RemainingMaterials.
     * @example
     * // Create many RemainingMaterials
     * const remainingMaterial = await prisma.remainingMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RemainingMaterials and only return the `id`
     * const remainingMaterialWithIdOnly = await prisma.remainingMaterial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RemainingMaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, RemainingMaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemainingMaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RemainingMaterial.
     * @param {RemainingMaterialDeleteArgs} args - Arguments to delete one RemainingMaterial.
     * @example
     * // Delete one RemainingMaterial
     * const RemainingMaterial = await prisma.remainingMaterial.delete({
     *   where: {
     *     // ... filter to delete one RemainingMaterial
     *   }
     * })
     * 
     */
    delete<T extends RemainingMaterialDeleteArgs>(args: SelectSubset<T, RemainingMaterialDeleteArgs<ExtArgs>>): Prisma__RemainingMaterialClient<$Result.GetResult<Prisma.$RemainingMaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RemainingMaterial.
     * @param {RemainingMaterialUpdateArgs} args - Arguments to update one RemainingMaterial.
     * @example
     * // Update one RemainingMaterial
     * const remainingMaterial = await prisma.remainingMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RemainingMaterialUpdateArgs>(args: SelectSubset<T, RemainingMaterialUpdateArgs<ExtArgs>>): Prisma__RemainingMaterialClient<$Result.GetResult<Prisma.$RemainingMaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RemainingMaterials.
     * @param {RemainingMaterialDeleteManyArgs} args - Arguments to filter RemainingMaterials to delete.
     * @example
     * // Delete a few RemainingMaterials
     * const { count } = await prisma.remainingMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RemainingMaterialDeleteManyArgs>(args?: SelectSubset<T, RemainingMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RemainingMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemainingMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RemainingMaterials
     * const remainingMaterial = await prisma.remainingMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RemainingMaterialUpdateManyArgs>(args: SelectSubset<T, RemainingMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RemainingMaterials and returns the data updated in the database.
     * @param {RemainingMaterialUpdateManyAndReturnArgs} args - Arguments to update many RemainingMaterials.
     * @example
     * // Update many RemainingMaterials
     * const remainingMaterial = await prisma.remainingMaterial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RemainingMaterials and only return the `id`
     * const remainingMaterialWithIdOnly = await prisma.remainingMaterial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RemainingMaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, RemainingMaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemainingMaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RemainingMaterial.
     * @param {RemainingMaterialUpsertArgs} args - Arguments to update or create a RemainingMaterial.
     * @example
     * // Update or create a RemainingMaterial
     * const remainingMaterial = await prisma.remainingMaterial.upsert({
     *   create: {
     *     // ... data to create a RemainingMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RemainingMaterial we want to update
     *   }
     * })
     */
    upsert<T extends RemainingMaterialUpsertArgs>(args: SelectSubset<T, RemainingMaterialUpsertArgs<ExtArgs>>): Prisma__RemainingMaterialClient<$Result.GetResult<Prisma.$RemainingMaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RemainingMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemainingMaterialCountArgs} args - Arguments to filter RemainingMaterials to count.
     * @example
     * // Count the number of RemainingMaterials
     * const count = await prisma.remainingMaterial.count({
     *   where: {
     *     // ... the filter for the RemainingMaterials we want to count
     *   }
     * })
    **/
    count<T extends RemainingMaterialCountArgs>(
      args?: Subset<T, RemainingMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RemainingMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RemainingMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemainingMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RemainingMaterialAggregateArgs>(args: Subset<T, RemainingMaterialAggregateArgs>): Prisma.PrismaPromise<GetRemainingMaterialAggregateType<T>>

    /**
     * Group by RemainingMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemainingMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RemainingMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RemainingMaterialGroupByArgs['orderBy'] }
        : { orderBy?: RemainingMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RemainingMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRemainingMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RemainingMaterial model
   */
  readonly fields: RemainingMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RemainingMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RemainingMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RemainingMaterial model
   */
  interface RemainingMaterialFieldRefs {
    readonly id: FieldRef<"RemainingMaterial", 'Int'>
    readonly materialId: FieldRef<"RemainingMaterial", 'Int'>
    readonly quantity: FieldRef<"RemainingMaterial", 'Decimal'>
    readonly unit: FieldRef<"RemainingMaterial", 'String'>
    readonly notes: FieldRef<"RemainingMaterial", 'String'>
    readonly createdAt: FieldRef<"RemainingMaterial", 'DateTime'>
    readonly updatedAt: FieldRef<"RemainingMaterial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RemainingMaterial findUnique
   */
  export type RemainingMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RemainingMaterial to fetch.
     */
    where: RemainingMaterialWhereUniqueInput
  }

  /**
   * RemainingMaterial findUniqueOrThrow
   */
  export type RemainingMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RemainingMaterial to fetch.
     */
    where: RemainingMaterialWhereUniqueInput
  }

  /**
   * RemainingMaterial findFirst
   */
  export type RemainingMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RemainingMaterial to fetch.
     */
    where?: RemainingMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemainingMaterials to fetch.
     */
    orderBy?: RemainingMaterialOrderByWithRelationInput | RemainingMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RemainingMaterials.
     */
    cursor?: RemainingMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemainingMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemainingMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RemainingMaterials.
     */
    distinct?: RemainingMaterialScalarFieldEnum | RemainingMaterialScalarFieldEnum[]
  }

  /**
   * RemainingMaterial findFirstOrThrow
   */
  export type RemainingMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RemainingMaterial to fetch.
     */
    where?: RemainingMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemainingMaterials to fetch.
     */
    orderBy?: RemainingMaterialOrderByWithRelationInput | RemainingMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RemainingMaterials.
     */
    cursor?: RemainingMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemainingMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemainingMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RemainingMaterials.
     */
    distinct?: RemainingMaterialScalarFieldEnum | RemainingMaterialScalarFieldEnum[]
  }

  /**
   * RemainingMaterial findMany
   */
  export type RemainingMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialInclude<ExtArgs> | null
    /**
     * Filter, which RemainingMaterials to fetch.
     */
    where?: RemainingMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemainingMaterials to fetch.
     */
    orderBy?: RemainingMaterialOrderByWithRelationInput | RemainingMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RemainingMaterials.
     */
    cursor?: RemainingMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemainingMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemainingMaterials.
     */
    skip?: number
    distinct?: RemainingMaterialScalarFieldEnum | RemainingMaterialScalarFieldEnum[]
  }

  /**
   * RemainingMaterial create
   */
  export type RemainingMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a RemainingMaterial.
     */
    data: XOR<RemainingMaterialCreateInput, RemainingMaterialUncheckedCreateInput>
  }

  /**
   * RemainingMaterial createMany
   */
  export type RemainingMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RemainingMaterials.
     */
    data: RemainingMaterialCreateManyInput | RemainingMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RemainingMaterial createManyAndReturn
   */
  export type RemainingMaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * The data used to create many RemainingMaterials.
     */
    data: RemainingMaterialCreateManyInput | RemainingMaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RemainingMaterial update
   */
  export type RemainingMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a RemainingMaterial.
     */
    data: XOR<RemainingMaterialUpdateInput, RemainingMaterialUncheckedUpdateInput>
    /**
     * Choose, which RemainingMaterial to update.
     */
    where: RemainingMaterialWhereUniqueInput
  }

  /**
   * RemainingMaterial updateMany
   */
  export type RemainingMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RemainingMaterials.
     */
    data: XOR<RemainingMaterialUpdateManyMutationInput, RemainingMaterialUncheckedUpdateManyInput>
    /**
     * Filter which RemainingMaterials to update
     */
    where?: RemainingMaterialWhereInput
    /**
     * Limit how many RemainingMaterials to update.
     */
    limit?: number
  }

  /**
   * RemainingMaterial updateManyAndReturn
   */
  export type RemainingMaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * The data used to update RemainingMaterials.
     */
    data: XOR<RemainingMaterialUpdateManyMutationInput, RemainingMaterialUncheckedUpdateManyInput>
    /**
     * Filter which RemainingMaterials to update
     */
    where?: RemainingMaterialWhereInput
    /**
     * Limit how many RemainingMaterials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RemainingMaterial upsert
   */
  export type RemainingMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the RemainingMaterial to update in case it exists.
     */
    where: RemainingMaterialWhereUniqueInput
    /**
     * In case the RemainingMaterial found by the `where` argument doesn't exist, create a new RemainingMaterial with this data.
     */
    create: XOR<RemainingMaterialCreateInput, RemainingMaterialUncheckedCreateInput>
    /**
     * In case the RemainingMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RemainingMaterialUpdateInput, RemainingMaterialUncheckedUpdateInput>
  }

  /**
   * RemainingMaterial delete
   */
  export type RemainingMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialInclude<ExtArgs> | null
    /**
     * Filter which RemainingMaterial to delete.
     */
    where: RemainingMaterialWhereUniqueInput
  }

  /**
   * RemainingMaterial deleteMany
   */
  export type RemainingMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RemainingMaterials to delete
     */
    where?: RemainingMaterialWhereInput
    /**
     * Limit how many RemainingMaterials to delete.
     */
    limit?: number
  }

  /**
   * RemainingMaterial without action
   */
  export type RemainingMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemainingMaterial
     */
    select?: RemainingMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemainingMaterial
     */
    omit?: RemainingMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemainingMaterialInclude<ExtArgs> | null
  }


  /**
   * Model Inventaris
   */

  export type AggregateInventaris = {
    _count: InventarisCountAggregateOutputType | null
    _avg: InventarisAvgAggregateOutputType | null
    _sum: InventarisSumAggregateOutputType | null
    _min: InventarisMinAggregateOutputType | null
    _max: InventarisMaxAggregateOutputType | null
  }

  export type InventarisAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
  }

  export type InventarisSumAggregateOutputType = {
    id: number | null
    quantity: number | null
  }

  export type InventarisMinAggregateOutputType = {
    id: number | null
    name: string | null
    quantity: number | null
    unit: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventarisMaxAggregateOutputType = {
    id: number | null
    name: string | null
    quantity: number | null
    unit: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventarisCountAggregateOutputType = {
    id: number
    name: number
    quantity: number
    unit: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventarisAvgAggregateInputType = {
    id?: true
    quantity?: true
  }

  export type InventarisSumAggregateInputType = {
    id?: true
    quantity?: true
  }

  export type InventarisMinAggregateInputType = {
    id?: true
    name?: true
    quantity?: true
    unit?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventarisMaxAggregateInputType = {
    id?: true
    name?: true
    quantity?: true
    unit?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventarisCountAggregateInputType = {
    id?: true
    name?: true
    quantity?: true
    unit?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventarisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventaris to aggregate.
     */
    where?: InventarisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventarises to fetch.
     */
    orderBy?: InventarisOrderByWithRelationInput | InventarisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventarisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventarises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventarises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventarises
    **/
    _count?: true | InventarisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventarisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventarisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventarisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventarisMaxAggregateInputType
  }

  export type GetInventarisAggregateType<T extends InventarisAggregateArgs> = {
        [P in keyof T & keyof AggregateInventaris]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventaris[P]>
      : GetScalarType<T[P], AggregateInventaris[P]>
  }




  export type InventarisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventarisWhereInput
    orderBy?: InventarisOrderByWithAggregationInput | InventarisOrderByWithAggregationInput[]
    by: InventarisScalarFieldEnum[] | InventarisScalarFieldEnum
    having?: InventarisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventarisCountAggregateInputType | true
    _avg?: InventarisAvgAggregateInputType
    _sum?: InventarisSumAggregateInputType
    _min?: InventarisMinAggregateInputType
    _max?: InventarisMaxAggregateInputType
  }

  export type InventarisGroupByOutputType = {
    id: number
    name: string
    quantity: number
    unit: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InventarisCountAggregateOutputType | null
    _avg: InventarisAvgAggregateOutputType | null
    _sum: InventarisSumAggregateOutputType | null
    _min: InventarisMinAggregateOutputType | null
    _max: InventarisMaxAggregateOutputType | null
  }

  type GetInventarisGroupByPayload<T extends InventarisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventarisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventarisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventarisGroupByOutputType[P]>
            : GetScalarType<T[P], InventarisGroupByOutputType[P]>
        }
      >
    >


  export type InventarisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    quantity?: boolean
    unit?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventaris"]>

  export type InventarisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    quantity?: boolean
    unit?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventaris"]>

  export type InventarisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    quantity?: boolean
    unit?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventaris"]>

  export type InventarisSelectScalar = {
    id?: boolean
    name?: boolean
    quantity?: boolean
    unit?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventarisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "quantity" | "unit" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["inventaris"]>

  export type $InventarisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventaris"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      quantity: number
      unit: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventaris"]>
    composites: {}
  }

  type InventarisGetPayload<S extends boolean | null | undefined | InventarisDefaultArgs> = $Result.GetResult<Prisma.$InventarisPayload, S>

  type InventarisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventarisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventarisCountAggregateInputType | true
    }

  export interface InventarisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventaris'], meta: { name: 'Inventaris' } }
    /**
     * Find zero or one Inventaris that matches the filter.
     * @param {InventarisFindUniqueArgs} args - Arguments to find a Inventaris
     * @example
     * // Get one Inventaris
     * const inventaris = await prisma.inventaris.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventarisFindUniqueArgs>(args: SelectSubset<T, InventarisFindUniqueArgs<ExtArgs>>): Prisma__InventarisClient<$Result.GetResult<Prisma.$InventarisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventaris that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventarisFindUniqueOrThrowArgs} args - Arguments to find a Inventaris
     * @example
     * // Get one Inventaris
     * const inventaris = await prisma.inventaris.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventarisFindUniqueOrThrowArgs>(args: SelectSubset<T, InventarisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventarisClient<$Result.GetResult<Prisma.$InventarisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventaris that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarisFindFirstArgs} args - Arguments to find a Inventaris
     * @example
     * // Get one Inventaris
     * const inventaris = await prisma.inventaris.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventarisFindFirstArgs>(args?: SelectSubset<T, InventarisFindFirstArgs<ExtArgs>>): Prisma__InventarisClient<$Result.GetResult<Prisma.$InventarisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventaris that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarisFindFirstOrThrowArgs} args - Arguments to find a Inventaris
     * @example
     * // Get one Inventaris
     * const inventaris = await prisma.inventaris.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventarisFindFirstOrThrowArgs>(args?: SelectSubset<T, InventarisFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventarisClient<$Result.GetResult<Prisma.$InventarisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventarises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventarises
     * const inventarises = await prisma.inventaris.findMany()
     * 
     * // Get first 10 Inventarises
     * const inventarises = await prisma.inventaris.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventarisWithIdOnly = await prisma.inventaris.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventarisFindManyArgs>(args?: SelectSubset<T, InventarisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventaris.
     * @param {InventarisCreateArgs} args - Arguments to create a Inventaris.
     * @example
     * // Create one Inventaris
     * const Inventaris = await prisma.inventaris.create({
     *   data: {
     *     // ... data to create a Inventaris
     *   }
     * })
     * 
     */
    create<T extends InventarisCreateArgs>(args: SelectSubset<T, InventarisCreateArgs<ExtArgs>>): Prisma__InventarisClient<$Result.GetResult<Prisma.$InventarisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventarises.
     * @param {InventarisCreateManyArgs} args - Arguments to create many Inventarises.
     * @example
     * // Create many Inventarises
     * const inventaris = await prisma.inventaris.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventarisCreateManyArgs>(args?: SelectSubset<T, InventarisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventarises and returns the data saved in the database.
     * @param {InventarisCreateManyAndReturnArgs} args - Arguments to create many Inventarises.
     * @example
     * // Create many Inventarises
     * const inventaris = await prisma.inventaris.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventarises and only return the `id`
     * const inventarisWithIdOnly = await prisma.inventaris.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventarisCreateManyAndReturnArgs>(args?: SelectSubset<T, InventarisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inventaris.
     * @param {InventarisDeleteArgs} args - Arguments to delete one Inventaris.
     * @example
     * // Delete one Inventaris
     * const Inventaris = await prisma.inventaris.delete({
     *   where: {
     *     // ... filter to delete one Inventaris
     *   }
     * })
     * 
     */
    delete<T extends InventarisDeleteArgs>(args: SelectSubset<T, InventarisDeleteArgs<ExtArgs>>): Prisma__InventarisClient<$Result.GetResult<Prisma.$InventarisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventaris.
     * @param {InventarisUpdateArgs} args - Arguments to update one Inventaris.
     * @example
     * // Update one Inventaris
     * const inventaris = await prisma.inventaris.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventarisUpdateArgs>(args: SelectSubset<T, InventarisUpdateArgs<ExtArgs>>): Prisma__InventarisClient<$Result.GetResult<Prisma.$InventarisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventarises.
     * @param {InventarisDeleteManyArgs} args - Arguments to filter Inventarises to delete.
     * @example
     * // Delete a few Inventarises
     * const { count } = await prisma.inventaris.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventarisDeleteManyArgs>(args?: SelectSubset<T, InventarisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventarises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventarises
     * const inventaris = await prisma.inventaris.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventarisUpdateManyArgs>(args: SelectSubset<T, InventarisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventarises and returns the data updated in the database.
     * @param {InventarisUpdateManyAndReturnArgs} args - Arguments to update many Inventarises.
     * @example
     * // Update many Inventarises
     * const inventaris = await prisma.inventaris.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inventarises and only return the `id`
     * const inventarisWithIdOnly = await prisma.inventaris.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventarisUpdateManyAndReturnArgs>(args: SelectSubset<T, InventarisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventarisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inventaris.
     * @param {InventarisUpsertArgs} args - Arguments to update or create a Inventaris.
     * @example
     * // Update or create a Inventaris
     * const inventaris = await prisma.inventaris.upsert({
     *   create: {
     *     // ... data to create a Inventaris
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventaris we want to update
     *   }
     * })
     */
    upsert<T extends InventarisUpsertArgs>(args: SelectSubset<T, InventarisUpsertArgs<ExtArgs>>): Prisma__InventarisClient<$Result.GetResult<Prisma.$InventarisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventarises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarisCountArgs} args - Arguments to filter Inventarises to count.
     * @example
     * // Count the number of Inventarises
     * const count = await prisma.inventaris.count({
     *   where: {
     *     // ... the filter for the Inventarises we want to count
     *   }
     * })
    **/
    count<T extends InventarisCountArgs>(
      args?: Subset<T, InventarisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventarisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventaris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventarisAggregateArgs>(args: Subset<T, InventarisAggregateArgs>): Prisma.PrismaPromise<GetInventarisAggregateType<T>>

    /**
     * Group by Inventaris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventarisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventarisGroupByArgs['orderBy'] }
        : { orderBy?: InventarisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventarisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventarisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventaris model
   */
  readonly fields: InventarisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventaris.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventarisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventaris model
   */
  interface InventarisFieldRefs {
    readonly id: FieldRef<"Inventaris", 'Int'>
    readonly name: FieldRef<"Inventaris", 'String'>
    readonly quantity: FieldRef<"Inventaris", 'Int'>
    readonly unit: FieldRef<"Inventaris", 'String'>
    readonly notes: FieldRef<"Inventaris", 'String'>
    readonly createdAt: FieldRef<"Inventaris", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventaris", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventaris findUnique
   */
  export type InventarisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaris
     */
    select?: InventarisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventaris
     */
    omit?: InventarisOmit<ExtArgs> | null
    /**
     * Filter, which Inventaris to fetch.
     */
    where: InventarisWhereUniqueInput
  }

  /**
   * Inventaris findUniqueOrThrow
   */
  export type InventarisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaris
     */
    select?: InventarisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventaris
     */
    omit?: InventarisOmit<ExtArgs> | null
    /**
     * Filter, which Inventaris to fetch.
     */
    where: InventarisWhereUniqueInput
  }

  /**
   * Inventaris findFirst
   */
  export type InventarisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaris
     */
    select?: InventarisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventaris
     */
    omit?: InventarisOmit<ExtArgs> | null
    /**
     * Filter, which Inventaris to fetch.
     */
    where?: InventarisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventarises to fetch.
     */
    orderBy?: InventarisOrderByWithRelationInput | InventarisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventarises.
     */
    cursor?: InventarisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventarises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventarises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventarises.
     */
    distinct?: InventarisScalarFieldEnum | InventarisScalarFieldEnum[]
  }

  /**
   * Inventaris findFirstOrThrow
   */
  export type InventarisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaris
     */
    select?: InventarisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventaris
     */
    omit?: InventarisOmit<ExtArgs> | null
    /**
     * Filter, which Inventaris to fetch.
     */
    where?: InventarisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventarises to fetch.
     */
    orderBy?: InventarisOrderByWithRelationInput | InventarisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventarises.
     */
    cursor?: InventarisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventarises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventarises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventarises.
     */
    distinct?: InventarisScalarFieldEnum | InventarisScalarFieldEnum[]
  }

  /**
   * Inventaris findMany
   */
  export type InventarisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaris
     */
    select?: InventarisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventaris
     */
    omit?: InventarisOmit<ExtArgs> | null
    /**
     * Filter, which Inventarises to fetch.
     */
    where?: InventarisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventarises to fetch.
     */
    orderBy?: InventarisOrderByWithRelationInput | InventarisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventarises.
     */
    cursor?: InventarisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventarises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventarises.
     */
    skip?: number
    distinct?: InventarisScalarFieldEnum | InventarisScalarFieldEnum[]
  }

  /**
   * Inventaris create
   */
  export type InventarisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaris
     */
    select?: InventarisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventaris
     */
    omit?: InventarisOmit<ExtArgs> | null
    /**
     * The data needed to create a Inventaris.
     */
    data: XOR<InventarisCreateInput, InventarisUncheckedCreateInput>
  }

  /**
   * Inventaris createMany
   */
  export type InventarisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventarises.
     */
    data: InventarisCreateManyInput | InventarisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventaris createManyAndReturn
   */
  export type InventarisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaris
     */
    select?: InventarisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventaris
     */
    omit?: InventarisOmit<ExtArgs> | null
    /**
     * The data used to create many Inventarises.
     */
    data: InventarisCreateManyInput | InventarisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventaris update
   */
  export type InventarisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaris
     */
    select?: InventarisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventaris
     */
    omit?: InventarisOmit<ExtArgs> | null
    /**
     * The data needed to update a Inventaris.
     */
    data: XOR<InventarisUpdateInput, InventarisUncheckedUpdateInput>
    /**
     * Choose, which Inventaris to update.
     */
    where: InventarisWhereUniqueInput
  }

  /**
   * Inventaris updateMany
   */
  export type InventarisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventarises.
     */
    data: XOR<InventarisUpdateManyMutationInput, InventarisUncheckedUpdateManyInput>
    /**
     * Filter which Inventarises to update
     */
    where?: InventarisWhereInput
    /**
     * Limit how many Inventarises to update.
     */
    limit?: number
  }

  /**
   * Inventaris updateManyAndReturn
   */
  export type InventarisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaris
     */
    select?: InventarisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventaris
     */
    omit?: InventarisOmit<ExtArgs> | null
    /**
     * The data used to update Inventarises.
     */
    data: XOR<InventarisUpdateManyMutationInput, InventarisUncheckedUpdateManyInput>
    /**
     * Filter which Inventarises to update
     */
    where?: InventarisWhereInput
    /**
     * Limit how many Inventarises to update.
     */
    limit?: number
  }

  /**
   * Inventaris upsert
   */
  export type InventarisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaris
     */
    select?: InventarisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventaris
     */
    omit?: InventarisOmit<ExtArgs> | null
    /**
     * The filter to search for the Inventaris to update in case it exists.
     */
    where: InventarisWhereUniqueInput
    /**
     * In case the Inventaris found by the `where` argument doesn't exist, create a new Inventaris with this data.
     */
    create: XOR<InventarisCreateInput, InventarisUncheckedCreateInput>
    /**
     * In case the Inventaris was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventarisUpdateInput, InventarisUncheckedUpdateInput>
  }

  /**
   * Inventaris delete
   */
  export type InventarisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaris
     */
    select?: InventarisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventaris
     */
    omit?: InventarisOmit<ExtArgs> | null
    /**
     * Filter which Inventaris to delete.
     */
    where: InventarisWhereUniqueInput
  }

  /**
   * Inventaris deleteMany
   */
  export type InventarisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventarises to delete
     */
    where?: InventarisWhereInput
    /**
     * Limit how many Inventarises to delete.
     */
    limit?: number
  }

  /**
   * Inventaris without action
   */
  export type InventarisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaris
     */
    select?: InventarisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventaris
     */
    omit?: InventarisOmit<ExtArgs> | null
  }


  /**
   * Model OrderLink
   */

  export type AggregateOrderLink = {
    _count: OrderLinkCountAggregateOutputType | null
    _avg: OrderLinkAvgAggregateOutputType | null
    _sum: OrderLinkSumAggregateOutputType | null
    _min: OrderLinkMinAggregateOutputType | null
    _max: OrderLinkMaxAggregateOutputType | null
  }

  export type OrderLinkAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    userId: number | null
  }

  export type OrderLinkSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    userId: number | null
  }

  export type OrderLinkMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    userId: number | null
    linkToken: string | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderLinkMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    userId: number | null
    linkToken: string | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderLinkCountAggregateOutputType = {
    id: number
    orderId: number
    userId: number
    linkToken: number
    isActive: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderLinkAvgAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
  }

  export type OrderLinkSumAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
  }

  export type OrderLinkMinAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    linkToken?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderLinkMaxAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    linkToken?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderLinkCountAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    linkToken?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderLink to aggregate.
     */
    where?: OrderLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderLinks to fetch.
     */
    orderBy?: OrderLinkOrderByWithRelationInput | OrderLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderLinks
    **/
    _count?: true | OrderLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderLinkMaxAggregateInputType
  }

  export type GetOrderLinkAggregateType<T extends OrderLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderLink[P]>
      : GetScalarType<T[P], AggregateOrderLink[P]>
  }




  export type OrderLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderLinkWhereInput
    orderBy?: OrderLinkOrderByWithAggregationInput | OrderLinkOrderByWithAggregationInput[]
    by: OrderLinkScalarFieldEnum[] | OrderLinkScalarFieldEnum
    having?: OrderLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderLinkCountAggregateInputType | true
    _avg?: OrderLinkAvgAggregateInputType
    _sum?: OrderLinkSumAggregateInputType
    _min?: OrderLinkMinAggregateInputType
    _max?: OrderLinkMaxAggregateInputType
  }

  export type OrderLinkGroupByOutputType = {
    id: number
    orderId: number
    userId: number
    linkToken: string
    isActive: boolean
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OrderLinkCountAggregateOutputType | null
    _avg: OrderLinkAvgAggregateOutputType | null
    _sum: OrderLinkSumAggregateOutputType | null
    _min: OrderLinkMinAggregateOutputType | null
    _max: OrderLinkMaxAggregateOutputType | null
  }

  type GetOrderLinkGroupByPayload<T extends OrderLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderLinkGroupByOutputType[P]>
            : GetScalarType<T[P], OrderLinkGroupByOutputType[P]>
        }
      >
    >


  export type OrderLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    userId?: boolean
    linkToken?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderLink"]>

  export type OrderLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    userId?: boolean
    linkToken?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderLink"]>

  export type OrderLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    userId?: boolean
    linkToken?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderLink"]>

  export type OrderLinkSelectScalar = {
    id?: boolean
    orderId?: boolean
    userId?: boolean
    linkToken?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "userId" | "linkToken" | "isActive" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["orderLink"]>
  export type OrderLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderLink"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      userId: number
      linkToken: string
      isActive: boolean
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderLink"]>
    composites: {}
  }

  type OrderLinkGetPayload<S extends boolean | null | undefined | OrderLinkDefaultArgs> = $Result.GetResult<Prisma.$OrderLinkPayload, S>

  type OrderLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderLinkCountAggregateInputType | true
    }

  export interface OrderLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderLink'], meta: { name: 'OrderLink' } }
    /**
     * Find zero or one OrderLink that matches the filter.
     * @param {OrderLinkFindUniqueArgs} args - Arguments to find a OrderLink
     * @example
     * // Get one OrderLink
     * const orderLink = await prisma.orderLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderLinkFindUniqueArgs>(args: SelectSubset<T, OrderLinkFindUniqueArgs<ExtArgs>>): Prisma__OrderLinkClient<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderLinkFindUniqueOrThrowArgs} args - Arguments to find a OrderLink
     * @example
     * // Get one OrderLink
     * const orderLink = await prisma.orderLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderLinkClient<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLinkFindFirstArgs} args - Arguments to find a OrderLink
     * @example
     * // Get one OrderLink
     * const orderLink = await prisma.orderLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderLinkFindFirstArgs>(args?: SelectSubset<T, OrderLinkFindFirstArgs<ExtArgs>>): Prisma__OrderLinkClient<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLinkFindFirstOrThrowArgs} args - Arguments to find a OrderLink
     * @example
     * // Get one OrderLink
     * const orderLink = await prisma.orderLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderLinkClient<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderLinks
     * const orderLinks = await prisma.orderLink.findMany()
     * 
     * // Get first 10 OrderLinks
     * const orderLinks = await prisma.orderLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderLinkWithIdOnly = await prisma.orderLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderLinkFindManyArgs>(args?: SelectSubset<T, OrderLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderLink.
     * @param {OrderLinkCreateArgs} args - Arguments to create a OrderLink.
     * @example
     * // Create one OrderLink
     * const OrderLink = await prisma.orderLink.create({
     *   data: {
     *     // ... data to create a OrderLink
     *   }
     * })
     * 
     */
    create<T extends OrderLinkCreateArgs>(args: SelectSubset<T, OrderLinkCreateArgs<ExtArgs>>): Prisma__OrderLinkClient<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderLinks.
     * @param {OrderLinkCreateManyArgs} args - Arguments to create many OrderLinks.
     * @example
     * // Create many OrderLinks
     * const orderLink = await prisma.orderLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderLinkCreateManyArgs>(args?: SelectSubset<T, OrderLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderLinks and returns the data saved in the database.
     * @param {OrderLinkCreateManyAndReturnArgs} args - Arguments to create many OrderLinks.
     * @example
     * // Create many OrderLinks
     * const orderLink = await prisma.orderLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderLinks and only return the `id`
     * const orderLinkWithIdOnly = await prisma.orderLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderLink.
     * @param {OrderLinkDeleteArgs} args - Arguments to delete one OrderLink.
     * @example
     * // Delete one OrderLink
     * const OrderLink = await prisma.orderLink.delete({
     *   where: {
     *     // ... filter to delete one OrderLink
     *   }
     * })
     * 
     */
    delete<T extends OrderLinkDeleteArgs>(args: SelectSubset<T, OrderLinkDeleteArgs<ExtArgs>>): Prisma__OrderLinkClient<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderLink.
     * @param {OrderLinkUpdateArgs} args - Arguments to update one OrderLink.
     * @example
     * // Update one OrderLink
     * const orderLink = await prisma.orderLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderLinkUpdateArgs>(args: SelectSubset<T, OrderLinkUpdateArgs<ExtArgs>>): Prisma__OrderLinkClient<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderLinks.
     * @param {OrderLinkDeleteManyArgs} args - Arguments to filter OrderLinks to delete.
     * @example
     * // Delete a few OrderLinks
     * const { count } = await prisma.orderLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderLinkDeleteManyArgs>(args?: SelectSubset<T, OrderLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderLinks
     * const orderLink = await prisma.orderLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderLinkUpdateManyArgs>(args: SelectSubset<T, OrderLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderLinks and returns the data updated in the database.
     * @param {OrderLinkUpdateManyAndReturnArgs} args - Arguments to update many OrderLinks.
     * @example
     * // Update many OrderLinks
     * const orderLink = await prisma.orderLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderLinks and only return the `id`
     * const orderLinkWithIdOnly = await prisma.orderLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderLink.
     * @param {OrderLinkUpsertArgs} args - Arguments to update or create a OrderLink.
     * @example
     * // Update or create a OrderLink
     * const orderLink = await prisma.orderLink.upsert({
     *   create: {
     *     // ... data to create a OrderLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderLink we want to update
     *   }
     * })
     */
    upsert<T extends OrderLinkUpsertArgs>(args: SelectSubset<T, OrderLinkUpsertArgs<ExtArgs>>): Prisma__OrderLinkClient<$Result.GetResult<Prisma.$OrderLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLinkCountArgs} args - Arguments to filter OrderLinks to count.
     * @example
     * // Count the number of OrderLinks
     * const count = await prisma.orderLink.count({
     *   where: {
     *     // ... the filter for the OrderLinks we want to count
     *   }
     * })
    **/
    count<T extends OrderLinkCountArgs>(
      args?: Subset<T, OrderLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderLinkAggregateArgs>(args: Subset<T, OrderLinkAggregateArgs>): Prisma.PrismaPromise<GetOrderLinkAggregateType<T>>

    /**
     * Group by OrderLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderLinkGroupByArgs['orderBy'] }
        : { orderBy?: OrderLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderLink model
   */
  readonly fields: OrderLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderLink model
   */
  interface OrderLinkFieldRefs {
    readonly id: FieldRef<"OrderLink", 'Int'>
    readonly orderId: FieldRef<"OrderLink", 'Int'>
    readonly userId: FieldRef<"OrderLink", 'Int'>
    readonly linkToken: FieldRef<"OrderLink", 'String'>
    readonly isActive: FieldRef<"OrderLink", 'Boolean'>
    readonly expiresAt: FieldRef<"OrderLink", 'DateTime'>
    readonly createdAt: FieldRef<"OrderLink", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderLink findUnique
   */
  export type OrderLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkInclude<ExtArgs> | null
    /**
     * Filter, which OrderLink to fetch.
     */
    where: OrderLinkWhereUniqueInput
  }

  /**
   * OrderLink findUniqueOrThrow
   */
  export type OrderLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkInclude<ExtArgs> | null
    /**
     * Filter, which OrderLink to fetch.
     */
    where: OrderLinkWhereUniqueInput
  }

  /**
   * OrderLink findFirst
   */
  export type OrderLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkInclude<ExtArgs> | null
    /**
     * Filter, which OrderLink to fetch.
     */
    where?: OrderLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderLinks to fetch.
     */
    orderBy?: OrderLinkOrderByWithRelationInput | OrderLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderLinks.
     */
    cursor?: OrderLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderLinks.
     */
    distinct?: OrderLinkScalarFieldEnum | OrderLinkScalarFieldEnum[]
  }

  /**
   * OrderLink findFirstOrThrow
   */
  export type OrderLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkInclude<ExtArgs> | null
    /**
     * Filter, which OrderLink to fetch.
     */
    where?: OrderLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderLinks to fetch.
     */
    orderBy?: OrderLinkOrderByWithRelationInput | OrderLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderLinks.
     */
    cursor?: OrderLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderLinks.
     */
    distinct?: OrderLinkScalarFieldEnum | OrderLinkScalarFieldEnum[]
  }

  /**
   * OrderLink findMany
   */
  export type OrderLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkInclude<ExtArgs> | null
    /**
     * Filter, which OrderLinks to fetch.
     */
    where?: OrderLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderLinks to fetch.
     */
    orderBy?: OrderLinkOrderByWithRelationInput | OrderLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderLinks.
     */
    cursor?: OrderLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderLinks.
     */
    skip?: number
    distinct?: OrderLinkScalarFieldEnum | OrderLinkScalarFieldEnum[]
  }

  /**
   * OrderLink create
   */
  export type OrderLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderLink.
     */
    data: XOR<OrderLinkCreateInput, OrderLinkUncheckedCreateInput>
  }

  /**
   * OrderLink createMany
   */
  export type OrderLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderLinks.
     */
    data: OrderLinkCreateManyInput | OrderLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderLink createManyAndReturn
   */
  export type OrderLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * The data used to create many OrderLinks.
     */
    data: OrderLinkCreateManyInput | OrderLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderLink update
   */
  export type OrderLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderLink.
     */
    data: XOR<OrderLinkUpdateInput, OrderLinkUncheckedUpdateInput>
    /**
     * Choose, which OrderLink to update.
     */
    where: OrderLinkWhereUniqueInput
  }

  /**
   * OrderLink updateMany
   */
  export type OrderLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderLinks.
     */
    data: XOR<OrderLinkUpdateManyMutationInput, OrderLinkUncheckedUpdateManyInput>
    /**
     * Filter which OrderLinks to update
     */
    where?: OrderLinkWhereInput
    /**
     * Limit how many OrderLinks to update.
     */
    limit?: number
  }

  /**
   * OrderLink updateManyAndReturn
   */
  export type OrderLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * The data used to update OrderLinks.
     */
    data: XOR<OrderLinkUpdateManyMutationInput, OrderLinkUncheckedUpdateManyInput>
    /**
     * Filter which OrderLinks to update
     */
    where?: OrderLinkWhereInput
    /**
     * Limit how many OrderLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderLink upsert
   */
  export type OrderLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderLink to update in case it exists.
     */
    where: OrderLinkWhereUniqueInput
    /**
     * In case the OrderLink found by the `where` argument doesn't exist, create a new OrderLink with this data.
     */
    create: XOR<OrderLinkCreateInput, OrderLinkUncheckedCreateInput>
    /**
     * In case the OrderLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderLinkUpdateInput, OrderLinkUncheckedUpdateInput>
  }

  /**
   * OrderLink delete
   */
  export type OrderLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkInclude<ExtArgs> | null
    /**
     * Filter which OrderLink to delete.
     */
    where: OrderLinkWhereUniqueInput
  }

  /**
   * OrderLink deleteMany
   */
  export type OrderLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderLinks to delete
     */
    where?: OrderLinkWhereInput
    /**
     * Limit how many OrderLinks to delete.
     */
    limit?: number
  }

  /**
   * OrderLink without action
   */
  export type OrderLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderLink
     */
    select?: OrderLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderLink
     */
    omit?: OrderLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderLinkInclude<ExtArgs> | null
  }


  /**
   * Model ProductMaterial
   */

  export type AggregateProductMaterial = {
    _count: ProductMaterialCountAggregateOutputType | null
    _avg: ProductMaterialAvgAggregateOutputType | null
    _sum: ProductMaterialSumAggregateOutputType | null
    _min: ProductMaterialMinAggregateOutputType | null
    _max: ProductMaterialMaxAggregateOutputType | null
  }

  export type ProductMaterialAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    materialId: number | null
    quantity: Decimal | null
  }

  export type ProductMaterialSumAggregateOutputType = {
    id: number | null
    productId: number | null
    materialId: number | null
    quantity: Decimal | null
  }

  export type ProductMaterialMinAggregateOutputType = {
    id: number | null
    productId: number | null
    materialId: number | null
    quantity: Decimal | null
    unit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaterialMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    materialId: number | null
    quantity: Decimal | null
    unit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaterialCountAggregateOutputType = {
    id: number
    productId: number
    materialId: number
    quantity: number
    unit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductMaterialAvgAggregateInputType = {
    id?: true
    productId?: true
    materialId?: true
    quantity?: true
  }

  export type ProductMaterialSumAggregateInputType = {
    id?: true
    productId?: true
    materialId?: true
    quantity?: true
  }

  export type ProductMaterialMinAggregateInputType = {
    id?: true
    productId?: true
    materialId?: true
    quantity?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaterialMaxAggregateInputType = {
    id?: true
    productId?: true
    materialId?: true
    quantity?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaterialCountAggregateInputType = {
    id?: true
    productId?: true
    materialId?: true
    quantity?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductMaterial to aggregate.
     */
    where?: ProductMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductMaterials to fetch.
     */
    orderBy?: ProductMaterialOrderByWithRelationInput | ProductMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductMaterials
    **/
    _count?: true | ProductMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductMaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductMaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaterialMaxAggregateInputType
  }

  export type GetProductMaterialAggregateType<T extends ProductMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateProductMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductMaterial[P]>
      : GetScalarType<T[P], AggregateProductMaterial[P]>
  }




  export type ProductMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductMaterialWhereInput
    orderBy?: ProductMaterialOrderByWithAggregationInput | ProductMaterialOrderByWithAggregationInput[]
    by: ProductMaterialScalarFieldEnum[] | ProductMaterialScalarFieldEnum
    having?: ProductMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductMaterialCountAggregateInputType | true
    _avg?: ProductMaterialAvgAggregateInputType
    _sum?: ProductMaterialSumAggregateInputType
    _min?: ProductMaterialMinAggregateInputType
    _max?: ProductMaterialMaxAggregateInputType
  }

  export type ProductMaterialGroupByOutputType = {
    id: number
    productId: number
    materialId: number
    quantity: Decimal
    unit: string
    createdAt: Date
    updatedAt: Date
    _count: ProductMaterialCountAggregateOutputType | null
    _avg: ProductMaterialAvgAggregateOutputType | null
    _sum: ProductMaterialSumAggregateOutputType | null
    _min: ProductMaterialMinAggregateOutputType | null
    _max: ProductMaterialMaxAggregateOutputType | null
  }

  type GetProductMaterialGroupByPayload<T extends ProductMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], ProductMaterialGroupByOutputType[P]>
        }
      >
    >


  export type ProductMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    materialId?: boolean
    quantity?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productMaterial"]>

  export type ProductMaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    materialId?: boolean
    quantity?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productMaterial"]>

  export type ProductMaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    materialId?: boolean
    quantity?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productMaterial"]>

  export type ProductMaterialSelectScalar = {
    id?: boolean
    productId?: boolean
    materialId?: boolean
    quantity?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductMaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "materialId" | "quantity" | "unit" | "createdAt" | "updatedAt", ExtArgs["result"]["productMaterial"]>
  export type ProductMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type ProductMaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type ProductMaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }

  export type $ProductMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductMaterial"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      material: Prisma.$MaterialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      materialId: number
      quantity: Prisma.Decimal
      unit: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productMaterial"]>
    composites: {}
  }

  type ProductMaterialGetPayload<S extends boolean | null | undefined | ProductMaterialDefaultArgs> = $Result.GetResult<Prisma.$ProductMaterialPayload, S>

  type ProductMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductMaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductMaterialCountAggregateInputType | true
    }

  export interface ProductMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductMaterial'], meta: { name: 'ProductMaterial' } }
    /**
     * Find zero or one ProductMaterial that matches the filter.
     * @param {ProductMaterialFindUniqueArgs} args - Arguments to find a ProductMaterial
     * @example
     * // Get one ProductMaterial
     * const productMaterial = await prisma.productMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductMaterialFindUniqueArgs>(args: SelectSubset<T, ProductMaterialFindUniqueArgs<ExtArgs>>): Prisma__ProductMaterialClient<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductMaterialFindUniqueOrThrowArgs} args - Arguments to find a ProductMaterial
     * @example
     * // Get one ProductMaterial
     * const productMaterial = await prisma.productMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductMaterialClient<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMaterialFindFirstArgs} args - Arguments to find a ProductMaterial
     * @example
     * // Get one ProductMaterial
     * const productMaterial = await prisma.productMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductMaterialFindFirstArgs>(args?: SelectSubset<T, ProductMaterialFindFirstArgs<ExtArgs>>): Prisma__ProductMaterialClient<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMaterialFindFirstOrThrowArgs} args - Arguments to find a ProductMaterial
     * @example
     * // Get one ProductMaterial
     * const productMaterial = await prisma.productMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductMaterialClient<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductMaterials
     * const productMaterials = await prisma.productMaterial.findMany()
     * 
     * // Get first 10 ProductMaterials
     * const productMaterials = await prisma.productMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productMaterialWithIdOnly = await prisma.productMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductMaterialFindManyArgs>(args?: SelectSubset<T, ProductMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductMaterial.
     * @param {ProductMaterialCreateArgs} args - Arguments to create a ProductMaterial.
     * @example
     * // Create one ProductMaterial
     * const ProductMaterial = await prisma.productMaterial.create({
     *   data: {
     *     // ... data to create a ProductMaterial
     *   }
     * })
     * 
     */
    create<T extends ProductMaterialCreateArgs>(args: SelectSubset<T, ProductMaterialCreateArgs<ExtArgs>>): Prisma__ProductMaterialClient<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductMaterials.
     * @param {ProductMaterialCreateManyArgs} args - Arguments to create many ProductMaterials.
     * @example
     * // Create many ProductMaterials
     * const productMaterial = await prisma.productMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductMaterialCreateManyArgs>(args?: SelectSubset<T, ProductMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductMaterials and returns the data saved in the database.
     * @param {ProductMaterialCreateManyAndReturnArgs} args - Arguments to create many ProductMaterials.
     * @example
     * // Create many ProductMaterials
     * const productMaterial = await prisma.productMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductMaterials and only return the `id`
     * const productMaterialWithIdOnly = await prisma.productMaterial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductMaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductMaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductMaterial.
     * @param {ProductMaterialDeleteArgs} args - Arguments to delete one ProductMaterial.
     * @example
     * // Delete one ProductMaterial
     * const ProductMaterial = await prisma.productMaterial.delete({
     *   where: {
     *     // ... filter to delete one ProductMaterial
     *   }
     * })
     * 
     */
    delete<T extends ProductMaterialDeleteArgs>(args: SelectSubset<T, ProductMaterialDeleteArgs<ExtArgs>>): Prisma__ProductMaterialClient<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductMaterial.
     * @param {ProductMaterialUpdateArgs} args - Arguments to update one ProductMaterial.
     * @example
     * // Update one ProductMaterial
     * const productMaterial = await prisma.productMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductMaterialUpdateArgs>(args: SelectSubset<T, ProductMaterialUpdateArgs<ExtArgs>>): Prisma__ProductMaterialClient<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductMaterials.
     * @param {ProductMaterialDeleteManyArgs} args - Arguments to filter ProductMaterials to delete.
     * @example
     * // Delete a few ProductMaterials
     * const { count } = await prisma.productMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductMaterialDeleteManyArgs>(args?: SelectSubset<T, ProductMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductMaterials
     * const productMaterial = await prisma.productMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductMaterialUpdateManyArgs>(args: SelectSubset<T, ProductMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductMaterials and returns the data updated in the database.
     * @param {ProductMaterialUpdateManyAndReturnArgs} args - Arguments to update many ProductMaterials.
     * @example
     * // Update many ProductMaterials
     * const productMaterial = await prisma.productMaterial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductMaterials and only return the `id`
     * const productMaterialWithIdOnly = await prisma.productMaterial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductMaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductMaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductMaterial.
     * @param {ProductMaterialUpsertArgs} args - Arguments to update or create a ProductMaterial.
     * @example
     * // Update or create a ProductMaterial
     * const productMaterial = await prisma.productMaterial.upsert({
     *   create: {
     *     // ... data to create a ProductMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductMaterial we want to update
     *   }
     * })
     */
    upsert<T extends ProductMaterialUpsertArgs>(args: SelectSubset<T, ProductMaterialUpsertArgs<ExtArgs>>): Prisma__ProductMaterialClient<$Result.GetResult<Prisma.$ProductMaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMaterialCountArgs} args - Arguments to filter ProductMaterials to count.
     * @example
     * // Count the number of ProductMaterials
     * const count = await prisma.productMaterial.count({
     *   where: {
     *     // ... the filter for the ProductMaterials we want to count
     *   }
     * })
    **/
    count<T extends ProductMaterialCountArgs>(
      args?: Subset<T, ProductMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductMaterialAggregateArgs>(args: Subset<T, ProductMaterialAggregateArgs>): Prisma.PrismaPromise<GetProductMaterialAggregateType<T>>

    /**
     * Group by ProductMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductMaterialGroupByArgs['orderBy'] }
        : { orderBy?: ProductMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductMaterial model
   */
  readonly fields: ProductMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductMaterial model
   */
  interface ProductMaterialFieldRefs {
    readonly id: FieldRef<"ProductMaterial", 'Int'>
    readonly productId: FieldRef<"ProductMaterial", 'Int'>
    readonly materialId: FieldRef<"ProductMaterial", 'Int'>
    readonly quantity: FieldRef<"ProductMaterial", 'Decimal'>
    readonly unit: FieldRef<"ProductMaterial", 'String'>
    readonly createdAt: FieldRef<"ProductMaterial", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductMaterial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductMaterial findUnique
   */
  export type ProductMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialInclude<ExtArgs> | null
    /**
     * Filter, which ProductMaterial to fetch.
     */
    where: ProductMaterialWhereUniqueInput
  }

  /**
   * ProductMaterial findUniqueOrThrow
   */
  export type ProductMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialInclude<ExtArgs> | null
    /**
     * Filter, which ProductMaterial to fetch.
     */
    where: ProductMaterialWhereUniqueInput
  }

  /**
   * ProductMaterial findFirst
   */
  export type ProductMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialInclude<ExtArgs> | null
    /**
     * Filter, which ProductMaterial to fetch.
     */
    where?: ProductMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductMaterials to fetch.
     */
    orderBy?: ProductMaterialOrderByWithRelationInput | ProductMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductMaterials.
     */
    cursor?: ProductMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductMaterials.
     */
    distinct?: ProductMaterialScalarFieldEnum | ProductMaterialScalarFieldEnum[]
  }

  /**
   * ProductMaterial findFirstOrThrow
   */
  export type ProductMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialInclude<ExtArgs> | null
    /**
     * Filter, which ProductMaterial to fetch.
     */
    where?: ProductMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductMaterials to fetch.
     */
    orderBy?: ProductMaterialOrderByWithRelationInput | ProductMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductMaterials.
     */
    cursor?: ProductMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductMaterials.
     */
    distinct?: ProductMaterialScalarFieldEnum | ProductMaterialScalarFieldEnum[]
  }

  /**
   * ProductMaterial findMany
   */
  export type ProductMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialInclude<ExtArgs> | null
    /**
     * Filter, which ProductMaterials to fetch.
     */
    where?: ProductMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductMaterials to fetch.
     */
    orderBy?: ProductMaterialOrderByWithRelationInput | ProductMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductMaterials.
     */
    cursor?: ProductMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductMaterials.
     */
    skip?: number
    distinct?: ProductMaterialScalarFieldEnum | ProductMaterialScalarFieldEnum[]
  }

  /**
   * ProductMaterial create
   */
  export type ProductMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductMaterial.
     */
    data: XOR<ProductMaterialCreateInput, ProductMaterialUncheckedCreateInput>
  }

  /**
   * ProductMaterial createMany
   */
  export type ProductMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductMaterials.
     */
    data: ProductMaterialCreateManyInput | ProductMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductMaterial createManyAndReturn
   */
  export type ProductMaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * The data used to create many ProductMaterials.
     */
    data: ProductMaterialCreateManyInput | ProductMaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductMaterial update
   */
  export type ProductMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductMaterial.
     */
    data: XOR<ProductMaterialUpdateInput, ProductMaterialUncheckedUpdateInput>
    /**
     * Choose, which ProductMaterial to update.
     */
    where: ProductMaterialWhereUniqueInput
  }

  /**
   * ProductMaterial updateMany
   */
  export type ProductMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductMaterials.
     */
    data: XOR<ProductMaterialUpdateManyMutationInput, ProductMaterialUncheckedUpdateManyInput>
    /**
     * Filter which ProductMaterials to update
     */
    where?: ProductMaterialWhereInput
    /**
     * Limit how many ProductMaterials to update.
     */
    limit?: number
  }

  /**
   * ProductMaterial updateManyAndReturn
   */
  export type ProductMaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * The data used to update ProductMaterials.
     */
    data: XOR<ProductMaterialUpdateManyMutationInput, ProductMaterialUncheckedUpdateManyInput>
    /**
     * Filter which ProductMaterials to update
     */
    where?: ProductMaterialWhereInput
    /**
     * Limit how many ProductMaterials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductMaterial upsert
   */
  export type ProductMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductMaterial to update in case it exists.
     */
    where: ProductMaterialWhereUniqueInput
    /**
     * In case the ProductMaterial found by the `where` argument doesn't exist, create a new ProductMaterial with this data.
     */
    create: XOR<ProductMaterialCreateInput, ProductMaterialUncheckedCreateInput>
    /**
     * In case the ProductMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductMaterialUpdateInput, ProductMaterialUncheckedUpdateInput>
  }

  /**
   * ProductMaterial delete
   */
  export type ProductMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialInclude<ExtArgs> | null
    /**
     * Filter which ProductMaterial to delete.
     */
    where: ProductMaterialWhereUniqueInput
  }

  /**
   * ProductMaterial deleteMany
   */
  export type ProductMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductMaterials to delete
     */
    where?: ProductMaterialWhereInput
    /**
     * Limit how many ProductMaterials to delete.
     */
    limit?: number
  }

  /**
   * ProductMaterial without action
   */
  export type ProductMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMaterial
     */
    select?: ProductMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMaterial
     */
    omit?: ProductMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMaterialInclude<ExtArgs> | null
  }


  /**
   * Model Shipment
   */

  export type AggregateShipment = {
    _count: ShipmentCountAggregateOutputType | null
    _avg: ShipmentAvgAggregateOutputType | null
    _sum: ShipmentSumAggregateOutputType | null
    _min: ShipmentMinAggregateOutputType | null
    _max: ShipmentMaxAggregateOutputType | null
  }

  export type ShipmentAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type ShipmentSumAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type ShipmentMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    trackingNumber: string | null
    carrier: string | null
    shippedDate: Date | null
    deliveredDate: Date | null
    status: $Enums.ShipmentStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShipmentMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    trackingNumber: string | null
    carrier: string | null
    shippedDate: Date | null
    deliveredDate: Date | null
    status: $Enums.ShipmentStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShipmentCountAggregateOutputType = {
    id: number
    orderId: number
    trackingNumber: number
    carrier: number
    shippedDate: number
    deliveredDate: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShipmentAvgAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type ShipmentSumAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type ShipmentMinAggregateInputType = {
    id?: true
    orderId?: true
    trackingNumber?: true
    carrier?: true
    shippedDate?: true
    deliveredDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShipmentMaxAggregateInputType = {
    id?: true
    orderId?: true
    trackingNumber?: true
    carrier?: true
    shippedDate?: true
    deliveredDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShipmentCountAggregateInputType = {
    id?: true
    orderId?: true
    trackingNumber?: true
    carrier?: true
    shippedDate?: true
    deliveredDate?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipment to aggregate.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shipments
    **/
    _count?: true | ShipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShipmentMaxAggregateInputType
  }

  export type GetShipmentAggregateType<T extends ShipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateShipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipment[P]>
      : GetScalarType<T[P], AggregateShipment[P]>
  }




  export type ShipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithAggregationInput | ShipmentOrderByWithAggregationInput[]
    by: ShipmentScalarFieldEnum[] | ShipmentScalarFieldEnum
    having?: ShipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShipmentCountAggregateInputType | true
    _avg?: ShipmentAvgAggregateInputType
    _sum?: ShipmentSumAggregateInputType
    _min?: ShipmentMinAggregateInputType
    _max?: ShipmentMaxAggregateInputType
  }

  export type ShipmentGroupByOutputType = {
    id: number
    orderId: number
    trackingNumber: string | null
    carrier: string | null
    shippedDate: Date | null
    deliveredDate: Date | null
    status: $Enums.ShipmentStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShipmentCountAggregateOutputType | null
    _avg: ShipmentAvgAggregateOutputType | null
    _sum: ShipmentSumAggregateOutputType | null
    _min: ShipmentMinAggregateOutputType | null
    _max: ShipmentMaxAggregateOutputType | null
  }

  type GetShipmentGroupByPayload<T extends ShipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShipmentGroupByOutputType[P]>
            : GetScalarType<T[P], ShipmentGroupByOutputType[P]>
        }
      >
    >


  export type ShipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    shippedDate?: boolean
    deliveredDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    shippedDate?: boolean
    deliveredDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    shippedDate?: boolean
    deliveredDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectScalar = {
    id?: boolean
    orderId?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    shippedDate?: boolean
    deliveredDate?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "trackingNumber" | "carrier" | "shippedDate" | "deliveredDate" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["shipment"]>
  export type ShipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type ShipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type ShipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $ShipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shipment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      trackingNumber: string | null
      carrier: string | null
      shippedDate: Date | null
      deliveredDate: Date | null
      status: $Enums.ShipmentStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shipment"]>
    composites: {}
  }

  type ShipmentGetPayload<S extends boolean | null | undefined | ShipmentDefaultArgs> = $Result.GetResult<Prisma.$ShipmentPayload, S>

  type ShipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShipmentCountAggregateInputType | true
    }

  export interface ShipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shipment'], meta: { name: 'Shipment' } }
    /**
     * Find zero or one Shipment that matches the filter.
     * @param {ShipmentFindUniqueArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShipmentFindUniqueArgs>(args: SelectSubset<T, ShipmentFindUniqueArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShipmentFindUniqueOrThrowArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ShipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindFirstArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShipmentFindFirstArgs>(args?: SelectSubset<T, ShipmentFindFirstArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindFirstOrThrowArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ShipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shipments
     * const shipments = await prisma.shipment.findMany()
     * 
     * // Get first 10 Shipments
     * const shipments = await prisma.shipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shipmentWithIdOnly = await prisma.shipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShipmentFindManyArgs>(args?: SelectSubset<T, ShipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shipment.
     * @param {ShipmentCreateArgs} args - Arguments to create a Shipment.
     * @example
     * // Create one Shipment
     * const Shipment = await prisma.shipment.create({
     *   data: {
     *     // ... data to create a Shipment
     *   }
     * })
     * 
     */
    create<T extends ShipmentCreateArgs>(args: SelectSubset<T, ShipmentCreateArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shipments.
     * @param {ShipmentCreateManyArgs} args - Arguments to create many Shipments.
     * @example
     * // Create many Shipments
     * const shipment = await prisma.shipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShipmentCreateManyArgs>(args?: SelectSubset<T, ShipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shipments and returns the data saved in the database.
     * @param {ShipmentCreateManyAndReturnArgs} args - Arguments to create many Shipments.
     * @example
     * // Create many Shipments
     * const shipment = await prisma.shipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shipments and only return the `id`
     * const shipmentWithIdOnly = await prisma.shipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ShipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shipment.
     * @param {ShipmentDeleteArgs} args - Arguments to delete one Shipment.
     * @example
     * // Delete one Shipment
     * const Shipment = await prisma.shipment.delete({
     *   where: {
     *     // ... filter to delete one Shipment
     *   }
     * })
     * 
     */
    delete<T extends ShipmentDeleteArgs>(args: SelectSubset<T, ShipmentDeleteArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shipment.
     * @param {ShipmentUpdateArgs} args - Arguments to update one Shipment.
     * @example
     * // Update one Shipment
     * const shipment = await prisma.shipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShipmentUpdateArgs>(args: SelectSubset<T, ShipmentUpdateArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shipments.
     * @param {ShipmentDeleteManyArgs} args - Arguments to filter Shipments to delete.
     * @example
     * // Delete a few Shipments
     * const { count } = await prisma.shipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShipmentDeleteManyArgs>(args?: SelectSubset<T, ShipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shipments
     * const shipment = await prisma.shipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShipmentUpdateManyArgs>(args: SelectSubset<T, ShipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shipments and returns the data updated in the database.
     * @param {ShipmentUpdateManyAndReturnArgs} args - Arguments to update many Shipments.
     * @example
     * // Update many Shipments
     * const shipment = await prisma.shipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shipments and only return the `id`
     * const shipmentWithIdOnly = await prisma.shipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ShipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shipment.
     * @param {ShipmentUpsertArgs} args - Arguments to update or create a Shipment.
     * @example
     * // Update or create a Shipment
     * const shipment = await prisma.shipment.upsert({
     *   create: {
     *     // ... data to create a Shipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shipment we want to update
     *   }
     * })
     */
    upsert<T extends ShipmentUpsertArgs>(args: SelectSubset<T, ShipmentUpsertArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentCountArgs} args - Arguments to filter Shipments to count.
     * @example
     * // Count the number of Shipments
     * const count = await prisma.shipment.count({
     *   where: {
     *     // ... the filter for the Shipments we want to count
     *   }
     * })
    **/
    count<T extends ShipmentCountArgs>(
      args?: Subset<T, ShipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShipmentAggregateArgs>(args: Subset<T, ShipmentAggregateArgs>): Prisma.PrismaPromise<GetShipmentAggregateType<T>>

    /**
     * Group by Shipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShipmentGroupByArgs['orderBy'] }
        : { orderBy?: ShipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shipment model
   */
  readonly fields: ShipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shipment model
   */
  interface ShipmentFieldRefs {
    readonly id: FieldRef<"Shipment", 'Int'>
    readonly orderId: FieldRef<"Shipment", 'Int'>
    readonly trackingNumber: FieldRef<"Shipment", 'String'>
    readonly carrier: FieldRef<"Shipment", 'String'>
    readonly shippedDate: FieldRef<"Shipment", 'DateTime'>
    readonly deliveredDate: FieldRef<"Shipment", 'DateTime'>
    readonly status: FieldRef<"Shipment", 'ShipmentStatus'>
    readonly notes: FieldRef<"Shipment", 'String'>
    readonly createdAt: FieldRef<"Shipment", 'DateTime'>
    readonly updatedAt: FieldRef<"Shipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shipment findUnique
   */
  export type ShipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment findUniqueOrThrow
   */
  export type ShipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment findFirst
   */
  export type ShipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shipments.
     */
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment findFirstOrThrow
   */
  export type ShipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shipments.
     */
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment findMany
   */
  export type ShipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipments to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment create
   */
  export type ShipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Shipment.
     */
    data: XOR<ShipmentCreateInput, ShipmentUncheckedCreateInput>
  }

  /**
   * Shipment createMany
   */
  export type ShipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shipments.
     */
    data: ShipmentCreateManyInput | ShipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shipment createManyAndReturn
   */
  export type ShipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * The data used to create many Shipments.
     */
    data: ShipmentCreateManyInput | ShipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shipment update
   */
  export type ShipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Shipment.
     */
    data: XOR<ShipmentUpdateInput, ShipmentUncheckedUpdateInput>
    /**
     * Choose, which Shipment to update.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment updateMany
   */
  export type ShipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shipments.
     */
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyInput>
    /**
     * Filter which Shipments to update
     */
    where?: ShipmentWhereInput
    /**
     * Limit how many Shipments to update.
     */
    limit?: number
  }

  /**
   * Shipment updateManyAndReturn
   */
  export type ShipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * The data used to update Shipments.
     */
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyInput>
    /**
     * Filter which Shipments to update
     */
    where?: ShipmentWhereInput
    /**
     * Limit how many Shipments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shipment upsert
   */
  export type ShipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Shipment to update in case it exists.
     */
    where: ShipmentWhereUniqueInput
    /**
     * In case the Shipment found by the `where` argument doesn't exist, create a new Shipment with this data.
     */
    create: XOR<ShipmentCreateInput, ShipmentUncheckedCreateInput>
    /**
     * In case the Shipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShipmentUpdateInput, ShipmentUncheckedUpdateInput>
  }

  /**
   * Shipment delete
   */
  export type ShipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter which Shipment to delete.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment deleteMany
   */
  export type ShipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipments to delete
     */
    where?: ShipmentWhereInput
    /**
     * Limit how many Shipments to delete.
     */
    limit?: number
  }

  /**
   * Shipment without action
   */
  export type ShipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
  }


  /**
   * Model RecurringPlan
   */

  export type AggregateRecurringPlan = {
    _count: RecurringPlanCountAggregateOutputType | null
    _avg: RecurringPlanAvgAggregateOutputType | null
    _sum: RecurringPlanSumAggregateOutputType | null
    _min: RecurringPlanMinAggregateOutputType | null
    _max: RecurringPlanMaxAggregateOutputType | null
  }

  export type RecurringPlanAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
  }

  export type RecurringPlanSumAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
  }

  export type RecurringPlanMinAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    frequency: string | null
    isActive: boolean | null
    nextDue: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringPlanMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    frequency: string | null
    isActive: boolean | null
    nextDue: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringPlanCountAggregateOutputType = {
    id: number
    productId: number
    quantity: number
    frequency: number
    isActive: number
    nextDue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecurringPlanAvgAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
  }

  export type RecurringPlanSumAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
  }

  export type RecurringPlanMinAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    frequency?: true
    isActive?: true
    nextDue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringPlanMaxAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    frequency?: true
    isActive?: true
    nextDue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringPlanCountAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    frequency?: true
    isActive?: true
    nextDue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecurringPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringPlan to aggregate.
     */
    where?: RecurringPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringPlans to fetch.
     */
    orderBy?: RecurringPlanOrderByWithRelationInput | RecurringPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringPlans
    **/
    _count?: true | RecurringPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringPlanMaxAggregateInputType
  }

  export type GetRecurringPlanAggregateType<T extends RecurringPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringPlan[P]>
      : GetScalarType<T[P], AggregateRecurringPlan[P]>
  }




  export type RecurringPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringPlanWhereInput
    orderBy?: RecurringPlanOrderByWithAggregationInput | RecurringPlanOrderByWithAggregationInput[]
    by: RecurringPlanScalarFieldEnum[] | RecurringPlanScalarFieldEnum
    having?: RecurringPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringPlanCountAggregateInputType | true
    _avg?: RecurringPlanAvgAggregateInputType
    _sum?: RecurringPlanSumAggregateInputType
    _min?: RecurringPlanMinAggregateInputType
    _max?: RecurringPlanMaxAggregateInputType
  }

  export type RecurringPlanGroupByOutputType = {
    id: number
    productId: number
    quantity: number
    frequency: string
    isActive: boolean
    nextDue: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RecurringPlanCountAggregateOutputType | null
    _avg: RecurringPlanAvgAggregateOutputType | null
    _sum: RecurringPlanSumAggregateOutputType | null
    _min: RecurringPlanMinAggregateOutputType | null
    _max: RecurringPlanMaxAggregateOutputType | null
  }

  type GetRecurringPlanGroupByPayload<T extends RecurringPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringPlanGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringPlanGroupByOutputType[P]>
        }
      >
    >


  export type RecurringPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    frequency?: boolean
    isActive?: boolean
    nextDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringPlan"]>

  export type RecurringPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    frequency?: boolean
    isActive?: boolean
    nextDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringPlan"]>

  export type RecurringPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    frequency?: boolean
    isActive?: boolean
    nextDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringPlan"]>

  export type RecurringPlanSelectScalar = {
    id?: boolean
    productId?: boolean
    quantity?: boolean
    frequency?: boolean
    isActive?: boolean
    nextDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecurringPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "quantity" | "frequency" | "isActive" | "nextDue" | "createdAt" | "updatedAt", ExtArgs["result"]["recurringPlan"]>
  export type RecurringPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type RecurringPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type RecurringPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $RecurringPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringPlan"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      quantity: number
      frequency: string
      isActive: boolean
      nextDue: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recurringPlan"]>
    composites: {}
  }

  type RecurringPlanGetPayload<S extends boolean | null | undefined | RecurringPlanDefaultArgs> = $Result.GetResult<Prisma.$RecurringPlanPayload, S>

  type RecurringPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecurringPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurringPlanCountAggregateInputType | true
    }

  export interface RecurringPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringPlan'], meta: { name: 'RecurringPlan' } }
    /**
     * Find zero or one RecurringPlan that matches the filter.
     * @param {RecurringPlanFindUniqueArgs} args - Arguments to find a RecurringPlan
     * @example
     * // Get one RecurringPlan
     * const recurringPlan = await prisma.recurringPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringPlanFindUniqueArgs>(args: SelectSubset<T, RecurringPlanFindUniqueArgs<ExtArgs>>): Prisma__RecurringPlanClient<$Result.GetResult<Prisma.$RecurringPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecurringPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecurringPlanFindUniqueOrThrowArgs} args - Arguments to find a RecurringPlan
     * @example
     * // Get one RecurringPlan
     * const recurringPlan = await prisma.recurringPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringPlanClient<$Result.GetResult<Prisma.$RecurringPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPlanFindFirstArgs} args - Arguments to find a RecurringPlan
     * @example
     * // Get one RecurringPlan
     * const recurringPlan = await prisma.recurringPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringPlanFindFirstArgs>(args?: SelectSubset<T, RecurringPlanFindFirstArgs<ExtArgs>>): Prisma__RecurringPlanClient<$Result.GetResult<Prisma.$RecurringPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPlanFindFirstOrThrowArgs} args - Arguments to find a RecurringPlan
     * @example
     * // Get one RecurringPlan
     * const recurringPlan = await prisma.recurringPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringPlanClient<$Result.GetResult<Prisma.$RecurringPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringPlans
     * const recurringPlans = await prisma.recurringPlan.findMany()
     * 
     * // Get first 10 RecurringPlans
     * const recurringPlans = await prisma.recurringPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringPlanWithIdOnly = await prisma.recurringPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringPlanFindManyArgs>(args?: SelectSubset<T, RecurringPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecurringPlan.
     * @param {RecurringPlanCreateArgs} args - Arguments to create a RecurringPlan.
     * @example
     * // Create one RecurringPlan
     * const RecurringPlan = await prisma.recurringPlan.create({
     *   data: {
     *     // ... data to create a RecurringPlan
     *   }
     * })
     * 
     */
    create<T extends RecurringPlanCreateArgs>(args: SelectSubset<T, RecurringPlanCreateArgs<ExtArgs>>): Prisma__RecurringPlanClient<$Result.GetResult<Prisma.$RecurringPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecurringPlans.
     * @param {RecurringPlanCreateManyArgs} args - Arguments to create many RecurringPlans.
     * @example
     * // Create many RecurringPlans
     * const recurringPlan = await prisma.recurringPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringPlanCreateManyArgs>(args?: SelectSubset<T, RecurringPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurringPlans and returns the data saved in the database.
     * @param {RecurringPlanCreateManyAndReturnArgs} args - Arguments to create many RecurringPlans.
     * @example
     * // Create many RecurringPlans
     * const recurringPlan = await prisma.recurringPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurringPlans and only return the `id`
     * const recurringPlanWithIdOnly = await prisma.recurringPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurringPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurringPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecurringPlan.
     * @param {RecurringPlanDeleteArgs} args - Arguments to delete one RecurringPlan.
     * @example
     * // Delete one RecurringPlan
     * const RecurringPlan = await prisma.recurringPlan.delete({
     *   where: {
     *     // ... filter to delete one RecurringPlan
     *   }
     * })
     * 
     */
    delete<T extends RecurringPlanDeleteArgs>(args: SelectSubset<T, RecurringPlanDeleteArgs<ExtArgs>>): Prisma__RecurringPlanClient<$Result.GetResult<Prisma.$RecurringPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecurringPlan.
     * @param {RecurringPlanUpdateArgs} args - Arguments to update one RecurringPlan.
     * @example
     * // Update one RecurringPlan
     * const recurringPlan = await prisma.recurringPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringPlanUpdateArgs>(args: SelectSubset<T, RecurringPlanUpdateArgs<ExtArgs>>): Prisma__RecurringPlanClient<$Result.GetResult<Prisma.$RecurringPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecurringPlans.
     * @param {RecurringPlanDeleteManyArgs} args - Arguments to filter RecurringPlans to delete.
     * @example
     * // Delete a few RecurringPlans
     * const { count } = await prisma.recurringPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringPlanDeleteManyArgs>(args?: SelectSubset<T, RecurringPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringPlans
     * const recurringPlan = await prisma.recurringPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringPlanUpdateManyArgs>(args: SelectSubset<T, RecurringPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringPlans and returns the data updated in the database.
     * @param {RecurringPlanUpdateManyAndReturnArgs} args - Arguments to update many RecurringPlans.
     * @example
     * // Update many RecurringPlans
     * const recurringPlan = await prisma.recurringPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecurringPlans and only return the `id`
     * const recurringPlanWithIdOnly = await prisma.recurringPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecurringPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, RecurringPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecurringPlan.
     * @param {RecurringPlanUpsertArgs} args - Arguments to update or create a RecurringPlan.
     * @example
     * // Update or create a RecurringPlan
     * const recurringPlan = await prisma.recurringPlan.upsert({
     *   create: {
     *     // ... data to create a RecurringPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringPlan we want to update
     *   }
     * })
     */
    upsert<T extends RecurringPlanUpsertArgs>(args: SelectSubset<T, RecurringPlanUpsertArgs<ExtArgs>>): Prisma__RecurringPlanClient<$Result.GetResult<Prisma.$RecurringPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecurringPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPlanCountArgs} args - Arguments to filter RecurringPlans to count.
     * @example
     * // Count the number of RecurringPlans
     * const count = await prisma.recurringPlan.count({
     *   where: {
     *     // ... the filter for the RecurringPlans we want to count
     *   }
     * })
    **/
    count<T extends RecurringPlanCountArgs>(
      args?: Subset<T, RecurringPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringPlanAggregateArgs>(args: Subset<T, RecurringPlanAggregateArgs>): Prisma.PrismaPromise<GetRecurringPlanAggregateType<T>>

    /**
     * Group by RecurringPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringPlanGroupByArgs['orderBy'] }
        : { orderBy?: RecurringPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringPlan model
   */
  readonly fields: RecurringPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringPlan model
   */
  interface RecurringPlanFieldRefs {
    readonly id: FieldRef<"RecurringPlan", 'Int'>
    readonly productId: FieldRef<"RecurringPlan", 'Int'>
    readonly quantity: FieldRef<"RecurringPlan", 'Int'>
    readonly frequency: FieldRef<"RecurringPlan", 'String'>
    readonly isActive: FieldRef<"RecurringPlan", 'Boolean'>
    readonly nextDue: FieldRef<"RecurringPlan", 'DateTime'>
    readonly createdAt: FieldRef<"RecurringPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"RecurringPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecurringPlan findUnique
   */
  export type RecurringPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanInclude<ExtArgs> | null
    /**
     * Filter, which RecurringPlan to fetch.
     */
    where: RecurringPlanWhereUniqueInput
  }

  /**
   * RecurringPlan findUniqueOrThrow
   */
  export type RecurringPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanInclude<ExtArgs> | null
    /**
     * Filter, which RecurringPlan to fetch.
     */
    where: RecurringPlanWhereUniqueInput
  }

  /**
   * RecurringPlan findFirst
   */
  export type RecurringPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanInclude<ExtArgs> | null
    /**
     * Filter, which RecurringPlan to fetch.
     */
    where?: RecurringPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringPlans to fetch.
     */
    orderBy?: RecurringPlanOrderByWithRelationInput | RecurringPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringPlans.
     */
    cursor?: RecurringPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringPlans.
     */
    distinct?: RecurringPlanScalarFieldEnum | RecurringPlanScalarFieldEnum[]
  }

  /**
   * RecurringPlan findFirstOrThrow
   */
  export type RecurringPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanInclude<ExtArgs> | null
    /**
     * Filter, which RecurringPlan to fetch.
     */
    where?: RecurringPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringPlans to fetch.
     */
    orderBy?: RecurringPlanOrderByWithRelationInput | RecurringPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringPlans.
     */
    cursor?: RecurringPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringPlans.
     */
    distinct?: RecurringPlanScalarFieldEnum | RecurringPlanScalarFieldEnum[]
  }

  /**
   * RecurringPlan findMany
   */
  export type RecurringPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanInclude<ExtArgs> | null
    /**
     * Filter, which RecurringPlans to fetch.
     */
    where?: RecurringPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringPlans to fetch.
     */
    orderBy?: RecurringPlanOrderByWithRelationInput | RecurringPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringPlans.
     */
    cursor?: RecurringPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringPlans.
     */
    skip?: number
    distinct?: RecurringPlanScalarFieldEnum | RecurringPlanScalarFieldEnum[]
  }

  /**
   * RecurringPlan create
   */
  export type RecurringPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringPlan.
     */
    data: XOR<RecurringPlanCreateInput, RecurringPlanUncheckedCreateInput>
  }

  /**
   * RecurringPlan createMany
   */
  export type RecurringPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringPlans.
     */
    data: RecurringPlanCreateManyInput | RecurringPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurringPlan createManyAndReturn
   */
  export type RecurringPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * The data used to create many RecurringPlans.
     */
    data: RecurringPlanCreateManyInput | RecurringPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringPlan update
   */
  export type RecurringPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringPlan.
     */
    data: XOR<RecurringPlanUpdateInput, RecurringPlanUncheckedUpdateInput>
    /**
     * Choose, which RecurringPlan to update.
     */
    where: RecurringPlanWhereUniqueInput
  }

  /**
   * RecurringPlan updateMany
   */
  export type RecurringPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringPlans.
     */
    data: XOR<RecurringPlanUpdateManyMutationInput, RecurringPlanUncheckedUpdateManyInput>
    /**
     * Filter which RecurringPlans to update
     */
    where?: RecurringPlanWhereInput
    /**
     * Limit how many RecurringPlans to update.
     */
    limit?: number
  }

  /**
   * RecurringPlan updateManyAndReturn
   */
  export type RecurringPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * The data used to update RecurringPlans.
     */
    data: XOR<RecurringPlanUpdateManyMutationInput, RecurringPlanUncheckedUpdateManyInput>
    /**
     * Filter which RecurringPlans to update
     */
    where?: RecurringPlanWhereInput
    /**
     * Limit how many RecurringPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringPlan upsert
   */
  export type RecurringPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringPlan to update in case it exists.
     */
    where: RecurringPlanWhereUniqueInput
    /**
     * In case the RecurringPlan found by the `where` argument doesn't exist, create a new RecurringPlan with this data.
     */
    create: XOR<RecurringPlanCreateInput, RecurringPlanUncheckedCreateInput>
    /**
     * In case the RecurringPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringPlanUpdateInput, RecurringPlanUncheckedUpdateInput>
  }

  /**
   * RecurringPlan delete
   */
  export type RecurringPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanInclude<ExtArgs> | null
    /**
     * Filter which RecurringPlan to delete.
     */
    where: RecurringPlanWhereUniqueInput
  }

  /**
   * RecurringPlan deleteMany
   */
  export type RecurringPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringPlans to delete
     */
    where?: RecurringPlanWhereInput
    /**
     * Limit how many RecurringPlans to delete.
     */
    limit?: number
  }

  /**
   * RecurringPlan without action
   */
  export type RecurringPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringPlan
     */
    select?: RecurringPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringPlan
     */
    omit?: RecurringPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringPlanInclude<ExtArgs> | null
  }


  /**
   * Model StatusChange
   */

  export type AggregateStatusChange = {
    _count: StatusChangeCountAggregateOutputType | null
    _avg: StatusChangeAvgAggregateOutputType | null
    _sum: StatusChangeSumAggregateOutputType | null
    _min: StatusChangeMinAggregateOutputType | null
    _max: StatusChangeMaxAggregateOutputType | null
  }

  export type StatusChangeAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    changedBy: number | null
  }

  export type StatusChangeSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    changedBy: number | null
  }

  export type StatusChangeMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    changedBy: number | null
    fromStatus: $Enums.OrderStatus | null
    toStatus: $Enums.OrderStatus | null
    reason: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatusChangeMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    changedBy: number | null
    fromStatus: $Enums.OrderStatus | null
    toStatus: $Enums.OrderStatus | null
    reason: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatusChangeCountAggregateOutputType = {
    id: number
    orderId: number
    changedBy: number
    fromStatus: number
    toStatus: number
    reason: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatusChangeAvgAggregateInputType = {
    id?: true
    orderId?: true
    changedBy?: true
  }

  export type StatusChangeSumAggregateInputType = {
    id?: true
    orderId?: true
    changedBy?: true
  }

  export type StatusChangeMinAggregateInputType = {
    id?: true
    orderId?: true
    changedBy?: true
    fromStatus?: true
    toStatus?: true
    reason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatusChangeMaxAggregateInputType = {
    id?: true
    orderId?: true
    changedBy?: true
    fromStatus?: true
    toStatus?: true
    reason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatusChangeCountAggregateInputType = {
    id?: true
    orderId?: true
    changedBy?: true
    fromStatus?: true
    toStatus?: true
    reason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatusChangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusChange to aggregate.
     */
    where?: StatusChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusChanges to fetch.
     */
    orderBy?: StatusChangeOrderByWithRelationInput | StatusChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatusChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatusChanges
    **/
    _count?: true | StatusChangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusChangeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusChangeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusChangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusChangeMaxAggregateInputType
  }

  export type GetStatusChangeAggregateType<T extends StatusChangeAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusChange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusChange[P]>
      : GetScalarType<T[P], AggregateStatusChange[P]>
  }




  export type StatusChangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusChangeWhereInput
    orderBy?: StatusChangeOrderByWithAggregationInput | StatusChangeOrderByWithAggregationInput[]
    by: StatusChangeScalarFieldEnum[] | StatusChangeScalarFieldEnum
    having?: StatusChangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusChangeCountAggregateInputType | true
    _avg?: StatusChangeAvgAggregateInputType
    _sum?: StatusChangeSumAggregateInputType
    _min?: StatusChangeMinAggregateInputType
    _max?: StatusChangeMaxAggregateInputType
  }

  export type StatusChangeGroupByOutputType = {
    id: number
    orderId: number
    changedBy: number
    fromStatus: $Enums.OrderStatus
    toStatus: $Enums.OrderStatus
    reason: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: StatusChangeCountAggregateOutputType | null
    _avg: StatusChangeAvgAggregateOutputType | null
    _sum: StatusChangeSumAggregateOutputType | null
    _min: StatusChangeMinAggregateOutputType | null
    _max: StatusChangeMaxAggregateOutputType | null
  }

  type GetStatusChangeGroupByPayload<T extends StatusChangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusChangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusChangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusChangeGroupByOutputType[P]>
            : GetScalarType<T[P], StatusChangeGroupByOutputType[P]>
        }
      >
    >


  export type StatusChangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    changedBy?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusChange"]>

  export type StatusChangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    changedBy?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusChange"]>

  export type StatusChangeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    changedBy?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusChange"]>

  export type StatusChangeSelectScalar = {
    id?: boolean
    orderId?: boolean
    changedBy?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StatusChangeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "changedBy" | "fromStatus" | "toStatus" | "reason" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["statusChange"]>
  export type StatusChangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StatusChangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StatusChangeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StatusChangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatusChange"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      changedBy: number
      fromStatus: $Enums.OrderStatus
      toStatus: $Enums.OrderStatus
      reason: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["statusChange"]>
    composites: {}
  }

  type StatusChangeGetPayload<S extends boolean | null | undefined | StatusChangeDefaultArgs> = $Result.GetResult<Prisma.$StatusChangePayload, S>

  type StatusChangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StatusChangeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatusChangeCountAggregateInputType | true
    }

  export interface StatusChangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatusChange'], meta: { name: 'StatusChange' } }
    /**
     * Find zero or one StatusChange that matches the filter.
     * @param {StatusChangeFindUniqueArgs} args - Arguments to find a StatusChange
     * @example
     * // Get one StatusChange
     * const statusChange = await prisma.statusChange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatusChangeFindUniqueArgs>(args: SelectSubset<T, StatusChangeFindUniqueArgs<ExtArgs>>): Prisma__StatusChangeClient<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StatusChange that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StatusChangeFindUniqueOrThrowArgs} args - Arguments to find a StatusChange
     * @example
     * // Get one StatusChange
     * const statusChange = await prisma.statusChange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatusChangeFindUniqueOrThrowArgs>(args: SelectSubset<T, StatusChangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatusChangeClient<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StatusChange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeFindFirstArgs} args - Arguments to find a StatusChange
     * @example
     * // Get one StatusChange
     * const statusChange = await prisma.statusChange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatusChangeFindFirstArgs>(args?: SelectSubset<T, StatusChangeFindFirstArgs<ExtArgs>>): Prisma__StatusChangeClient<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StatusChange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeFindFirstOrThrowArgs} args - Arguments to find a StatusChange
     * @example
     * // Get one StatusChange
     * const statusChange = await prisma.statusChange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatusChangeFindFirstOrThrowArgs>(args?: SelectSubset<T, StatusChangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatusChangeClient<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StatusChanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusChanges
     * const statusChanges = await prisma.statusChange.findMany()
     * 
     * // Get first 10 StatusChanges
     * const statusChanges = await prisma.statusChange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusChangeWithIdOnly = await prisma.statusChange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatusChangeFindManyArgs>(args?: SelectSubset<T, StatusChangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StatusChange.
     * @param {StatusChangeCreateArgs} args - Arguments to create a StatusChange.
     * @example
     * // Create one StatusChange
     * const StatusChange = await prisma.statusChange.create({
     *   data: {
     *     // ... data to create a StatusChange
     *   }
     * })
     * 
     */
    create<T extends StatusChangeCreateArgs>(args: SelectSubset<T, StatusChangeCreateArgs<ExtArgs>>): Prisma__StatusChangeClient<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StatusChanges.
     * @param {StatusChangeCreateManyArgs} args - Arguments to create many StatusChanges.
     * @example
     * // Create many StatusChanges
     * const statusChange = await prisma.statusChange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatusChangeCreateManyArgs>(args?: SelectSubset<T, StatusChangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StatusChanges and returns the data saved in the database.
     * @param {StatusChangeCreateManyAndReturnArgs} args - Arguments to create many StatusChanges.
     * @example
     * // Create many StatusChanges
     * const statusChange = await prisma.statusChange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StatusChanges and only return the `id`
     * const statusChangeWithIdOnly = await prisma.statusChange.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatusChangeCreateManyAndReturnArgs>(args?: SelectSubset<T, StatusChangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StatusChange.
     * @param {StatusChangeDeleteArgs} args - Arguments to delete one StatusChange.
     * @example
     * // Delete one StatusChange
     * const StatusChange = await prisma.statusChange.delete({
     *   where: {
     *     // ... filter to delete one StatusChange
     *   }
     * })
     * 
     */
    delete<T extends StatusChangeDeleteArgs>(args: SelectSubset<T, StatusChangeDeleteArgs<ExtArgs>>): Prisma__StatusChangeClient<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StatusChange.
     * @param {StatusChangeUpdateArgs} args - Arguments to update one StatusChange.
     * @example
     * // Update one StatusChange
     * const statusChange = await prisma.statusChange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatusChangeUpdateArgs>(args: SelectSubset<T, StatusChangeUpdateArgs<ExtArgs>>): Prisma__StatusChangeClient<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StatusChanges.
     * @param {StatusChangeDeleteManyArgs} args - Arguments to filter StatusChanges to delete.
     * @example
     * // Delete a few StatusChanges
     * const { count } = await prisma.statusChange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatusChangeDeleteManyArgs>(args?: SelectSubset<T, StatusChangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusChanges
     * const statusChange = await prisma.statusChange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatusChangeUpdateManyArgs>(args: SelectSubset<T, StatusChangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusChanges and returns the data updated in the database.
     * @param {StatusChangeUpdateManyAndReturnArgs} args - Arguments to update many StatusChanges.
     * @example
     * // Update many StatusChanges
     * const statusChange = await prisma.statusChange.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StatusChanges and only return the `id`
     * const statusChangeWithIdOnly = await prisma.statusChange.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StatusChangeUpdateManyAndReturnArgs>(args: SelectSubset<T, StatusChangeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StatusChange.
     * @param {StatusChangeUpsertArgs} args - Arguments to update or create a StatusChange.
     * @example
     * // Update or create a StatusChange
     * const statusChange = await prisma.statusChange.upsert({
     *   create: {
     *     // ... data to create a StatusChange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusChange we want to update
     *   }
     * })
     */
    upsert<T extends StatusChangeUpsertArgs>(args: SelectSubset<T, StatusChangeUpsertArgs<ExtArgs>>): Prisma__StatusChangeClient<$Result.GetResult<Prisma.$StatusChangePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StatusChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeCountArgs} args - Arguments to filter StatusChanges to count.
     * @example
     * // Count the number of StatusChanges
     * const count = await prisma.statusChange.count({
     *   where: {
     *     // ... the filter for the StatusChanges we want to count
     *   }
     * })
    **/
    count<T extends StatusChangeCountArgs>(
      args?: Subset<T, StatusChangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusChangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusChangeAggregateArgs>(args: Subset<T, StatusChangeAggregateArgs>): Prisma.PrismaPromise<GetStatusChangeAggregateType<T>>

    /**
     * Group by StatusChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusChangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusChangeGroupByArgs['orderBy'] }
        : { orderBy?: StatusChangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusChangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusChangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatusChange model
   */
  readonly fields: StatusChangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusChange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatusChangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatusChange model
   */
  interface StatusChangeFieldRefs {
    readonly id: FieldRef<"StatusChange", 'Int'>
    readonly orderId: FieldRef<"StatusChange", 'Int'>
    readonly changedBy: FieldRef<"StatusChange", 'Int'>
    readonly fromStatus: FieldRef<"StatusChange", 'OrderStatus'>
    readonly toStatus: FieldRef<"StatusChange", 'OrderStatus'>
    readonly reason: FieldRef<"StatusChange", 'String'>
    readonly notes: FieldRef<"StatusChange", 'String'>
    readonly createdAt: FieldRef<"StatusChange", 'DateTime'>
    readonly updatedAt: FieldRef<"StatusChange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatusChange findUnique
   */
  export type StatusChangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null
    /**
     * Filter, which StatusChange to fetch.
     */
    where: StatusChangeWhereUniqueInput
  }

  /**
   * StatusChange findUniqueOrThrow
   */
  export type StatusChangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null
    /**
     * Filter, which StatusChange to fetch.
     */
    where: StatusChangeWhereUniqueInput
  }

  /**
   * StatusChange findFirst
   */
  export type StatusChangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null
    /**
     * Filter, which StatusChange to fetch.
     */
    where?: StatusChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusChanges to fetch.
     */
    orderBy?: StatusChangeOrderByWithRelationInput | StatusChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusChanges.
     */
    cursor?: StatusChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusChanges.
     */
    distinct?: StatusChangeScalarFieldEnum | StatusChangeScalarFieldEnum[]
  }

  /**
   * StatusChange findFirstOrThrow
   */
  export type StatusChangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null
    /**
     * Filter, which StatusChange to fetch.
     */
    where?: StatusChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusChanges to fetch.
     */
    orderBy?: StatusChangeOrderByWithRelationInput | StatusChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusChanges.
     */
    cursor?: StatusChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusChanges.
     */
    distinct?: StatusChangeScalarFieldEnum | StatusChangeScalarFieldEnum[]
  }

  /**
   * StatusChange findMany
   */
  export type StatusChangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null
    /**
     * Filter, which StatusChanges to fetch.
     */
    where?: StatusChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusChanges to fetch.
     */
    orderBy?: StatusChangeOrderByWithRelationInput | StatusChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatusChanges.
     */
    cursor?: StatusChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusChanges.
     */
    skip?: number
    distinct?: StatusChangeScalarFieldEnum | StatusChangeScalarFieldEnum[]
  }

  /**
   * StatusChange create
   */
  export type StatusChangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null
    /**
     * The data needed to create a StatusChange.
     */
    data: XOR<StatusChangeCreateInput, StatusChangeUncheckedCreateInput>
  }

  /**
   * StatusChange createMany
   */
  export type StatusChangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatusChanges.
     */
    data: StatusChangeCreateManyInput | StatusChangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatusChange createManyAndReturn
   */
  export type StatusChangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * The data used to create many StatusChanges.
     */
    data: StatusChangeCreateManyInput | StatusChangeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatusChange update
   */
  export type StatusChangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null
    /**
     * The data needed to update a StatusChange.
     */
    data: XOR<StatusChangeUpdateInput, StatusChangeUncheckedUpdateInput>
    /**
     * Choose, which StatusChange to update.
     */
    where: StatusChangeWhereUniqueInput
  }

  /**
   * StatusChange updateMany
   */
  export type StatusChangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatusChanges.
     */
    data: XOR<StatusChangeUpdateManyMutationInput, StatusChangeUncheckedUpdateManyInput>
    /**
     * Filter which StatusChanges to update
     */
    where?: StatusChangeWhereInput
    /**
     * Limit how many StatusChanges to update.
     */
    limit?: number
  }

  /**
   * StatusChange updateManyAndReturn
   */
  export type StatusChangeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * The data used to update StatusChanges.
     */
    data: XOR<StatusChangeUpdateManyMutationInput, StatusChangeUncheckedUpdateManyInput>
    /**
     * Filter which StatusChanges to update
     */
    where?: StatusChangeWhereInput
    /**
     * Limit how many StatusChanges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatusChange upsert
   */
  export type StatusChangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null
    /**
     * The filter to search for the StatusChange to update in case it exists.
     */
    where: StatusChangeWhereUniqueInput
    /**
     * In case the StatusChange found by the `where` argument doesn't exist, create a new StatusChange with this data.
     */
    create: XOR<StatusChangeCreateInput, StatusChangeUncheckedCreateInput>
    /**
     * In case the StatusChange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusChangeUpdateInput, StatusChangeUncheckedUpdateInput>
  }

  /**
   * StatusChange delete
   */
  export type StatusChangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null
    /**
     * Filter which StatusChange to delete.
     */
    where: StatusChangeWhereUniqueInput
  }

  /**
   * StatusChange deleteMany
   */
  export type StatusChangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusChanges to delete
     */
    where?: StatusChangeWhereInput
    /**
     * Limit how many StatusChanges to delete.
     */
    limit?: number
  }

  /**
   * StatusChange without action
   */
  export type StatusChangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null
  }


  /**
   * Model ProductColour
   */

  export type AggregateProductColour = {
    _count: ProductColourCountAggregateOutputType | null
    _avg: ProductColourAvgAggregateOutputType | null
    _sum: ProductColourSumAggregateOutputType | null
    _min: ProductColourMinAggregateOutputType | null
    _max: ProductColourMaxAggregateOutputType | null
  }

  export type ProductColourAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductColourSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductColourMinAggregateOutputType = {
    id: number | null
    productId: number | null
    colorName: string | null
    colorCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductColourMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    colorName: string | null
    colorCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductColourCountAggregateOutputType = {
    id: number
    productId: number
    colorName: number
    colorCode: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductColourAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductColourSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductColourMinAggregateInputType = {
    id?: true
    productId?: true
    colorName?: true
    colorCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductColourMaxAggregateInputType = {
    id?: true
    productId?: true
    colorName?: true
    colorCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductColourCountAggregateInputType = {
    id?: true
    productId?: true
    colorName?: true
    colorCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductColourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductColour to aggregate.
     */
    where?: ProductColourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColours to fetch.
     */
    orderBy?: ProductColourOrderByWithRelationInput | ProductColourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductColourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductColours
    **/
    _count?: true | ProductColourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductColourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductColourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductColourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductColourMaxAggregateInputType
  }

  export type GetProductColourAggregateType<T extends ProductColourAggregateArgs> = {
        [P in keyof T & keyof AggregateProductColour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductColour[P]>
      : GetScalarType<T[P], AggregateProductColour[P]>
  }




  export type ProductColourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductColourWhereInput
    orderBy?: ProductColourOrderByWithAggregationInput | ProductColourOrderByWithAggregationInput[]
    by: ProductColourScalarFieldEnum[] | ProductColourScalarFieldEnum
    having?: ProductColourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductColourCountAggregateInputType | true
    _avg?: ProductColourAvgAggregateInputType
    _sum?: ProductColourSumAggregateInputType
    _min?: ProductColourMinAggregateInputType
    _max?: ProductColourMaxAggregateInputType
  }

  export type ProductColourGroupByOutputType = {
    id: number
    productId: number
    colorName: string
    colorCode: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductColourCountAggregateOutputType | null
    _avg: ProductColourAvgAggregateOutputType | null
    _sum: ProductColourSumAggregateOutputType | null
    _min: ProductColourMinAggregateOutputType | null
    _max: ProductColourMaxAggregateOutputType | null
  }

  type GetProductColourGroupByPayload<T extends ProductColourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductColourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductColourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductColourGroupByOutputType[P]>
            : GetScalarType<T[P], ProductColourGroupByOutputType[P]>
        }
      >
    >


  export type ProductColourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    colorName?: boolean
    colorCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productColour"]>

  export type ProductColourSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    colorName?: boolean
    colorCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productColour"]>

  export type ProductColourSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    colorName?: boolean
    colorCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productColour"]>

  export type ProductColourSelectScalar = {
    id?: boolean
    productId?: boolean
    colorName?: boolean
    colorCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductColourOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "colorName" | "colorCode" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["productColour"]>
  export type ProductColourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductColourIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductColourIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductColourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductColour"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      colorName: string
      colorCode: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productColour"]>
    composites: {}
  }

  type ProductColourGetPayload<S extends boolean | null | undefined | ProductColourDefaultArgs> = $Result.GetResult<Prisma.$ProductColourPayload, S>

  type ProductColourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductColourFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductColourCountAggregateInputType | true
    }

  export interface ProductColourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductColour'], meta: { name: 'ProductColour' } }
    /**
     * Find zero or one ProductColour that matches the filter.
     * @param {ProductColourFindUniqueArgs} args - Arguments to find a ProductColour
     * @example
     * // Get one ProductColour
     * const productColour = await prisma.productColour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductColourFindUniqueArgs>(args: SelectSubset<T, ProductColourFindUniqueArgs<ExtArgs>>): Prisma__ProductColourClient<$Result.GetResult<Prisma.$ProductColourPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductColour that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductColourFindUniqueOrThrowArgs} args - Arguments to find a ProductColour
     * @example
     * // Get one ProductColour
     * const productColour = await prisma.productColour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductColourFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductColourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductColourClient<$Result.GetResult<Prisma.$ProductColourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductColour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColourFindFirstArgs} args - Arguments to find a ProductColour
     * @example
     * // Get one ProductColour
     * const productColour = await prisma.productColour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductColourFindFirstArgs>(args?: SelectSubset<T, ProductColourFindFirstArgs<ExtArgs>>): Prisma__ProductColourClient<$Result.GetResult<Prisma.$ProductColourPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductColour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColourFindFirstOrThrowArgs} args - Arguments to find a ProductColour
     * @example
     * // Get one ProductColour
     * const productColour = await prisma.productColour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductColourFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductColourFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductColourClient<$Result.GetResult<Prisma.$ProductColourPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductColours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductColours
     * const productColours = await prisma.productColour.findMany()
     * 
     * // Get first 10 ProductColours
     * const productColours = await prisma.productColour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productColourWithIdOnly = await prisma.productColour.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductColourFindManyArgs>(args?: SelectSubset<T, ProductColourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductColourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductColour.
     * @param {ProductColourCreateArgs} args - Arguments to create a ProductColour.
     * @example
     * // Create one ProductColour
     * const ProductColour = await prisma.productColour.create({
     *   data: {
     *     // ... data to create a ProductColour
     *   }
     * })
     * 
     */
    create<T extends ProductColourCreateArgs>(args: SelectSubset<T, ProductColourCreateArgs<ExtArgs>>): Prisma__ProductColourClient<$Result.GetResult<Prisma.$ProductColourPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductColours.
     * @param {ProductColourCreateManyArgs} args - Arguments to create many ProductColours.
     * @example
     * // Create many ProductColours
     * const productColour = await prisma.productColour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductColourCreateManyArgs>(args?: SelectSubset<T, ProductColourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductColours and returns the data saved in the database.
     * @param {ProductColourCreateManyAndReturnArgs} args - Arguments to create many ProductColours.
     * @example
     * // Create many ProductColours
     * const productColour = await prisma.productColour.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductColours and only return the `id`
     * const productColourWithIdOnly = await prisma.productColour.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductColourCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductColourCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductColourPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductColour.
     * @param {ProductColourDeleteArgs} args - Arguments to delete one ProductColour.
     * @example
     * // Delete one ProductColour
     * const ProductColour = await prisma.productColour.delete({
     *   where: {
     *     // ... filter to delete one ProductColour
     *   }
     * })
     * 
     */
    delete<T extends ProductColourDeleteArgs>(args: SelectSubset<T, ProductColourDeleteArgs<ExtArgs>>): Prisma__ProductColourClient<$Result.GetResult<Prisma.$ProductColourPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductColour.
     * @param {ProductColourUpdateArgs} args - Arguments to update one ProductColour.
     * @example
     * // Update one ProductColour
     * const productColour = await prisma.productColour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductColourUpdateArgs>(args: SelectSubset<T, ProductColourUpdateArgs<ExtArgs>>): Prisma__ProductColourClient<$Result.GetResult<Prisma.$ProductColourPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductColours.
     * @param {ProductColourDeleteManyArgs} args - Arguments to filter ProductColours to delete.
     * @example
     * // Delete a few ProductColours
     * const { count } = await prisma.productColour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductColourDeleteManyArgs>(args?: SelectSubset<T, ProductColourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductColours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductColours
     * const productColour = await prisma.productColour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductColourUpdateManyArgs>(args: SelectSubset<T, ProductColourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductColours and returns the data updated in the database.
     * @param {ProductColourUpdateManyAndReturnArgs} args - Arguments to update many ProductColours.
     * @example
     * // Update many ProductColours
     * const productColour = await prisma.productColour.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductColours and only return the `id`
     * const productColourWithIdOnly = await prisma.productColour.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductColourUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductColourUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductColourPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductColour.
     * @param {ProductColourUpsertArgs} args - Arguments to update or create a ProductColour.
     * @example
     * // Update or create a ProductColour
     * const productColour = await prisma.productColour.upsert({
     *   create: {
     *     // ... data to create a ProductColour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductColour we want to update
     *   }
     * })
     */
    upsert<T extends ProductColourUpsertArgs>(args: SelectSubset<T, ProductColourUpsertArgs<ExtArgs>>): Prisma__ProductColourClient<$Result.GetResult<Prisma.$ProductColourPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductColours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColourCountArgs} args - Arguments to filter ProductColours to count.
     * @example
     * // Count the number of ProductColours
     * const count = await prisma.productColour.count({
     *   where: {
     *     // ... the filter for the ProductColours we want to count
     *   }
     * })
    **/
    count<T extends ProductColourCountArgs>(
      args?: Subset<T, ProductColourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductColourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductColour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductColourAggregateArgs>(args: Subset<T, ProductColourAggregateArgs>): Prisma.PrismaPromise<GetProductColourAggregateType<T>>

    /**
     * Group by ProductColour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductColourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductColourGroupByArgs['orderBy'] }
        : { orderBy?: ProductColourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductColourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductColourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductColour model
   */
  readonly fields: ProductColourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductColour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductColourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductColour model
   */
  interface ProductColourFieldRefs {
    readonly id: FieldRef<"ProductColour", 'Int'>
    readonly productId: FieldRef<"ProductColour", 'Int'>
    readonly colorName: FieldRef<"ProductColour", 'String'>
    readonly colorCode: FieldRef<"ProductColour", 'String'>
    readonly isActive: FieldRef<"ProductColour", 'Boolean'>
    readonly createdAt: FieldRef<"ProductColour", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductColour", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductColour findUnique
   */
  export type ProductColourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourInclude<ExtArgs> | null
    /**
     * Filter, which ProductColour to fetch.
     */
    where: ProductColourWhereUniqueInput
  }

  /**
   * ProductColour findUniqueOrThrow
   */
  export type ProductColourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourInclude<ExtArgs> | null
    /**
     * Filter, which ProductColour to fetch.
     */
    where: ProductColourWhereUniqueInput
  }

  /**
   * ProductColour findFirst
   */
  export type ProductColourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourInclude<ExtArgs> | null
    /**
     * Filter, which ProductColour to fetch.
     */
    where?: ProductColourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColours to fetch.
     */
    orderBy?: ProductColourOrderByWithRelationInput | ProductColourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductColours.
     */
    cursor?: ProductColourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductColours.
     */
    distinct?: ProductColourScalarFieldEnum | ProductColourScalarFieldEnum[]
  }

  /**
   * ProductColour findFirstOrThrow
   */
  export type ProductColourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourInclude<ExtArgs> | null
    /**
     * Filter, which ProductColour to fetch.
     */
    where?: ProductColourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColours to fetch.
     */
    orderBy?: ProductColourOrderByWithRelationInput | ProductColourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductColours.
     */
    cursor?: ProductColourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductColours.
     */
    distinct?: ProductColourScalarFieldEnum | ProductColourScalarFieldEnum[]
  }

  /**
   * ProductColour findMany
   */
  export type ProductColourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourInclude<ExtArgs> | null
    /**
     * Filter, which ProductColours to fetch.
     */
    where?: ProductColourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColours to fetch.
     */
    orderBy?: ProductColourOrderByWithRelationInput | ProductColourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductColours.
     */
    cursor?: ProductColourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColours.
     */
    skip?: number
    distinct?: ProductColourScalarFieldEnum | ProductColourScalarFieldEnum[]
  }

  /**
   * ProductColour create
   */
  export type ProductColourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductColour.
     */
    data: XOR<ProductColourCreateInput, ProductColourUncheckedCreateInput>
  }

  /**
   * ProductColour createMany
   */
  export type ProductColourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductColours.
     */
    data: ProductColourCreateManyInput | ProductColourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductColour createManyAndReturn
   */
  export type ProductColourCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * The data used to create many ProductColours.
     */
    data: ProductColourCreateManyInput | ProductColourCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductColour update
   */
  export type ProductColourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductColour.
     */
    data: XOR<ProductColourUpdateInput, ProductColourUncheckedUpdateInput>
    /**
     * Choose, which ProductColour to update.
     */
    where: ProductColourWhereUniqueInput
  }

  /**
   * ProductColour updateMany
   */
  export type ProductColourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductColours.
     */
    data: XOR<ProductColourUpdateManyMutationInput, ProductColourUncheckedUpdateManyInput>
    /**
     * Filter which ProductColours to update
     */
    where?: ProductColourWhereInput
    /**
     * Limit how many ProductColours to update.
     */
    limit?: number
  }

  /**
   * ProductColour updateManyAndReturn
   */
  export type ProductColourUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * The data used to update ProductColours.
     */
    data: XOR<ProductColourUpdateManyMutationInput, ProductColourUncheckedUpdateManyInput>
    /**
     * Filter which ProductColours to update
     */
    where?: ProductColourWhereInput
    /**
     * Limit how many ProductColours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductColour upsert
   */
  export type ProductColourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductColour to update in case it exists.
     */
    where: ProductColourWhereUniqueInput
    /**
     * In case the ProductColour found by the `where` argument doesn't exist, create a new ProductColour with this data.
     */
    create: XOR<ProductColourCreateInput, ProductColourUncheckedCreateInput>
    /**
     * In case the ProductColour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductColourUpdateInput, ProductColourUncheckedUpdateInput>
  }

  /**
   * ProductColour delete
   */
  export type ProductColourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourInclude<ExtArgs> | null
    /**
     * Filter which ProductColour to delete.
     */
    where: ProductColourWhereUniqueInput
  }

  /**
   * ProductColour deleteMany
   */
  export type ProductColourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductColours to delete
     */
    where?: ProductColourWhereInput
    /**
     * Limit how many ProductColours to delete.
     */
    limit?: number
  }

  /**
   * ProductColour without action
   */
  export type ProductColourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColour
     */
    select?: ProductColourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColour
     */
    omit?: ProductColourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColourInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariation
   */

  export type AggregateProductVariation = {
    _count: ProductVariationCountAggregateOutputType | null
    _avg: ProductVariationAvgAggregateOutputType | null
    _sum: ProductVariationSumAggregateOutputType | null
    _min: ProductVariationMinAggregateOutputType | null
    _max: ProductVariationMaxAggregateOutputType | null
  }

  export type ProductVariationAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    priceAdjustment: Decimal | null
  }

  export type ProductVariationSumAggregateOutputType = {
    id: number | null
    productId: number | null
    priceAdjustment: Decimal | null
  }

  export type ProductVariationMinAggregateOutputType = {
    id: number | null
    productId: number | null
    variationType: string | null
    variationValue: string | null
    priceAdjustment: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariationMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    variationType: string | null
    variationValue: string | null
    priceAdjustment: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariationCountAggregateOutputType = {
    id: number
    productId: number
    variationType: number
    variationValue: number
    priceAdjustment: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVariationAvgAggregateInputType = {
    id?: true
    productId?: true
    priceAdjustment?: true
  }

  export type ProductVariationSumAggregateInputType = {
    id?: true
    productId?: true
    priceAdjustment?: true
  }

  export type ProductVariationMinAggregateInputType = {
    id?: true
    productId?: true
    variationType?: true
    variationValue?: true
    priceAdjustment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariationMaxAggregateInputType = {
    id?: true
    productId?: true
    variationType?: true
    variationValue?: true
    priceAdjustment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariationCountAggregateInputType = {
    id?: true
    productId?: true
    variationType?: true
    variationValue?: true
    priceAdjustment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVariationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariation to aggregate.
     */
    where?: ProductVariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariations to fetch.
     */
    orderBy?: ProductVariationOrderByWithRelationInput | ProductVariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariations
    **/
    _count?: true | ProductVariationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductVariationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductVariationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariationMaxAggregateInputType
  }

  export type GetProductVariationAggregateType<T extends ProductVariationAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariation[P]>
      : GetScalarType<T[P], AggregateProductVariation[P]>
  }




  export type ProductVariationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariationWhereInput
    orderBy?: ProductVariationOrderByWithAggregationInput | ProductVariationOrderByWithAggregationInput[]
    by: ProductVariationScalarFieldEnum[] | ProductVariationScalarFieldEnum
    having?: ProductVariationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariationCountAggregateInputType | true
    _avg?: ProductVariationAvgAggregateInputType
    _sum?: ProductVariationSumAggregateInputType
    _min?: ProductVariationMinAggregateInputType
    _max?: ProductVariationMaxAggregateInputType
  }

  export type ProductVariationGroupByOutputType = {
    id: number
    productId: number
    variationType: string
    variationValue: string
    priceAdjustment: Decimal | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductVariationCountAggregateOutputType | null
    _avg: ProductVariationAvgAggregateOutputType | null
    _sum: ProductVariationSumAggregateOutputType | null
    _min: ProductVariationMinAggregateOutputType | null
    _max: ProductVariationMaxAggregateOutputType | null
  }

  type GetProductVariationGroupByPayload<T extends ProductVariationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariationGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariationGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    variationType?: boolean
    variationValue?: boolean
    priceAdjustment?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariation"]>

  export type ProductVariationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    variationType?: boolean
    variationValue?: boolean
    priceAdjustment?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariation"]>

  export type ProductVariationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    variationType?: boolean
    variationValue?: boolean
    priceAdjustment?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariation"]>

  export type ProductVariationSelectScalar = {
    id?: boolean
    productId?: boolean
    variationType?: boolean
    variationValue?: boolean
    priceAdjustment?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductVariationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "variationType" | "variationValue" | "priceAdjustment" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["productVariation"]>
  export type ProductVariationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductVariationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductVariationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductVariationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariation"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      variationType: string
      variationValue: string
      priceAdjustment: Prisma.Decimal | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productVariation"]>
    composites: {}
  }

  type ProductVariationGetPayload<S extends boolean | null | undefined | ProductVariationDefaultArgs> = $Result.GetResult<Prisma.$ProductVariationPayload, S>

  type ProductVariationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductVariationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductVariationCountAggregateInputType | true
    }

  export interface ProductVariationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariation'], meta: { name: 'ProductVariation' } }
    /**
     * Find zero or one ProductVariation that matches the filter.
     * @param {ProductVariationFindUniqueArgs} args - Arguments to find a ProductVariation
     * @example
     * // Get one ProductVariation
     * const productVariation = await prisma.productVariation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariationFindUniqueArgs>(args: SelectSubset<T, ProductVariationFindUniqueArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductVariation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductVariationFindUniqueOrThrowArgs} args - Arguments to find a ProductVariation
     * @example
     * // Get one ProductVariation
     * const productVariation = await prisma.productVariation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationFindFirstArgs} args - Arguments to find a ProductVariation
     * @example
     * // Get one ProductVariation
     * const productVariation = await prisma.productVariation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariationFindFirstArgs>(args?: SelectSubset<T, ProductVariationFindFirstArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationFindFirstOrThrowArgs} args - Arguments to find a ProductVariation
     * @example
     * // Get one ProductVariation
     * const productVariation = await prisma.productVariation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductVariations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariations
     * const productVariations = await prisma.productVariation.findMany()
     * 
     * // Get first 10 ProductVariations
     * const productVariations = await prisma.productVariation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariationWithIdOnly = await prisma.productVariation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariationFindManyArgs>(args?: SelectSubset<T, ProductVariationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductVariation.
     * @param {ProductVariationCreateArgs} args - Arguments to create a ProductVariation.
     * @example
     * // Create one ProductVariation
     * const ProductVariation = await prisma.productVariation.create({
     *   data: {
     *     // ... data to create a ProductVariation
     *   }
     * })
     * 
     */
    create<T extends ProductVariationCreateArgs>(args: SelectSubset<T, ProductVariationCreateArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductVariations.
     * @param {ProductVariationCreateManyArgs} args - Arguments to create many ProductVariations.
     * @example
     * // Create many ProductVariations
     * const productVariation = await prisma.productVariation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariationCreateManyArgs>(args?: SelectSubset<T, ProductVariationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductVariations and returns the data saved in the database.
     * @param {ProductVariationCreateManyAndReturnArgs} args - Arguments to create many ProductVariations.
     * @example
     * // Create many ProductVariations
     * const productVariation = await prisma.productVariation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductVariations and only return the `id`
     * const productVariationWithIdOnly = await prisma.productVariation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductVariationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductVariationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductVariation.
     * @param {ProductVariationDeleteArgs} args - Arguments to delete one ProductVariation.
     * @example
     * // Delete one ProductVariation
     * const ProductVariation = await prisma.productVariation.delete({
     *   where: {
     *     // ... filter to delete one ProductVariation
     *   }
     * })
     * 
     */
    delete<T extends ProductVariationDeleteArgs>(args: SelectSubset<T, ProductVariationDeleteArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductVariation.
     * @param {ProductVariationUpdateArgs} args - Arguments to update one ProductVariation.
     * @example
     * // Update one ProductVariation
     * const productVariation = await prisma.productVariation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariationUpdateArgs>(args: SelectSubset<T, ProductVariationUpdateArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductVariations.
     * @param {ProductVariationDeleteManyArgs} args - Arguments to filter ProductVariations to delete.
     * @example
     * // Delete a few ProductVariations
     * const { count } = await prisma.productVariation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariationDeleteManyArgs>(args?: SelectSubset<T, ProductVariationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariations
     * const productVariation = await prisma.productVariation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariationUpdateManyArgs>(args: SelectSubset<T, ProductVariationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariations and returns the data updated in the database.
     * @param {ProductVariationUpdateManyAndReturnArgs} args - Arguments to update many ProductVariations.
     * @example
     * // Update many ProductVariations
     * const productVariation = await prisma.productVariation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductVariations and only return the `id`
     * const productVariationWithIdOnly = await prisma.productVariation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductVariationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductVariationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductVariation.
     * @param {ProductVariationUpsertArgs} args - Arguments to update or create a ProductVariation.
     * @example
     * // Update or create a ProductVariation
     * const productVariation = await prisma.productVariation.upsert({
     *   create: {
     *     // ... data to create a ProductVariation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariation we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariationUpsertArgs>(args: SelectSubset<T, ProductVariationUpsertArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductVariations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationCountArgs} args - Arguments to filter ProductVariations to count.
     * @example
     * // Count the number of ProductVariations
     * const count = await prisma.productVariation.count({
     *   where: {
     *     // ... the filter for the ProductVariations we want to count
     *   }
     * })
    **/
    count<T extends ProductVariationCountArgs>(
      args?: Subset<T, ProductVariationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariationAggregateArgs>(args: Subset<T, ProductVariationAggregateArgs>): Prisma.PrismaPromise<GetProductVariationAggregateType<T>>

    /**
     * Group by ProductVariation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariationGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariation model
   */
  readonly fields: ProductVariationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariation model
   */
  interface ProductVariationFieldRefs {
    readonly id: FieldRef<"ProductVariation", 'Int'>
    readonly productId: FieldRef<"ProductVariation", 'Int'>
    readonly variationType: FieldRef<"ProductVariation", 'String'>
    readonly variationValue: FieldRef<"ProductVariation", 'String'>
    readonly priceAdjustment: FieldRef<"ProductVariation", 'Decimal'>
    readonly isActive: FieldRef<"ProductVariation", 'Boolean'>
    readonly createdAt: FieldRef<"ProductVariation", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariation findUnique
   */
  export type ProductVariationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariation to fetch.
     */
    where: ProductVariationWhereUniqueInput
  }

  /**
   * ProductVariation findUniqueOrThrow
   */
  export type ProductVariationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariation to fetch.
     */
    where: ProductVariationWhereUniqueInput
  }

  /**
   * ProductVariation findFirst
   */
  export type ProductVariationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariation to fetch.
     */
    where?: ProductVariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariations to fetch.
     */
    orderBy?: ProductVariationOrderByWithRelationInput | ProductVariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariations.
     */
    cursor?: ProductVariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariations.
     */
    distinct?: ProductVariationScalarFieldEnum | ProductVariationScalarFieldEnum[]
  }

  /**
   * ProductVariation findFirstOrThrow
   */
  export type ProductVariationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariation to fetch.
     */
    where?: ProductVariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariations to fetch.
     */
    orderBy?: ProductVariationOrderByWithRelationInput | ProductVariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariations.
     */
    cursor?: ProductVariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariations.
     */
    distinct?: ProductVariationScalarFieldEnum | ProductVariationScalarFieldEnum[]
  }

  /**
   * ProductVariation findMany
   */
  export type ProductVariationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariations to fetch.
     */
    where?: ProductVariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariations to fetch.
     */
    orderBy?: ProductVariationOrderByWithRelationInput | ProductVariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariations.
     */
    cursor?: ProductVariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariations.
     */
    skip?: number
    distinct?: ProductVariationScalarFieldEnum | ProductVariationScalarFieldEnum[]
  }

  /**
   * ProductVariation create
   */
  export type ProductVariationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariation.
     */
    data: XOR<ProductVariationCreateInput, ProductVariationUncheckedCreateInput>
  }

  /**
   * ProductVariation createMany
   */
  export type ProductVariationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariations.
     */
    data: ProductVariationCreateManyInput | ProductVariationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVariation createManyAndReturn
   */
  export type ProductVariationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * The data used to create many ProductVariations.
     */
    data: ProductVariationCreateManyInput | ProductVariationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariation update
   */
  export type ProductVariationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariation.
     */
    data: XOR<ProductVariationUpdateInput, ProductVariationUncheckedUpdateInput>
    /**
     * Choose, which ProductVariation to update.
     */
    where: ProductVariationWhereUniqueInput
  }

  /**
   * ProductVariation updateMany
   */
  export type ProductVariationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariations.
     */
    data: XOR<ProductVariationUpdateManyMutationInput, ProductVariationUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariations to update
     */
    where?: ProductVariationWhereInput
    /**
     * Limit how many ProductVariations to update.
     */
    limit?: number
  }

  /**
   * ProductVariation updateManyAndReturn
   */
  export type ProductVariationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * The data used to update ProductVariations.
     */
    data: XOR<ProductVariationUpdateManyMutationInput, ProductVariationUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariations to update
     */
    where?: ProductVariationWhereInput
    /**
     * Limit how many ProductVariations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariation upsert
   */
  export type ProductVariationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariation to update in case it exists.
     */
    where: ProductVariationWhereUniqueInput
    /**
     * In case the ProductVariation found by the `where` argument doesn't exist, create a new ProductVariation with this data.
     */
    create: XOR<ProductVariationCreateInput, ProductVariationUncheckedCreateInput>
    /**
     * In case the ProductVariation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariationUpdateInput, ProductVariationUncheckedUpdateInput>
  }

  /**
   * ProductVariation delete
   */
  export type ProductVariationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * Filter which ProductVariation to delete.
     */
    where: ProductVariationWhereUniqueInput
  }

  /**
   * ProductVariation deleteMany
   */
  export type ProductVariationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariations to delete
     */
    where?: ProductVariationWhereInput
    /**
     * Limit how many ProductVariations to delete.
     */
    limit?: number
  }

  /**
   * ProductVariation without action
   */
  export type ProductVariationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
  }


  /**
   * Model ProductPhoto
   */

  export type AggregateProductPhoto = {
    _count: ProductPhotoCountAggregateOutputType | null
    _avg: ProductPhotoAvgAggregateOutputType | null
    _sum: ProductPhotoSumAggregateOutputType | null
    _min: ProductPhotoMinAggregateOutputType | null
    _max: ProductPhotoMaxAggregateOutputType | null
  }

  export type ProductPhotoAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    sortOrder: number | null
    fileSize: number | null
  }

  export type ProductPhotoSumAggregateOutputType = {
    id: number | null
    productId: number | null
    sortOrder: number | null
    fileSize: number | null
  }

  export type ProductPhotoMinAggregateOutputType = {
    id: number | null
    productId: number | null
    photoPath: string | null
    thumbnailPath: string | null
    description: string | null
    isPrimary: boolean | null
    sortOrder: number | null
    fileSize: number | null
    mimeType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductPhotoMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    photoPath: string | null
    thumbnailPath: string | null
    description: string | null
    isPrimary: boolean | null
    sortOrder: number | null
    fileSize: number | null
    mimeType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductPhotoCountAggregateOutputType = {
    id: number
    productId: number
    photoPath: number
    thumbnailPath: number
    description: number
    isPrimary: number
    sortOrder: number
    fileSize: number
    mimeType: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductPhotoAvgAggregateInputType = {
    id?: true
    productId?: true
    sortOrder?: true
    fileSize?: true
  }

  export type ProductPhotoSumAggregateInputType = {
    id?: true
    productId?: true
    sortOrder?: true
    fileSize?: true
  }

  export type ProductPhotoMinAggregateInputType = {
    id?: true
    productId?: true
    photoPath?: true
    thumbnailPath?: true
    description?: true
    isPrimary?: true
    sortOrder?: true
    fileSize?: true
    mimeType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductPhotoMaxAggregateInputType = {
    id?: true
    productId?: true
    photoPath?: true
    thumbnailPath?: true
    description?: true
    isPrimary?: true
    sortOrder?: true
    fileSize?: true
    mimeType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductPhotoCountAggregateInputType = {
    id?: true
    productId?: true
    photoPath?: true
    thumbnailPath?: true
    description?: true
    isPrimary?: true
    sortOrder?: true
    fileSize?: true
    mimeType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductPhoto to aggregate.
     */
    where?: ProductPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPhotos to fetch.
     */
    orderBy?: ProductPhotoOrderByWithRelationInput | ProductPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductPhotos
    **/
    _count?: true | ProductPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductPhotoMaxAggregateInputType
  }

  export type GetProductPhotoAggregateType<T extends ProductPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateProductPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductPhoto[P]>
      : GetScalarType<T[P], AggregateProductPhoto[P]>
  }




  export type ProductPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductPhotoWhereInput
    orderBy?: ProductPhotoOrderByWithAggregationInput | ProductPhotoOrderByWithAggregationInput[]
    by: ProductPhotoScalarFieldEnum[] | ProductPhotoScalarFieldEnum
    having?: ProductPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductPhotoCountAggregateInputType | true
    _avg?: ProductPhotoAvgAggregateInputType
    _sum?: ProductPhotoSumAggregateInputType
    _min?: ProductPhotoMinAggregateInputType
    _max?: ProductPhotoMaxAggregateInputType
  }

  export type ProductPhotoGroupByOutputType = {
    id: number
    productId: number
    photoPath: string
    thumbnailPath: string | null
    description: string | null
    isPrimary: boolean
    sortOrder: number
    fileSize: number | null
    mimeType: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductPhotoCountAggregateOutputType | null
    _avg: ProductPhotoAvgAggregateOutputType | null
    _sum: ProductPhotoSumAggregateOutputType | null
    _min: ProductPhotoMinAggregateOutputType | null
    _max: ProductPhotoMaxAggregateOutputType | null
  }

  type GetProductPhotoGroupByPayload<T extends ProductPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductPhotoGroupByOutputType[P]>
        }
      >
    >


  export type ProductPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    photoPath?: boolean
    thumbnailPath?: boolean
    description?: boolean
    isPrimary?: boolean
    sortOrder?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPhoto"]>

  export type ProductPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    photoPath?: boolean
    thumbnailPath?: boolean
    description?: boolean
    isPrimary?: boolean
    sortOrder?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPhoto"]>

  export type ProductPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    photoPath?: boolean
    thumbnailPath?: boolean
    description?: boolean
    isPrimary?: boolean
    sortOrder?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPhoto"]>

  export type ProductPhotoSelectScalar = {
    id?: boolean
    productId?: boolean
    photoPath?: boolean
    thumbnailPath?: boolean
    description?: boolean
    isPrimary?: boolean
    sortOrder?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "photoPath" | "thumbnailPath" | "description" | "isPrimary" | "sortOrder" | "fileSize" | "mimeType" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["productPhoto"]>
  export type ProductPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductPhoto"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      photoPath: string
      thumbnailPath: string | null
      description: string | null
      isPrimary: boolean
      sortOrder: number
      fileSize: number | null
      mimeType: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productPhoto"]>
    composites: {}
  }

  type ProductPhotoGetPayload<S extends boolean | null | undefined | ProductPhotoDefaultArgs> = $Result.GetResult<Prisma.$ProductPhotoPayload, S>

  type ProductPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductPhotoCountAggregateInputType | true
    }

  export interface ProductPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductPhoto'], meta: { name: 'ProductPhoto' } }
    /**
     * Find zero or one ProductPhoto that matches the filter.
     * @param {ProductPhotoFindUniqueArgs} args - Arguments to find a ProductPhoto
     * @example
     * // Get one ProductPhoto
     * const productPhoto = await prisma.productPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductPhotoFindUniqueArgs>(args: SelectSubset<T, ProductPhotoFindUniqueArgs<ExtArgs>>): Prisma__ProductPhotoClient<$Result.GetResult<Prisma.$ProductPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductPhotoFindUniqueOrThrowArgs} args - Arguments to find a ProductPhoto
     * @example
     * // Get one ProductPhoto
     * const productPhoto = await prisma.productPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductPhotoClient<$Result.GetResult<Prisma.$ProductPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPhotoFindFirstArgs} args - Arguments to find a ProductPhoto
     * @example
     * // Get one ProductPhoto
     * const productPhoto = await prisma.productPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductPhotoFindFirstArgs>(args?: SelectSubset<T, ProductPhotoFindFirstArgs<ExtArgs>>): Prisma__ProductPhotoClient<$Result.GetResult<Prisma.$ProductPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPhotoFindFirstOrThrowArgs} args - Arguments to find a ProductPhoto
     * @example
     * // Get one ProductPhoto
     * const productPhoto = await prisma.productPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductPhotoClient<$Result.GetResult<Prisma.$ProductPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductPhotos
     * const productPhotos = await prisma.productPhoto.findMany()
     * 
     * // Get first 10 ProductPhotos
     * const productPhotos = await prisma.productPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productPhotoWithIdOnly = await prisma.productPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductPhotoFindManyArgs>(args?: SelectSubset<T, ProductPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductPhoto.
     * @param {ProductPhotoCreateArgs} args - Arguments to create a ProductPhoto.
     * @example
     * // Create one ProductPhoto
     * const ProductPhoto = await prisma.productPhoto.create({
     *   data: {
     *     // ... data to create a ProductPhoto
     *   }
     * })
     * 
     */
    create<T extends ProductPhotoCreateArgs>(args: SelectSubset<T, ProductPhotoCreateArgs<ExtArgs>>): Prisma__ProductPhotoClient<$Result.GetResult<Prisma.$ProductPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductPhotos.
     * @param {ProductPhotoCreateManyArgs} args - Arguments to create many ProductPhotos.
     * @example
     * // Create many ProductPhotos
     * const productPhoto = await prisma.productPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductPhotoCreateManyArgs>(args?: SelectSubset<T, ProductPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductPhotos and returns the data saved in the database.
     * @param {ProductPhotoCreateManyAndReturnArgs} args - Arguments to create many ProductPhotos.
     * @example
     * // Create many ProductPhotos
     * const productPhoto = await prisma.productPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductPhotos and only return the `id`
     * const productPhotoWithIdOnly = await prisma.productPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductPhoto.
     * @param {ProductPhotoDeleteArgs} args - Arguments to delete one ProductPhoto.
     * @example
     * // Delete one ProductPhoto
     * const ProductPhoto = await prisma.productPhoto.delete({
     *   where: {
     *     // ... filter to delete one ProductPhoto
     *   }
     * })
     * 
     */
    delete<T extends ProductPhotoDeleteArgs>(args: SelectSubset<T, ProductPhotoDeleteArgs<ExtArgs>>): Prisma__ProductPhotoClient<$Result.GetResult<Prisma.$ProductPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductPhoto.
     * @param {ProductPhotoUpdateArgs} args - Arguments to update one ProductPhoto.
     * @example
     * // Update one ProductPhoto
     * const productPhoto = await prisma.productPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductPhotoUpdateArgs>(args: SelectSubset<T, ProductPhotoUpdateArgs<ExtArgs>>): Prisma__ProductPhotoClient<$Result.GetResult<Prisma.$ProductPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductPhotos.
     * @param {ProductPhotoDeleteManyArgs} args - Arguments to filter ProductPhotos to delete.
     * @example
     * // Delete a few ProductPhotos
     * const { count } = await prisma.productPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductPhotoDeleteManyArgs>(args?: SelectSubset<T, ProductPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductPhotos
     * const productPhoto = await prisma.productPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductPhotoUpdateManyArgs>(args: SelectSubset<T, ProductPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductPhotos and returns the data updated in the database.
     * @param {ProductPhotoUpdateManyAndReturnArgs} args - Arguments to update many ProductPhotos.
     * @example
     * // Update many ProductPhotos
     * const productPhoto = await prisma.productPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductPhotos and only return the `id`
     * const productPhotoWithIdOnly = await prisma.productPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductPhoto.
     * @param {ProductPhotoUpsertArgs} args - Arguments to update or create a ProductPhoto.
     * @example
     * // Update or create a ProductPhoto
     * const productPhoto = await prisma.productPhoto.upsert({
     *   create: {
     *     // ... data to create a ProductPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductPhoto we want to update
     *   }
     * })
     */
    upsert<T extends ProductPhotoUpsertArgs>(args: SelectSubset<T, ProductPhotoUpsertArgs<ExtArgs>>): Prisma__ProductPhotoClient<$Result.GetResult<Prisma.$ProductPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPhotoCountArgs} args - Arguments to filter ProductPhotos to count.
     * @example
     * // Count the number of ProductPhotos
     * const count = await prisma.productPhoto.count({
     *   where: {
     *     // ... the filter for the ProductPhotos we want to count
     *   }
     * })
    **/
    count<T extends ProductPhotoCountArgs>(
      args?: Subset<T, ProductPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductPhotoAggregateArgs>(args: Subset<T, ProductPhotoAggregateArgs>): Prisma.PrismaPromise<GetProductPhotoAggregateType<T>>

    /**
     * Group by ProductPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductPhotoGroupByArgs['orderBy'] }
        : { orderBy?: ProductPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductPhoto model
   */
  readonly fields: ProductPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductPhoto model
   */
  interface ProductPhotoFieldRefs {
    readonly id: FieldRef<"ProductPhoto", 'Int'>
    readonly productId: FieldRef<"ProductPhoto", 'Int'>
    readonly photoPath: FieldRef<"ProductPhoto", 'String'>
    readonly thumbnailPath: FieldRef<"ProductPhoto", 'String'>
    readonly description: FieldRef<"ProductPhoto", 'String'>
    readonly isPrimary: FieldRef<"ProductPhoto", 'Boolean'>
    readonly sortOrder: FieldRef<"ProductPhoto", 'Int'>
    readonly fileSize: FieldRef<"ProductPhoto", 'Int'>
    readonly mimeType: FieldRef<"ProductPhoto", 'String'>
    readonly isActive: FieldRef<"ProductPhoto", 'Boolean'>
    readonly createdAt: FieldRef<"ProductPhoto", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductPhoto findUnique
   */
  export type ProductPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProductPhoto to fetch.
     */
    where: ProductPhotoWhereUniqueInput
  }

  /**
   * ProductPhoto findUniqueOrThrow
   */
  export type ProductPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProductPhoto to fetch.
     */
    where: ProductPhotoWhereUniqueInput
  }

  /**
   * ProductPhoto findFirst
   */
  export type ProductPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProductPhoto to fetch.
     */
    where?: ProductPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPhotos to fetch.
     */
    orderBy?: ProductPhotoOrderByWithRelationInput | ProductPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPhotos.
     */
    cursor?: ProductPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPhotos.
     */
    distinct?: ProductPhotoScalarFieldEnum | ProductPhotoScalarFieldEnum[]
  }

  /**
   * ProductPhoto findFirstOrThrow
   */
  export type ProductPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProductPhoto to fetch.
     */
    where?: ProductPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPhotos to fetch.
     */
    orderBy?: ProductPhotoOrderByWithRelationInput | ProductPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPhotos.
     */
    cursor?: ProductPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPhotos.
     */
    distinct?: ProductPhotoScalarFieldEnum | ProductPhotoScalarFieldEnum[]
  }

  /**
   * ProductPhoto findMany
   */
  export type ProductPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProductPhotos to fetch.
     */
    where?: ProductPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPhotos to fetch.
     */
    orderBy?: ProductPhotoOrderByWithRelationInput | ProductPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductPhotos.
     */
    cursor?: ProductPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPhotos.
     */
    skip?: number
    distinct?: ProductPhotoScalarFieldEnum | ProductPhotoScalarFieldEnum[]
  }

  /**
   * ProductPhoto create
   */
  export type ProductPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductPhoto.
     */
    data: XOR<ProductPhotoCreateInput, ProductPhotoUncheckedCreateInput>
  }

  /**
   * ProductPhoto createMany
   */
  export type ProductPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductPhotos.
     */
    data: ProductPhotoCreateManyInput | ProductPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductPhoto createManyAndReturn
   */
  export type ProductPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many ProductPhotos.
     */
    data: ProductPhotoCreateManyInput | ProductPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductPhoto update
   */
  export type ProductPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductPhoto.
     */
    data: XOR<ProductPhotoUpdateInput, ProductPhotoUncheckedUpdateInput>
    /**
     * Choose, which ProductPhoto to update.
     */
    where: ProductPhotoWhereUniqueInput
  }

  /**
   * ProductPhoto updateMany
   */
  export type ProductPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductPhotos.
     */
    data: XOR<ProductPhotoUpdateManyMutationInput, ProductPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ProductPhotos to update
     */
    where?: ProductPhotoWhereInput
    /**
     * Limit how many ProductPhotos to update.
     */
    limit?: number
  }

  /**
   * ProductPhoto updateManyAndReturn
   */
  export type ProductPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * The data used to update ProductPhotos.
     */
    data: XOR<ProductPhotoUpdateManyMutationInput, ProductPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ProductPhotos to update
     */
    where?: ProductPhotoWhereInput
    /**
     * Limit how many ProductPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductPhoto upsert
   */
  export type ProductPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductPhoto to update in case it exists.
     */
    where: ProductPhotoWhereUniqueInput
    /**
     * In case the ProductPhoto found by the `where` argument doesn't exist, create a new ProductPhoto with this data.
     */
    create: XOR<ProductPhotoCreateInput, ProductPhotoUncheckedCreateInput>
    /**
     * In case the ProductPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductPhotoUpdateInput, ProductPhotoUncheckedUpdateInput>
  }

  /**
   * ProductPhoto delete
   */
  export type ProductPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoInclude<ExtArgs> | null
    /**
     * Filter which ProductPhoto to delete.
     */
    where: ProductPhotoWhereUniqueInput
  }

  /**
   * ProductPhoto deleteMany
   */
  export type ProductPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductPhotos to delete
     */
    where?: ProductPhotoWhereInput
    /**
     * Limit how many ProductPhotos to delete.
     */
    limit?: number
  }

  /**
   * ProductPhoto without action
   */
  export type ProductPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPhoto
     */
    select?: ProductPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductPhoto
     */
    omit?: ProductPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPhotoInclude<ExtArgs> | null
  }


  /**
   * Model MaterialPurchaseAlert
   */

  export type AggregateMaterialPurchaseAlert = {
    _count: MaterialPurchaseAlertCountAggregateOutputType | null
    _avg: MaterialPurchaseAlertAvgAggregateOutputType | null
    _sum: MaterialPurchaseAlertSumAggregateOutputType | null
    _min: MaterialPurchaseAlertMinAggregateOutputType | null
    _max: MaterialPurchaseAlertMaxAggregateOutputType | null
  }

  export type MaterialPurchaseAlertAvgAggregateOutputType = {
    id: number | null
    materialId: number | null
    orderId: number | null
    requiredQuantity: Decimal | null
    currentStock: Decimal | null
    createdBy: number | null
    resolvedBy: number | null
    estimatedCost: Decimal | null
  }

  export type MaterialPurchaseAlertSumAggregateOutputType = {
    id: number | null
    materialId: number | null
    orderId: number | null
    requiredQuantity: Decimal | null
    currentStock: Decimal | null
    createdBy: number | null
    resolvedBy: number | null
    estimatedCost: Decimal | null
  }

  export type MaterialPurchaseAlertMinAggregateOutputType = {
    id: number | null
    materialId: number | null
    orderId: number | null
    alertType: $Enums.MaterialPurchaseAlertType | null
    requiredQuantity: Decimal | null
    currentStock: Decimal | null
    urgencyLevel: $Enums.UrgencyLevel | null
    message: string | null
    status: $Enums.AlertStatus | null
    createdBy: number | null
    resolvedBy: number | null
    resolvedAt: Date | null
    resolution: string | null
    estimatedCost: Decimal | null
    suggestedSupplier: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialPurchaseAlertMaxAggregateOutputType = {
    id: number | null
    materialId: number | null
    orderId: number | null
    alertType: $Enums.MaterialPurchaseAlertType | null
    requiredQuantity: Decimal | null
    currentStock: Decimal | null
    urgencyLevel: $Enums.UrgencyLevel | null
    message: string | null
    status: $Enums.AlertStatus | null
    createdBy: number | null
    resolvedBy: number | null
    resolvedAt: Date | null
    resolution: string | null
    estimatedCost: Decimal | null
    suggestedSupplier: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialPurchaseAlertCountAggregateOutputType = {
    id: number
    materialId: number
    orderId: number
    alertType: number
    requiredQuantity: number
    currentStock: number
    urgencyLevel: number
    message: number
    status: number
    createdBy: number
    resolvedBy: number
    resolvedAt: number
    resolution: number
    estimatedCost: number
    suggestedSupplier: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterialPurchaseAlertAvgAggregateInputType = {
    id?: true
    materialId?: true
    orderId?: true
    requiredQuantity?: true
    currentStock?: true
    createdBy?: true
    resolvedBy?: true
    estimatedCost?: true
  }

  export type MaterialPurchaseAlertSumAggregateInputType = {
    id?: true
    materialId?: true
    orderId?: true
    requiredQuantity?: true
    currentStock?: true
    createdBy?: true
    resolvedBy?: true
    estimatedCost?: true
  }

  export type MaterialPurchaseAlertMinAggregateInputType = {
    id?: true
    materialId?: true
    orderId?: true
    alertType?: true
    requiredQuantity?: true
    currentStock?: true
    urgencyLevel?: true
    message?: true
    status?: true
    createdBy?: true
    resolvedBy?: true
    resolvedAt?: true
    resolution?: true
    estimatedCost?: true
    suggestedSupplier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialPurchaseAlertMaxAggregateInputType = {
    id?: true
    materialId?: true
    orderId?: true
    alertType?: true
    requiredQuantity?: true
    currentStock?: true
    urgencyLevel?: true
    message?: true
    status?: true
    createdBy?: true
    resolvedBy?: true
    resolvedAt?: true
    resolution?: true
    estimatedCost?: true
    suggestedSupplier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialPurchaseAlertCountAggregateInputType = {
    id?: true
    materialId?: true
    orderId?: true
    alertType?: true
    requiredQuantity?: true
    currentStock?: true
    urgencyLevel?: true
    message?: true
    status?: true
    createdBy?: true
    resolvedBy?: true
    resolvedAt?: true
    resolution?: true
    estimatedCost?: true
    suggestedSupplier?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterialPurchaseAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialPurchaseAlert to aggregate.
     */
    where?: MaterialPurchaseAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialPurchaseAlerts to fetch.
     */
    orderBy?: MaterialPurchaseAlertOrderByWithRelationInput | MaterialPurchaseAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialPurchaseAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialPurchaseAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialPurchaseAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialPurchaseAlerts
    **/
    _count?: true | MaterialPurchaseAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialPurchaseAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialPurchaseAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialPurchaseAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialPurchaseAlertMaxAggregateInputType
  }

  export type GetMaterialPurchaseAlertAggregateType<T extends MaterialPurchaseAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialPurchaseAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialPurchaseAlert[P]>
      : GetScalarType<T[P], AggregateMaterialPurchaseAlert[P]>
  }




  export type MaterialPurchaseAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialPurchaseAlertWhereInput
    orderBy?: MaterialPurchaseAlertOrderByWithAggregationInput | MaterialPurchaseAlertOrderByWithAggregationInput[]
    by: MaterialPurchaseAlertScalarFieldEnum[] | MaterialPurchaseAlertScalarFieldEnum
    having?: MaterialPurchaseAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialPurchaseAlertCountAggregateInputType | true
    _avg?: MaterialPurchaseAlertAvgAggregateInputType
    _sum?: MaterialPurchaseAlertSumAggregateInputType
    _min?: MaterialPurchaseAlertMinAggregateInputType
    _max?: MaterialPurchaseAlertMaxAggregateInputType
  }

  export type MaterialPurchaseAlertGroupByOutputType = {
    id: number
    materialId: number
    orderId: number | null
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal
    currentStock: Decimal
    urgencyLevel: $Enums.UrgencyLevel
    message: string
    status: $Enums.AlertStatus
    createdBy: number
    resolvedBy: number | null
    resolvedAt: Date | null
    resolution: string | null
    estimatedCost: Decimal | null
    suggestedSupplier: string | null
    createdAt: Date
    updatedAt: Date
    _count: MaterialPurchaseAlertCountAggregateOutputType | null
    _avg: MaterialPurchaseAlertAvgAggregateOutputType | null
    _sum: MaterialPurchaseAlertSumAggregateOutputType | null
    _min: MaterialPurchaseAlertMinAggregateOutputType | null
    _max: MaterialPurchaseAlertMaxAggregateOutputType | null
  }

  type GetMaterialPurchaseAlertGroupByPayload<T extends MaterialPurchaseAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialPurchaseAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialPurchaseAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialPurchaseAlertGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialPurchaseAlertGroupByOutputType[P]>
        }
      >
    >


  export type MaterialPurchaseAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    orderId?: boolean
    alertType?: boolean
    requiredQuantity?: boolean
    currentStock?: boolean
    urgencyLevel?: boolean
    message?: boolean
    status?: boolean
    createdBy?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    resolution?: boolean
    estimatedCost?: boolean
    suggestedSupplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    order?: boolean | MaterialPurchaseAlert$orderArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | MaterialPurchaseAlert$resolvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["materialPurchaseAlert"]>

  export type MaterialPurchaseAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    orderId?: boolean
    alertType?: boolean
    requiredQuantity?: boolean
    currentStock?: boolean
    urgencyLevel?: boolean
    message?: boolean
    status?: boolean
    createdBy?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    resolution?: boolean
    estimatedCost?: boolean
    suggestedSupplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    order?: boolean | MaterialPurchaseAlert$orderArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | MaterialPurchaseAlert$resolvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["materialPurchaseAlert"]>

  export type MaterialPurchaseAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    orderId?: boolean
    alertType?: boolean
    requiredQuantity?: boolean
    currentStock?: boolean
    urgencyLevel?: boolean
    message?: boolean
    status?: boolean
    createdBy?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    resolution?: boolean
    estimatedCost?: boolean
    suggestedSupplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    order?: boolean | MaterialPurchaseAlert$orderArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | MaterialPurchaseAlert$resolvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["materialPurchaseAlert"]>

  export type MaterialPurchaseAlertSelectScalar = {
    id?: boolean
    materialId?: boolean
    orderId?: boolean
    alertType?: boolean
    requiredQuantity?: boolean
    currentStock?: boolean
    urgencyLevel?: boolean
    message?: boolean
    status?: boolean
    createdBy?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    resolution?: boolean
    estimatedCost?: boolean
    suggestedSupplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaterialPurchaseAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "materialId" | "orderId" | "alertType" | "requiredQuantity" | "currentStock" | "urgencyLevel" | "message" | "status" | "createdBy" | "resolvedBy" | "resolvedAt" | "resolution" | "estimatedCost" | "suggestedSupplier" | "createdAt" | "updatedAt", ExtArgs["result"]["materialPurchaseAlert"]>
  export type MaterialPurchaseAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    order?: boolean | MaterialPurchaseAlert$orderArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | MaterialPurchaseAlert$resolvedByUserArgs<ExtArgs>
  }
  export type MaterialPurchaseAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    order?: boolean | MaterialPurchaseAlert$orderArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | MaterialPurchaseAlert$resolvedByUserArgs<ExtArgs>
  }
  export type MaterialPurchaseAlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    order?: boolean | MaterialPurchaseAlert$orderArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | MaterialPurchaseAlert$resolvedByUserArgs<ExtArgs>
  }

  export type $MaterialPurchaseAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialPurchaseAlert"
    objects: {
      material: Prisma.$MaterialPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
      createdByUser: Prisma.$UserPayload<ExtArgs>
      resolvedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materialId: number
      orderId: number | null
      alertType: $Enums.MaterialPurchaseAlertType
      requiredQuantity: Prisma.Decimal
      currentStock: Prisma.Decimal
      urgencyLevel: $Enums.UrgencyLevel
      message: string
      status: $Enums.AlertStatus
      createdBy: number
      resolvedBy: number | null
      resolvedAt: Date | null
      resolution: string | null
      estimatedCost: Prisma.Decimal | null
      suggestedSupplier: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["materialPurchaseAlert"]>
    composites: {}
  }

  type MaterialPurchaseAlertGetPayload<S extends boolean | null | undefined | MaterialPurchaseAlertDefaultArgs> = $Result.GetResult<Prisma.$MaterialPurchaseAlertPayload, S>

  type MaterialPurchaseAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialPurchaseAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialPurchaseAlertCountAggregateInputType | true
    }

  export interface MaterialPurchaseAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialPurchaseAlert'], meta: { name: 'MaterialPurchaseAlert' } }
    /**
     * Find zero or one MaterialPurchaseAlert that matches the filter.
     * @param {MaterialPurchaseAlertFindUniqueArgs} args - Arguments to find a MaterialPurchaseAlert
     * @example
     * // Get one MaterialPurchaseAlert
     * const materialPurchaseAlert = await prisma.materialPurchaseAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialPurchaseAlertFindUniqueArgs>(args: SelectSubset<T, MaterialPurchaseAlertFindUniqueArgs<ExtArgs>>): Prisma__MaterialPurchaseAlertClient<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaterialPurchaseAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialPurchaseAlertFindUniqueOrThrowArgs} args - Arguments to find a MaterialPurchaseAlert
     * @example
     * // Get one MaterialPurchaseAlert
     * const materialPurchaseAlert = await prisma.materialPurchaseAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialPurchaseAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialPurchaseAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialPurchaseAlertClient<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialPurchaseAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialPurchaseAlertFindFirstArgs} args - Arguments to find a MaterialPurchaseAlert
     * @example
     * // Get one MaterialPurchaseAlert
     * const materialPurchaseAlert = await prisma.materialPurchaseAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialPurchaseAlertFindFirstArgs>(args?: SelectSubset<T, MaterialPurchaseAlertFindFirstArgs<ExtArgs>>): Prisma__MaterialPurchaseAlertClient<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialPurchaseAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialPurchaseAlertFindFirstOrThrowArgs} args - Arguments to find a MaterialPurchaseAlert
     * @example
     * // Get one MaterialPurchaseAlert
     * const materialPurchaseAlert = await prisma.materialPurchaseAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialPurchaseAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialPurchaseAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialPurchaseAlertClient<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaterialPurchaseAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialPurchaseAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialPurchaseAlerts
     * const materialPurchaseAlerts = await prisma.materialPurchaseAlert.findMany()
     * 
     * // Get first 10 MaterialPurchaseAlerts
     * const materialPurchaseAlerts = await prisma.materialPurchaseAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialPurchaseAlertWithIdOnly = await prisma.materialPurchaseAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialPurchaseAlertFindManyArgs>(args?: SelectSubset<T, MaterialPurchaseAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaterialPurchaseAlert.
     * @param {MaterialPurchaseAlertCreateArgs} args - Arguments to create a MaterialPurchaseAlert.
     * @example
     * // Create one MaterialPurchaseAlert
     * const MaterialPurchaseAlert = await prisma.materialPurchaseAlert.create({
     *   data: {
     *     // ... data to create a MaterialPurchaseAlert
     *   }
     * })
     * 
     */
    create<T extends MaterialPurchaseAlertCreateArgs>(args: SelectSubset<T, MaterialPurchaseAlertCreateArgs<ExtArgs>>): Prisma__MaterialPurchaseAlertClient<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaterialPurchaseAlerts.
     * @param {MaterialPurchaseAlertCreateManyArgs} args - Arguments to create many MaterialPurchaseAlerts.
     * @example
     * // Create many MaterialPurchaseAlerts
     * const materialPurchaseAlert = await prisma.materialPurchaseAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialPurchaseAlertCreateManyArgs>(args?: SelectSubset<T, MaterialPurchaseAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaterialPurchaseAlerts and returns the data saved in the database.
     * @param {MaterialPurchaseAlertCreateManyAndReturnArgs} args - Arguments to create many MaterialPurchaseAlerts.
     * @example
     * // Create many MaterialPurchaseAlerts
     * const materialPurchaseAlert = await prisma.materialPurchaseAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaterialPurchaseAlerts and only return the `id`
     * const materialPurchaseAlertWithIdOnly = await prisma.materialPurchaseAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialPurchaseAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialPurchaseAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaterialPurchaseAlert.
     * @param {MaterialPurchaseAlertDeleteArgs} args - Arguments to delete one MaterialPurchaseAlert.
     * @example
     * // Delete one MaterialPurchaseAlert
     * const MaterialPurchaseAlert = await prisma.materialPurchaseAlert.delete({
     *   where: {
     *     // ... filter to delete one MaterialPurchaseAlert
     *   }
     * })
     * 
     */
    delete<T extends MaterialPurchaseAlertDeleteArgs>(args: SelectSubset<T, MaterialPurchaseAlertDeleteArgs<ExtArgs>>): Prisma__MaterialPurchaseAlertClient<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaterialPurchaseAlert.
     * @param {MaterialPurchaseAlertUpdateArgs} args - Arguments to update one MaterialPurchaseAlert.
     * @example
     * // Update one MaterialPurchaseAlert
     * const materialPurchaseAlert = await prisma.materialPurchaseAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialPurchaseAlertUpdateArgs>(args: SelectSubset<T, MaterialPurchaseAlertUpdateArgs<ExtArgs>>): Prisma__MaterialPurchaseAlertClient<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaterialPurchaseAlerts.
     * @param {MaterialPurchaseAlertDeleteManyArgs} args - Arguments to filter MaterialPurchaseAlerts to delete.
     * @example
     * // Delete a few MaterialPurchaseAlerts
     * const { count } = await prisma.materialPurchaseAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialPurchaseAlertDeleteManyArgs>(args?: SelectSubset<T, MaterialPurchaseAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialPurchaseAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialPurchaseAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialPurchaseAlerts
     * const materialPurchaseAlert = await prisma.materialPurchaseAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialPurchaseAlertUpdateManyArgs>(args: SelectSubset<T, MaterialPurchaseAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialPurchaseAlerts and returns the data updated in the database.
     * @param {MaterialPurchaseAlertUpdateManyAndReturnArgs} args - Arguments to update many MaterialPurchaseAlerts.
     * @example
     * // Update many MaterialPurchaseAlerts
     * const materialPurchaseAlert = await prisma.materialPurchaseAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaterialPurchaseAlerts and only return the `id`
     * const materialPurchaseAlertWithIdOnly = await prisma.materialPurchaseAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialPurchaseAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialPurchaseAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaterialPurchaseAlert.
     * @param {MaterialPurchaseAlertUpsertArgs} args - Arguments to update or create a MaterialPurchaseAlert.
     * @example
     * // Update or create a MaterialPurchaseAlert
     * const materialPurchaseAlert = await prisma.materialPurchaseAlert.upsert({
     *   create: {
     *     // ... data to create a MaterialPurchaseAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialPurchaseAlert we want to update
     *   }
     * })
     */
    upsert<T extends MaterialPurchaseAlertUpsertArgs>(args: SelectSubset<T, MaterialPurchaseAlertUpsertArgs<ExtArgs>>): Prisma__MaterialPurchaseAlertClient<$Result.GetResult<Prisma.$MaterialPurchaseAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaterialPurchaseAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialPurchaseAlertCountArgs} args - Arguments to filter MaterialPurchaseAlerts to count.
     * @example
     * // Count the number of MaterialPurchaseAlerts
     * const count = await prisma.materialPurchaseAlert.count({
     *   where: {
     *     // ... the filter for the MaterialPurchaseAlerts we want to count
     *   }
     * })
    **/
    count<T extends MaterialPurchaseAlertCountArgs>(
      args?: Subset<T, MaterialPurchaseAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialPurchaseAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialPurchaseAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialPurchaseAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialPurchaseAlertAggregateArgs>(args: Subset<T, MaterialPurchaseAlertAggregateArgs>): Prisma.PrismaPromise<GetMaterialPurchaseAlertAggregateType<T>>

    /**
     * Group by MaterialPurchaseAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialPurchaseAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialPurchaseAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialPurchaseAlertGroupByArgs['orderBy'] }
        : { orderBy?: MaterialPurchaseAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialPurchaseAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialPurchaseAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialPurchaseAlert model
   */
  readonly fields: MaterialPurchaseAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialPurchaseAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialPurchaseAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends MaterialPurchaseAlert$orderArgs<ExtArgs> = {}>(args?: Subset<T, MaterialPurchaseAlert$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resolvedByUser<T extends MaterialPurchaseAlert$resolvedByUserArgs<ExtArgs> = {}>(args?: Subset<T, MaterialPurchaseAlert$resolvedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialPurchaseAlert model
   */
  interface MaterialPurchaseAlertFieldRefs {
    readonly id: FieldRef<"MaterialPurchaseAlert", 'Int'>
    readonly materialId: FieldRef<"MaterialPurchaseAlert", 'Int'>
    readonly orderId: FieldRef<"MaterialPurchaseAlert", 'Int'>
    readonly alertType: FieldRef<"MaterialPurchaseAlert", 'MaterialPurchaseAlertType'>
    readonly requiredQuantity: FieldRef<"MaterialPurchaseAlert", 'Decimal'>
    readonly currentStock: FieldRef<"MaterialPurchaseAlert", 'Decimal'>
    readonly urgencyLevel: FieldRef<"MaterialPurchaseAlert", 'UrgencyLevel'>
    readonly message: FieldRef<"MaterialPurchaseAlert", 'String'>
    readonly status: FieldRef<"MaterialPurchaseAlert", 'AlertStatus'>
    readonly createdBy: FieldRef<"MaterialPurchaseAlert", 'Int'>
    readonly resolvedBy: FieldRef<"MaterialPurchaseAlert", 'Int'>
    readonly resolvedAt: FieldRef<"MaterialPurchaseAlert", 'DateTime'>
    readonly resolution: FieldRef<"MaterialPurchaseAlert", 'String'>
    readonly estimatedCost: FieldRef<"MaterialPurchaseAlert", 'Decimal'>
    readonly suggestedSupplier: FieldRef<"MaterialPurchaseAlert", 'String'>
    readonly createdAt: FieldRef<"MaterialPurchaseAlert", 'DateTime'>
    readonly updatedAt: FieldRef<"MaterialPurchaseAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaterialPurchaseAlert findUnique
   */
  export type MaterialPurchaseAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    /**
     * Filter, which MaterialPurchaseAlert to fetch.
     */
    where: MaterialPurchaseAlertWhereUniqueInput
  }

  /**
   * MaterialPurchaseAlert findUniqueOrThrow
   */
  export type MaterialPurchaseAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    /**
     * Filter, which MaterialPurchaseAlert to fetch.
     */
    where: MaterialPurchaseAlertWhereUniqueInput
  }

  /**
   * MaterialPurchaseAlert findFirst
   */
  export type MaterialPurchaseAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    /**
     * Filter, which MaterialPurchaseAlert to fetch.
     */
    where?: MaterialPurchaseAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialPurchaseAlerts to fetch.
     */
    orderBy?: MaterialPurchaseAlertOrderByWithRelationInput | MaterialPurchaseAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialPurchaseAlerts.
     */
    cursor?: MaterialPurchaseAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialPurchaseAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialPurchaseAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialPurchaseAlerts.
     */
    distinct?: MaterialPurchaseAlertScalarFieldEnum | MaterialPurchaseAlertScalarFieldEnum[]
  }

  /**
   * MaterialPurchaseAlert findFirstOrThrow
   */
  export type MaterialPurchaseAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    /**
     * Filter, which MaterialPurchaseAlert to fetch.
     */
    where?: MaterialPurchaseAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialPurchaseAlerts to fetch.
     */
    orderBy?: MaterialPurchaseAlertOrderByWithRelationInput | MaterialPurchaseAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialPurchaseAlerts.
     */
    cursor?: MaterialPurchaseAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialPurchaseAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialPurchaseAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialPurchaseAlerts.
     */
    distinct?: MaterialPurchaseAlertScalarFieldEnum | MaterialPurchaseAlertScalarFieldEnum[]
  }

  /**
   * MaterialPurchaseAlert findMany
   */
  export type MaterialPurchaseAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    /**
     * Filter, which MaterialPurchaseAlerts to fetch.
     */
    where?: MaterialPurchaseAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialPurchaseAlerts to fetch.
     */
    orderBy?: MaterialPurchaseAlertOrderByWithRelationInput | MaterialPurchaseAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialPurchaseAlerts.
     */
    cursor?: MaterialPurchaseAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialPurchaseAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialPurchaseAlerts.
     */
    skip?: number
    distinct?: MaterialPurchaseAlertScalarFieldEnum | MaterialPurchaseAlertScalarFieldEnum[]
  }

  /**
   * MaterialPurchaseAlert create
   */
  export type MaterialPurchaseAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialPurchaseAlert.
     */
    data: XOR<MaterialPurchaseAlertCreateInput, MaterialPurchaseAlertUncheckedCreateInput>
  }

  /**
   * MaterialPurchaseAlert createMany
   */
  export type MaterialPurchaseAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialPurchaseAlerts.
     */
    data: MaterialPurchaseAlertCreateManyInput | MaterialPurchaseAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialPurchaseAlert createManyAndReturn
   */
  export type MaterialPurchaseAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * The data used to create many MaterialPurchaseAlerts.
     */
    data: MaterialPurchaseAlertCreateManyInput | MaterialPurchaseAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialPurchaseAlert update
   */
  export type MaterialPurchaseAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialPurchaseAlert.
     */
    data: XOR<MaterialPurchaseAlertUpdateInput, MaterialPurchaseAlertUncheckedUpdateInput>
    /**
     * Choose, which MaterialPurchaseAlert to update.
     */
    where: MaterialPurchaseAlertWhereUniqueInput
  }

  /**
   * MaterialPurchaseAlert updateMany
   */
  export type MaterialPurchaseAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialPurchaseAlerts.
     */
    data: XOR<MaterialPurchaseAlertUpdateManyMutationInput, MaterialPurchaseAlertUncheckedUpdateManyInput>
    /**
     * Filter which MaterialPurchaseAlerts to update
     */
    where?: MaterialPurchaseAlertWhereInput
    /**
     * Limit how many MaterialPurchaseAlerts to update.
     */
    limit?: number
  }

  /**
   * MaterialPurchaseAlert updateManyAndReturn
   */
  export type MaterialPurchaseAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * The data used to update MaterialPurchaseAlerts.
     */
    data: XOR<MaterialPurchaseAlertUpdateManyMutationInput, MaterialPurchaseAlertUncheckedUpdateManyInput>
    /**
     * Filter which MaterialPurchaseAlerts to update
     */
    where?: MaterialPurchaseAlertWhereInput
    /**
     * Limit how many MaterialPurchaseAlerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialPurchaseAlert upsert
   */
  export type MaterialPurchaseAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialPurchaseAlert to update in case it exists.
     */
    where: MaterialPurchaseAlertWhereUniqueInput
    /**
     * In case the MaterialPurchaseAlert found by the `where` argument doesn't exist, create a new MaterialPurchaseAlert with this data.
     */
    create: XOR<MaterialPurchaseAlertCreateInput, MaterialPurchaseAlertUncheckedCreateInput>
    /**
     * In case the MaterialPurchaseAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialPurchaseAlertUpdateInput, MaterialPurchaseAlertUncheckedUpdateInput>
  }

  /**
   * MaterialPurchaseAlert delete
   */
  export type MaterialPurchaseAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
    /**
     * Filter which MaterialPurchaseAlert to delete.
     */
    where: MaterialPurchaseAlertWhereUniqueInput
  }

  /**
   * MaterialPurchaseAlert deleteMany
   */
  export type MaterialPurchaseAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialPurchaseAlerts to delete
     */
    where?: MaterialPurchaseAlertWhereInput
    /**
     * Limit how many MaterialPurchaseAlerts to delete.
     */
    limit?: number
  }

  /**
   * MaterialPurchaseAlert.order
   */
  export type MaterialPurchaseAlert$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * MaterialPurchaseAlert.resolvedByUser
   */
  export type MaterialPurchaseAlert$resolvedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MaterialPurchaseAlert without action
   */
  export type MaterialPurchaseAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialPurchaseAlert
     */
    select?: MaterialPurchaseAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialPurchaseAlert
     */
    omit?: MaterialPurchaseAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialPurchaseAlertInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseLog
   */

  export type AggregatePurchaseLog = {
    _count: PurchaseLogCountAggregateOutputType | null
    _avg: PurchaseLogAvgAggregateOutputType | null
    _sum: PurchaseLogSumAggregateOutputType | null
    _min: PurchaseLogMinAggregateOutputType | null
    _max: PurchaseLogMaxAggregateOutputType | null
  }

  export type PurchaseLogAvgAggregateOutputType = {
    id: number | null
    materialId: number | null
    quantity: Decimal | null
    pricePerUnit: Decimal | null
    totalCost: Decimal | null
    receivedQuantity: Decimal | null
  }

  export type PurchaseLogSumAggregateOutputType = {
    id: number | null
    materialId: number | null
    quantity: Decimal | null
    pricePerUnit: Decimal | null
    totalCost: Decimal | null
    receivedQuantity: Decimal | null
  }

  export type PurchaseLogMinAggregateOutputType = {
    id: number | null
    materialId: number | null
    supplier: string | null
    quantity: Decimal | null
    unit: string | null
    pricePerUnit: Decimal | null
    totalCost: Decimal | null
    purchaseDate: Date | null
    invoiceNumber: string | null
    receiptPath: string | null
    notes: string | null
    status: $Enums.PurchaseStatus | null
    deliveryDate: Date | null
    receivedQuantity: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseLogMaxAggregateOutputType = {
    id: number | null
    materialId: number | null
    supplier: string | null
    quantity: Decimal | null
    unit: string | null
    pricePerUnit: Decimal | null
    totalCost: Decimal | null
    purchaseDate: Date | null
    invoiceNumber: string | null
    receiptPath: string | null
    notes: string | null
    status: $Enums.PurchaseStatus | null
    deliveryDate: Date | null
    receivedQuantity: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseLogCountAggregateOutputType = {
    id: number
    materialId: number
    supplier: number
    quantity: number
    unit: number
    pricePerUnit: number
    totalCost: number
    purchaseDate: number
    invoiceNumber: number
    receiptPath: number
    notes: number
    status: number
    deliveryDate: number
    receivedQuantity: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseLogAvgAggregateInputType = {
    id?: true
    materialId?: true
    quantity?: true
    pricePerUnit?: true
    totalCost?: true
    receivedQuantity?: true
  }

  export type PurchaseLogSumAggregateInputType = {
    id?: true
    materialId?: true
    quantity?: true
    pricePerUnit?: true
    totalCost?: true
    receivedQuantity?: true
  }

  export type PurchaseLogMinAggregateInputType = {
    id?: true
    materialId?: true
    supplier?: true
    quantity?: true
    unit?: true
    pricePerUnit?: true
    totalCost?: true
    purchaseDate?: true
    invoiceNumber?: true
    receiptPath?: true
    notes?: true
    status?: true
    deliveryDate?: true
    receivedQuantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseLogMaxAggregateInputType = {
    id?: true
    materialId?: true
    supplier?: true
    quantity?: true
    unit?: true
    pricePerUnit?: true
    totalCost?: true
    purchaseDate?: true
    invoiceNumber?: true
    receiptPath?: true
    notes?: true
    status?: true
    deliveryDate?: true
    receivedQuantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseLogCountAggregateInputType = {
    id?: true
    materialId?: true
    supplier?: true
    quantity?: true
    unit?: true
    pricePerUnit?: true
    totalCost?: true
    purchaseDate?: true
    invoiceNumber?: true
    receiptPath?: true
    notes?: true
    status?: true
    deliveryDate?: true
    receivedQuantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseLog to aggregate.
     */
    where?: PurchaseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseLogs to fetch.
     */
    orderBy?: PurchaseLogOrderByWithRelationInput | PurchaseLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseLogs
    **/
    _count?: true | PurchaseLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseLogMaxAggregateInputType
  }

  export type GetPurchaseLogAggregateType<T extends PurchaseLogAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseLog[P]>
      : GetScalarType<T[P], AggregatePurchaseLog[P]>
  }




  export type PurchaseLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseLogWhereInput
    orderBy?: PurchaseLogOrderByWithAggregationInput | PurchaseLogOrderByWithAggregationInput[]
    by: PurchaseLogScalarFieldEnum[] | PurchaseLogScalarFieldEnum
    having?: PurchaseLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseLogCountAggregateInputType | true
    _avg?: PurchaseLogAvgAggregateInputType
    _sum?: PurchaseLogSumAggregateInputType
    _min?: PurchaseLogMinAggregateInputType
    _max?: PurchaseLogMaxAggregateInputType
  }

  export type PurchaseLogGroupByOutputType = {
    id: number
    materialId: number
    supplier: string
    quantity: Decimal
    unit: string
    pricePerUnit: Decimal
    totalCost: Decimal
    purchaseDate: Date
    invoiceNumber: string | null
    receiptPath: string | null
    notes: string | null
    status: $Enums.PurchaseStatus
    deliveryDate: Date | null
    receivedQuantity: Decimal | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PurchaseLogCountAggregateOutputType | null
    _avg: PurchaseLogAvgAggregateOutputType | null
    _sum: PurchaseLogSumAggregateOutputType | null
    _min: PurchaseLogMinAggregateOutputType | null
    _max: PurchaseLogMaxAggregateOutputType | null
  }

  type GetPurchaseLogGroupByPayload<T extends PurchaseLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseLogGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseLogGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    supplier?: boolean
    quantity?: boolean
    unit?: boolean
    pricePerUnit?: boolean
    totalCost?: boolean
    purchaseDate?: boolean
    invoiceNumber?: boolean
    receiptPath?: boolean
    notes?: boolean
    status?: boolean
    deliveryDate?: boolean
    receivedQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    movement?: boolean | PurchaseLog$movementArgs<ExtArgs>
    contactNotes?: boolean | PurchaseLog$contactNotesArgs<ExtArgs>
    _count?: boolean | PurchaseLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseLog"]>

  export type PurchaseLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    supplier?: boolean
    quantity?: boolean
    unit?: boolean
    pricePerUnit?: boolean
    totalCost?: boolean
    purchaseDate?: boolean
    invoiceNumber?: boolean
    receiptPath?: boolean
    notes?: boolean
    status?: boolean
    deliveryDate?: boolean
    receivedQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseLog"]>

  export type PurchaseLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialId?: boolean
    supplier?: boolean
    quantity?: boolean
    unit?: boolean
    pricePerUnit?: boolean
    totalCost?: boolean
    purchaseDate?: boolean
    invoiceNumber?: boolean
    receiptPath?: boolean
    notes?: boolean
    status?: boolean
    deliveryDate?: boolean
    receivedQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseLog"]>

  export type PurchaseLogSelectScalar = {
    id?: boolean
    materialId?: boolean
    supplier?: boolean
    quantity?: boolean
    unit?: boolean
    pricePerUnit?: boolean
    totalCost?: boolean
    purchaseDate?: boolean
    invoiceNumber?: boolean
    receiptPath?: boolean
    notes?: boolean
    status?: boolean
    deliveryDate?: boolean
    receivedQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "materialId" | "supplier" | "quantity" | "unit" | "pricePerUnit" | "totalCost" | "purchaseDate" | "invoiceNumber" | "receiptPath" | "notes" | "status" | "deliveryDate" | "receivedQuantity" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseLog"]>
  export type PurchaseLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    movement?: boolean | PurchaseLog$movementArgs<ExtArgs>
    contactNotes?: boolean | PurchaseLog$contactNotesArgs<ExtArgs>
    _count?: boolean | PurchaseLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type PurchaseLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }

  export type $PurchaseLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseLog"
    objects: {
      material: Prisma.$MaterialPayload<ExtArgs>
      movement: Prisma.$MaterialMovementPayload<ExtArgs> | null
      contactNotes: Prisma.$ContactNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materialId: number
      supplier: string
      quantity: Prisma.Decimal
      unit: string
      pricePerUnit: Prisma.Decimal
      totalCost: Prisma.Decimal
      purchaseDate: Date
      invoiceNumber: string | null
      receiptPath: string | null
      notes: string | null
      status: $Enums.PurchaseStatus
      deliveryDate: Date | null
      receivedQuantity: Prisma.Decimal | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseLog"]>
    composites: {}
  }

  type PurchaseLogGetPayload<S extends boolean | null | undefined | PurchaseLogDefaultArgs> = $Result.GetResult<Prisma.$PurchaseLogPayload, S>

  type PurchaseLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseLogCountAggregateInputType | true
    }

  export interface PurchaseLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseLog'], meta: { name: 'PurchaseLog' } }
    /**
     * Find zero or one PurchaseLog that matches the filter.
     * @param {PurchaseLogFindUniqueArgs} args - Arguments to find a PurchaseLog
     * @example
     * // Get one PurchaseLog
     * const purchaseLog = await prisma.purchaseLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseLogFindUniqueArgs>(args: SelectSubset<T, PurchaseLogFindUniqueArgs<ExtArgs>>): Prisma__PurchaseLogClient<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseLogFindUniqueOrThrowArgs} args - Arguments to find a PurchaseLog
     * @example
     * // Get one PurchaseLog
     * const purchaseLog = await prisma.purchaseLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseLogFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseLogClient<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLogFindFirstArgs} args - Arguments to find a PurchaseLog
     * @example
     * // Get one PurchaseLog
     * const purchaseLog = await prisma.purchaseLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseLogFindFirstArgs>(args?: SelectSubset<T, PurchaseLogFindFirstArgs<ExtArgs>>): Prisma__PurchaseLogClient<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLogFindFirstOrThrowArgs} args - Arguments to find a PurchaseLog
     * @example
     * // Get one PurchaseLog
     * const purchaseLog = await prisma.purchaseLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseLogFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseLogClient<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseLogs
     * const purchaseLogs = await prisma.purchaseLog.findMany()
     * 
     * // Get first 10 PurchaseLogs
     * const purchaseLogs = await prisma.purchaseLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseLogWithIdOnly = await prisma.purchaseLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseLogFindManyArgs>(args?: SelectSubset<T, PurchaseLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseLog.
     * @param {PurchaseLogCreateArgs} args - Arguments to create a PurchaseLog.
     * @example
     * // Create one PurchaseLog
     * const PurchaseLog = await prisma.purchaseLog.create({
     *   data: {
     *     // ... data to create a PurchaseLog
     *   }
     * })
     * 
     */
    create<T extends PurchaseLogCreateArgs>(args: SelectSubset<T, PurchaseLogCreateArgs<ExtArgs>>): Prisma__PurchaseLogClient<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseLogs.
     * @param {PurchaseLogCreateManyArgs} args - Arguments to create many PurchaseLogs.
     * @example
     * // Create many PurchaseLogs
     * const purchaseLog = await prisma.purchaseLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseLogCreateManyArgs>(args?: SelectSubset<T, PurchaseLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseLogs and returns the data saved in the database.
     * @param {PurchaseLogCreateManyAndReturnArgs} args - Arguments to create many PurchaseLogs.
     * @example
     * // Create many PurchaseLogs
     * const purchaseLog = await prisma.purchaseLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseLogs and only return the `id`
     * const purchaseLogWithIdOnly = await prisma.purchaseLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseLogCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseLog.
     * @param {PurchaseLogDeleteArgs} args - Arguments to delete one PurchaseLog.
     * @example
     * // Delete one PurchaseLog
     * const PurchaseLog = await prisma.purchaseLog.delete({
     *   where: {
     *     // ... filter to delete one PurchaseLog
     *   }
     * })
     * 
     */
    delete<T extends PurchaseLogDeleteArgs>(args: SelectSubset<T, PurchaseLogDeleteArgs<ExtArgs>>): Prisma__PurchaseLogClient<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseLog.
     * @param {PurchaseLogUpdateArgs} args - Arguments to update one PurchaseLog.
     * @example
     * // Update one PurchaseLog
     * const purchaseLog = await prisma.purchaseLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseLogUpdateArgs>(args: SelectSubset<T, PurchaseLogUpdateArgs<ExtArgs>>): Prisma__PurchaseLogClient<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseLogs.
     * @param {PurchaseLogDeleteManyArgs} args - Arguments to filter PurchaseLogs to delete.
     * @example
     * // Delete a few PurchaseLogs
     * const { count } = await prisma.purchaseLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseLogDeleteManyArgs>(args?: SelectSubset<T, PurchaseLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseLogs
     * const purchaseLog = await prisma.purchaseLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseLogUpdateManyArgs>(args: SelectSubset<T, PurchaseLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseLogs and returns the data updated in the database.
     * @param {PurchaseLogUpdateManyAndReturnArgs} args - Arguments to update many PurchaseLogs.
     * @example
     * // Update many PurchaseLogs
     * const purchaseLog = await prisma.purchaseLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseLogs and only return the `id`
     * const purchaseLogWithIdOnly = await prisma.purchaseLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseLogUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseLog.
     * @param {PurchaseLogUpsertArgs} args - Arguments to update or create a PurchaseLog.
     * @example
     * // Update or create a PurchaseLog
     * const purchaseLog = await prisma.purchaseLog.upsert({
     *   create: {
     *     // ... data to create a PurchaseLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseLog we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseLogUpsertArgs>(args: SelectSubset<T, PurchaseLogUpsertArgs<ExtArgs>>): Prisma__PurchaseLogClient<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLogCountArgs} args - Arguments to filter PurchaseLogs to count.
     * @example
     * // Count the number of PurchaseLogs
     * const count = await prisma.purchaseLog.count({
     *   where: {
     *     // ... the filter for the PurchaseLogs we want to count
     *   }
     * })
    **/
    count<T extends PurchaseLogCountArgs>(
      args?: Subset<T, PurchaseLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseLogAggregateArgs>(args: Subset<T, PurchaseLogAggregateArgs>): Prisma.PrismaPromise<GetPurchaseLogAggregateType<T>>

    /**
     * Group by PurchaseLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseLogGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseLog model
   */
  readonly fields: PurchaseLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    movement<T extends PurchaseLog$movementArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseLog$movementArgs<ExtArgs>>): Prisma__MaterialMovementClient<$Result.GetResult<Prisma.$MaterialMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contactNotes<T extends PurchaseLog$contactNotesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseLog$contactNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseLog model
   */
  interface PurchaseLogFieldRefs {
    readonly id: FieldRef<"PurchaseLog", 'Int'>
    readonly materialId: FieldRef<"PurchaseLog", 'Int'>
    readonly supplier: FieldRef<"PurchaseLog", 'String'>
    readonly quantity: FieldRef<"PurchaseLog", 'Decimal'>
    readonly unit: FieldRef<"PurchaseLog", 'String'>
    readonly pricePerUnit: FieldRef<"PurchaseLog", 'Decimal'>
    readonly totalCost: FieldRef<"PurchaseLog", 'Decimal'>
    readonly purchaseDate: FieldRef<"PurchaseLog", 'DateTime'>
    readonly invoiceNumber: FieldRef<"PurchaseLog", 'String'>
    readonly receiptPath: FieldRef<"PurchaseLog", 'String'>
    readonly notes: FieldRef<"PurchaseLog", 'String'>
    readonly status: FieldRef<"PurchaseLog", 'PurchaseStatus'>
    readonly deliveryDate: FieldRef<"PurchaseLog", 'DateTime'>
    readonly receivedQuantity: FieldRef<"PurchaseLog", 'Decimal'>
    readonly isActive: FieldRef<"PurchaseLog", 'Boolean'>
    readonly createdAt: FieldRef<"PurchaseLog", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseLog findUnique
   */
  export type PurchaseLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLog to fetch.
     */
    where: PurchaseLogWhereUniqueInput
  }

  /**
   * PurchaseLog findUniqueOrThrow
   */
  export type PurchaseLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLog to fetch.
     */
    where: PurchaseLogWhereUniqueInput
  }

  /**
   * PurchaseLog findFirst
   */
  export type PurchaseLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLog to fetch.
     */
    where?: PurchaseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseLogs to fetch.
     */
    orderBy?: PurchaseLogOrderByWithRelationInput | PurchaseLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseLogs.
     */
    cursor?: PurchaseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseLogs.
     */
    distinct?: PurchaseLogScalarFieldEnum | PurchaseLogScalarFieldEnum[]
  }

  /**
   * PurchaseLog findFirstOrThrow
   */
  export type PurchaseLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLog to fetch.
     */
    where?: PurchaseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseLogs to fetch.
     */
    orderBy?: PurchaseLogOrderByWithRelationInput | PurchaseLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseLogs.
     */
    cursor?: PurchaseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseLogs.
     */
    distinct?: PurchaseLogScalarFieldEnum | PurchaseLogScalarFieldEnum[]
  }

  /**
   * PurchaseLog findMany
   */
  export type PurchaseLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLogs to fetch.
     */
    where?: PurchaseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseLogs to fetch.
     */
    orderBy?: PurchaseLogOrderByWithRelationInput | PurchaseLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseLogs.
     */
    cursor?: PurchaseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseLogs.
     */
    skip?: number
    distinct?: PurchaseLogScalarFieldEnum | PurchaseLogScalarFieldEnum[]
  }

  /**
   * PurchaseLog create
   */
  export type PurchaseLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseLog.
     */
    data: XOR<PurchaseLogCreateInput, PurchaseLogUncheckedCreateInput>
  }

  /**
   * PurchaseLog createMany
   */
  export type PurchaseLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseLogs.
     */
    data: PurchaseLogCreateManyInput | PurchaseLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseLog createManyAndReturn
   */
  export type PurchaseLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseLogs.
     */
    data: PurchaseLogCreateManyInput | PurchaseLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseLog update
   */
  export type PurchaseLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseLog.
     */
    data: XOR<PurchaseLogUpdateInput, PurchaseLogUncheckedUpdateInput>
    /**
     * Choose, which PurchaseLog to update.
     */
    where: PurchaseLogWhereUniqueInput
  }

  /**
   * PurchaseLog updateMany
   */
  export type PurchaseLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseLogs.
     */
    data: XOR<PurchaseLogUpdateManyMutationInput, PurchaseLogUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseLogs to update
     */
    where?: PurchaseLogWhereInput
    /**
     * Limit how many PurchaseLogs to update.
     */
    limit?: number
  }

  /**
   * PurchaseLog updateManyAndReturn
   */
  export type PurchaseLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseLogs.
     */
    data: XOR<PurchaseLogUpdateManyMutationInput, PurchaseLogUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseLogs to update
     */
    where?: PurchaseLogWhereInput
    /**
     * Limit how many PurchaseLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseLog upsert
   */
  export type PurchaseLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseLog to update in case it exists.
     */
    where: PurchaseLogWhereUniqueInput
    /**
     * In case the PurchaseLog found by the `where` argument doesn't exist, create a new PurchaseLog with this data.
     */
    create: XOR<PurchaseLogCreateInput, PurchaseLogUncheckedCreateInput>
    /**
     * In case the PurchaseLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseLogUpdateInput, PurchaseLogUncheckedUpdateInput>
  }

  /**
   * PurchaseLog delete
   */
  export type PurchaseLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
    /**
     * Filter which PurchaseLog to delete.
     */
    where: PurchaseLogWhereUniqueInput
  }

  /**
   * PurchaseLog deleteMany
   */
  export type PurchaseLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseLogs to delete
     */
    where?: PurchaseLogWhereInput
    /**
     * Limit how many PurchaseLogs to delete.
     */
    limit?: number
  }

  /**
   * PurchaseLog.movement
   */
  export type PurchaseLog$movementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialMovement
     */
    select?: MaterialMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialMovement
     */
    omit?: MaterialMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialMovementInclude<ExtArgs> | null
    where?: MaterialMovementWhereInput
  }

  /**
   * PurchaseLog.contactNotes
   */
  export type PurchaseLog$contactNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    where?: ContactNoteWhereInput
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    cursor?: ContactNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactNoteScalarFieldEnum | ContactNoteScalarFieldEnum[]
  }

  /**
   * PurchaseLog without action
   */
  export type PurchaseLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    id: number | null
  }

  export type ContactSumAggregateOutputType = {
    id: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    whatsappPhone: string | null
    email: string | null
    address: string | null
    contactType: $Enums.ContactType | null
    company: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    whatsappPhone: string | null
    email: string | null
    address: string | null
    contactType: $Enums.ContactType | null
    company: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    whatsappPhone: number
    email: number
    address: number
    contactType: number
    company: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    id?: true
  }

  export type ContactSumAggregateInputType = {
    id?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    whatsappPhone?: true
    email?: true
    address?: true
    contactType?: true
    company?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    whatsappPhone?: true
    email?: true
    address?: true
    contactType?: true
    company?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    whatsappPhone?: true
    email?: true
    address?: true
    contactType?: true
    company?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: number
    name: string
    phone: string | null
    whatsappPhone: string | null
    email: string | null
    address: string | null
    contactType: $Enums.ContactType
    company: string | null
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    whatsappPhone?: boolean
    email?: boolean
    address?: boolean
    contactType?: boolean
    company?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workerOrders?: boolean | Contact$workerOrdersArgs<ExtArgs>
    contactNotes?: boolean | Contact$contactNotesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    whatsappPhone?: boolean
    email?: boolean
    address?: boolean
    contactType?: boolean
    company?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    whatsappPhone?: boolean
    email?: boolean
    address?: boolean
    contactType?: boolean
    company?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    whatsappPhone?: boolean
    email?: boolean
    address?: boolean
    contactType?: boolean
    company?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "whatsappPhone" | "email" | "address" | "contactType" | "company" | "notes" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workerOrders?: boolean | Contact$workerOrdersArgs<ExtArgs>
    contactNotes?: boolean | Contact$contactNotesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      workerOrders: Prisma.$OrderPayload<ExtArgs>[]
      contactNotes: Prisma.$ContactNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string | null
      whatsappPhone: string | null
      email: string | null
      address: string | null
      contactType: $Enums.ContactType
      company: string | null
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workerOrders<T extends Contact$workerOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Contact$workerOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contactNotes<T extends Contact$contactNotesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$contactNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'Int'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly whatsappPhone: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly address: FieldRef<"Contact", 'String'>
    readonly contactType: FieldRef<"Contact", 'ContactType'>
    readonly company: FieldRef<"Contact", 'String'>
    readonly notes: FieldRef<"Contact", 'String'>
    readonly isActive: FieldRef<"Contact", 'Boolean'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.workerOrders
   */
  export type Contact$workerOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Contact.contactNotes
   */
  export type Contact$contactNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    where?: ContactNoteWhereInput
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    cursor?: ContactNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactNoteScalarFieldEnum | ContactNoteScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model ContactNote
   */

  export type AggregateContactNote = {
    _count: ContactNoteCountAggregateOutputType | null
    _avg: ContactNoteAvgAggregateOutputType | null
    _sum: ContactNoteSumAggregateOutputType | null
    _min: ContactNoteMinAggregateOutputType | null
    _max: ContactNoteMaxAggregateOutputType | null
  }

  export type ContactNoteAvgAggregateOutputType = {
    id: number | null
    contactId: number | null
    orderId: number | null
    purchaseLogId: number | null
    createdBy: number | null
  }

  export type ContactNoteSumAggregateOutputType = {
    id: number | null
    contactId: number | null
    orderId: number | null
    purchaseLogId: number | null
    createdBy: number | null
  }

  export type ContactNoteMinAggregateOutputType = {
    id: number | null
    contactId: number | null
    orderId: number | null
    purchaseLogId: number | null
    createdBy: number | null
    noteType: $Enums.NoteType | null
    subject: string | null
    content: string | null
    followUpDate: Date | null
    isImportant: boolean | null
    tags: string | null
    attachmentPath: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactNoteMaxAggregateOutputType = {
    id: number | null
    contactId: number | null
    orderId: number | null
    purchaseLogId: number | null
    createdBy: number | null
    noteType: $Enums.NoteType | null
    subject: string | null
    content: string | null
    followUpDate: Date | null
    isImportant: boolean | null
    tags: string | null
    attachmentPath: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactNoteCountAggregateOutputType = {
    id: number
    contactId: number
    orderId: number
    purchaseLogId: number
    createdBy: number
    noteType: number
    subject: number
    content: number
    followUpDate: number
    isImportant: number
    tags: number
    attachmentPath: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactNoteAvgAggregateInputType = {
    id?: true
    contactId?: true
    orderId?: true
    purchaseLogId?: true
    createdBy?: true
  }

  export type ContactNoteSumAggregateInputType = {
    id?: true
    contactId?: true
    orderId?: true
    purchaseLogId?: true
    createdBy?: true
  }

  export type ContactNoteMinAggregateInputType = {
    id?: true
    contactId?: true
    orderId?: true
    purchaseLogId?: true
    createdBy?: true
    noteType?: true
    subject?: true
    content?: true
    followUpDate?: true
    isImportant?: true
    tags?: true
    attachmentPath?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactNoteMaxAggregateInputType = {
    id?: true
    contactId?: true
    orderId?: true
    purchaseLogId?: true
    createdBy?: true
    noteType?: true
    subject?: true
    content?: true
    followUpDate?: true
    isImportant?: true
    tags?: true
    attachmentPath?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactNoteCountAggregateInputType = {
    id?: true
    contactId?: true
    orderId?: true
    purchaseLogId?: true
    createdBy?: true
    noteType?: true
    subject?: true
    content?: true
    followUpDate?: true
    isImportant?: true
    tags?: true
    attachmentPath?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactNote to aggregate.
     */
    where?: ContactNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactNotes to fetch.
     */
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactNotes
    **/
    _count?: true | ContactNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactNoteMaxAggregateInputType
  }

  export type GetContactNoteAggregateType<T extends ContactNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateContactNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactNote[P]>
      : GetScalarType<T[P], AggregateContactNote[P]>
  }




  export type ContactNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactNoteWhereInput
    orderBy?: ContactNoteOrderByWithAggregationInput | ContactNoteOrderByWithAggregationInput[]
    by: ContactNoteScalarFieldEnum[] | ContactNoteScalarFieldEnum
    having?: ContactNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactNoteCountAggregateInputType | true
    _avg?: ContactNoteAvgAggregateInputType
    _sum?: ContactNoteSumAggregateInputType
    _min?: ContactNoteMinAggregateInputType
    _max?: ContactNoteMaxAggregateInputType
  }

  export type ContactNoteGroupByOutputType = {
    id: number
    contactId: number
    orderId: number | null
    purchaseLogId: number | null
    createdBy: number
    noteType: $Enums.NoteType
    subject: string | null
    content: string
    followUpDate: Date | null
    isImportant: boolean
    tags: string | null
    attachmentPath: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ContactNoteCountAggregateOutputType | null
    _avg: ContactNoteAvgAggregateOutputType | null
    _sum: ContactNoteSumAggregateOutputType | null
    _min: ContactNoteMinAggregateOutputType | null
    _max: ContactNoteMaxAggregateOutputType | null
  }

  type GetContactNoteGroupByPayload<T extends ContactNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ContactNoteGroupByOutputType[P]>
        }
      >
    >


  export type ContactNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    orderId?: boolean
    purchaseLogId?: boolean
    createdBy?: boolean
    noteType?: boolean
    subject?: boolean
    content?: boolean
    followUpDate?: boolean
    isImportant?: boolean
    tags?: boolean
    attachmentPath?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    order?: boolean | ContactNote$orderArgs<ExtArgs>
    purchaseLog?: boolean | ContactNote$purchaseLogArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactNote"]>

  export type ContactNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    orderId?: boolean
    purchaseLogId?: boolean
    createdBy?: boolean
    noteType?: boolean
    subject?: boolean
    content?: boolean
    followUpDate?: boolean
    isImportant?: boolean
    tags?: boolean
    attachmentPath?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    order?: boolean | ContactNote$orderArgs<ExtArgs>
    purchaseLog?: boolean | ContactNote$purchaseLogArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactNote"]>

  export type ContactNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    orderId?: boolean
    purchaseLogId?: boolean
    createdBy?: boolean
    noteType?: boolean
    subject?: boolean
    content?: boolean
    followUpDate?: boolean
    isImportant?: boolean
    tags?: boolean
    attachmentPath?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    order?: boolean | ContactNote$orderArgs<ExtArgs>
    purchaseLog?: boolean | ContactNote$purchaseLogArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactNote"]>

  export type ContactNoteSelectScalar = {
    id?: boolean
    contactId?: boolean
    orderId?: boolean
    purchaseLogId?: boolean
    createdBy?: boolean
    noteType?: boolean
    subject?: boolean
    content?: boolean
    followUpDate?: boolean
    isImportant?: boolean
    tags?: boolean
    attachmentPath?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contactId" | "orderId" | "purchaseLogId" | "createdBy" | "noteType" | "subject" | "content" | "followUpDate" | "isImportant" | "tags" | "attachmentPath" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["contactNote"]>
  export type ContactNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    order?: boolean | ContactNote$orderArgs<ExtArgs>
    purchaseLog?: boolean | ContactNote$purchaseLogArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    order?: boolean | ContactNote$orderArgs<ExtArgs>
    purchaseLog?: boolean | ContactNote$purchaseLogArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    order?: boolean | ContactNote$orderArgs<ExtArgs>
    purchaseLog?: boolean | ContactNote$purchaseLogArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContactNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactNote"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
      purchaseLog: Prisma.$PurchaseLogPayload<ExtArgs> | null
      createdByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contactId: number
      orderId: number | null
      purchaseLogId: number | null
      createdBy: number
      noteType: $Enums.NoteType
      subject: string | null
      content: string
      followUpDate: Date | null
      isImportant: boolean
      tags: string | null
      attachmentPath: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactNote"]>
    composites: {}
  }

  type ContactNoteGetPayload<S extends boolean | null | undefined | ContactNoteDefaultArgs> = $Result.GetResult<Prisma.$ContactNotePayload, S>

  type ContactNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactNoteCountAggregateInputType | true
    }

  export interface ContactNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactNote'], meta: { name: 'ContactNote' } }
    /**
     * Find zero or one ContactNote that matches the filter.
     * @param {ContactNoteFindUniqueArgs} args - Arguments to find a ContactNote
     * @example
     * // Get one ContactNote
     * const contactNote = await prisma.contactNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactNoteFindUniqueArgs>(args: SelectSubset<T, ContactNoteFindUniqueArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactNoteFindUniqueOrThrowArgs} args - Arguments to find a ContactNote
     * @example
     * // Get one ContactNote
     * const contactNote = await prisma.contactNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteFindFirstArgs} args - Arguments to find a ContactNote
     * @example
     * // Get one ContactNote
     * const contactNote = await prisma.contactNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactNoteFindFirstArgs>(args?: SelectSubset<T, ContactNoteFindFirstArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteFindFirstOrThrowArgs} args - Arguments to find a ContactNote
     * @example
     * // Get one ContactNote
     * const contactNote = await prisma.contactNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactNotes
     * const contactNotes = await prisma.contactNote.findMany()
     * 
     * // Get first 10 ContactNotes
     * const contactNotes = await prisma.contactNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactNoteWithIdOnly = await prisma.contactNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactNoteFindManyArgs>(args?: SelectSubset<T, ContactNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactNote.
     * @param {ContactNoteCreateArgs} args - Arguments to create a ContactNote.
     * @example
     * // Create one ContactNote
     * const ContactNote = await prisma.contactNote.create({
     *   data: {
     *     // ... data to create a ContactNote
     *   }
     * })
     * 
     */
    create<T extends ContactNoteCreateArgs>(args: SelectSubset<T, ContactNoteCreateArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactNotes.
     * @param {ContactNoteCreateManyArgs} args - Arguments to create many ContactNotes.
     * @example
     * // Create many ContactNotes
     * const contactNote = await prisma.contactNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactNoteCreateManyArgs>(args?: SelectSubset<T, ContactNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactNotes and returns the data saved in the database.
     * @param {ContactNoteCreateManyAndReturnArgs} args - Arguments to create many ContactNotes.
     * @example
     * // Create many ContactNotes
     * const contactNote = await prisma.contactNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactNotes and only return the `id`
     * const contactNoteWithIdOnly = await prisma.contactNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactNote.
     * @param {ContactNoteDeleteArgs} args - Arguments to delete one ContactNote.
     * @example
     * // Delete one ContactNote
     * const ContactNote = await prisma.contactNote.delete({
     *   where: {
     *     // ... filter to delete one ContactNote
     *   }
     * })
     * 
     */
    delete<T extends ContactNoteDeleteArgs>(args: SelectSubset<T, ContactNoteDeleteArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactNote.
     * @param {ContactNoteUpdateArgs} args - Arguments to update one ContactNote.
     * @example
     * // Update one ContactNote
     * const contactNote = await prisma.contactNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactNoteUpdateArgs>(args: SelectSubset<T, ContactNoteUpdateArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactNotes.
     * @param {ContactNoteDeleteManyArgs} args - Arguments to filter ContactNotes to delete.
     * @example
     * // Delete a few ContactNotes
     * const { count } = await prisma.contactNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactNoteDeleteManyArgs>(args?: SelectSubset<T, ContactNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactNotes
     * const contactNote = await prisma.contactNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactNoteUpdateManyArgs>(args: SelectSubset<T, ContactNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactNotes and returns the data updated in the database.
     * @param {ContactNoteUpdateManyAndReturnArgs} args - Arguments to update many ContactNotes.
     * @example
     * // Update many ContactNotes
     * const contactNote = await prisma.contactNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactNotes and only return the `id`
     * const contactNoteWithIdOnly = await prisma.contactNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactNote.
     * @param {ContactNoteUpsertArgs} args - Arguments to update or create a ContactNote.
     * @example
     * // Update or create a ContactNote
     * const contactNote = await prisma.contactNote.upsert({
     *   create: {
     *     // ... data to create a ContactNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactNote we want to update
     *   }
     * })
     */
    upsert<T extends ContactNoteUpsertArgs>(args: SelectSubset<T, ContactNoteUpsertArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteCountArgs} args - Arguments to filter ContactNotes to count.
     * @example
     * // Count the number of ContactNotes
     * const count = await prisma.contactNote.count({
     *   where: {
     *     // ... the filter for the ContactNotes we want to count
     *   }
     * })
    **/
    count<T extends ContactNoteCountArgs>(
      args?: Subset<T, ContactNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactNoteAggregateArgs>(args: Subset<T, ContactNoteAggregateArgs>): Prisma.PrismaPromise<GetContactNoteAggregateType<T>>

    /**
     * Group by ContactNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactNoteGroupByArgs['orderBy'] }
        : { orderBy?: ContactNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactNote model
   */
  readonly fields: ContactNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends ContactNote$orderArgs<ExtArgs> = {}>(args?: Subset<T, ContactNote$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchaseLog<T extends ContactNote$purchaseLogArgs<ExtArgs> = {}>(args?: Subset<T, ContactNote$purchaseLogArgs<ExtArgs>>): Prisma__PurchaseLogClient<$Result.GetResult<Prisma.$PurchaseLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactNote model
   */
  interface ContactNoteFieldRefs {
    readonly id: FieldRef<"ContactNote", 'Int'>
    readonly contactId: FieldRef<"ContactNote", 'Int'>
    readonly orderId: FieldRef<"ContactNote", 'Int'>
    readonly purchaseLogId: FieldRef<"ContactNote", 'Int'>
    readonly createdBy: FieldRef<"ContactNote", 'Int'>
    readonly noteType: FieldRef<"ContactNote", 'NoteType'>
    readonly subject: FieldRef<"ContactNote", 'String'>
    readonly content: FieldRef<"ContactNote", 'String'>
    readonly followUpDate: FieldRef<"ContactNote", 'DateTime'>
    readonly isImportant: FieldRef<"ContactNote", 'Boolean'>
    readonly tags: FieldRef<"ContactNote", 'String'>
    readonly attachmentPath: FieldRef<"ContactNote", 'String'>
    readonly isActive: FieldRef<"ContactNote", 'Boolean'>
    readonly createdAt: FieldRef<"ContactNote", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactNote findUnique
   */
  export type ContactNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * Filter, which ContactNote to fetch.
     */
    where: ContactNoteWhereUniqueInput
  }

  /**
   * ContactNote findUniqueOrThrow
   */
  export type ContactNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * Filter, which ContactNote to fetch.
     */
    where: ContactNoteWhereUniqueInput
  }

  /**
   * ContactNote findFirst
   */
  export type ContactNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * Filter, which ContactNote to fetch.
     */
    where?: ContactNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactNotes to fetch.
     */
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactNotes.
     */
    cursor?: ContactNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactNotes.
     */
    distinct?: ContactNoteScalarFieldEnum | ContactNoteScalarFieldEnum[]
  }

  /**
   * ContactNote findFirstOrThrow
   */
  export type ContactNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * Filter, which ContactNote to fetch.
     */
    where?: ContactNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactNotes to fetch.
     */
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactNotes.
     */
    cursor?: ContactNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactNotes.
     */
    distinct?: ContactNoteScalarFieldEnum | ContactNoteScalarFieldEnum[]
  }

  /**
   * ContactNote findMany
   */
  export type ContactNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * Filter, which ContactNotes to fetch.
     */
    where?: ContactNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactNotes to fetch.
     */
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactNotes.
     */
    cursor?: ContactNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactNotes.
     */
    skip?: number
    distinct?: ContactNoteScalarFieldEnum | ContactNoteScalarFieldEnum[]
  }

  /**
   * ContactNote create
   */
  export type ContactNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactNote.
     */
    data: XOR<ContactNoteCreateInput, ContactNoteUncheckedCreateInput>
  }

  /**
   * ContactNote createMany
   */
  export type ContactNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactNotes.
     */
    data: ContactNoteCreateManyInput | ContactNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactNote createManyAndReturn
   */
  export type ContactNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * The data used to create many ContactNotes.
     */
    data: ContactNoteCreateManyInput | ContactNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactNote update
   */
  export type ContactNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactNote.
     */
    data: XOR<ContactNoteUpdateInput, ContactNoteUncheckedUpdateInput>
    /**
     * Choose, which ContactNote to update.
     */
    where: ContactNoteWhereUniqueInput
  }

  /**
   * ContactNote updateMany
   */
  export type ContactNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactNotes.
     */
    data: XOR<ContactNoteUpdateManyMutationInput, ContactNoteUncheckedUpdateManyInput>
    /**
     * Filter which ContactNotes to update
     */
    where?: ContactNoteWhereInput
    /**
     * Limit how many ContactNotes to update.
     */
    limit?: number
  }

  /**
   * ContactNote updateManyAndReturn
   */
  export type ContactNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * The data used to update ContactNotes.
     */
    data: XOR<ContactNoteUpdateManyMutationInput, ContactNoteUncheckedUpdateManyInput>
    /**
     * Filter which ContactNotes to update
     */
    where?: ContactNoteWhereInput
    /**
     * Limit how many ContactNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactNote upsert
   */
  export type ContactNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactNote to update in case it exists.
     */
    where: ContactNoteWhereUniqueInput
    /**
     * In case the ContactNote found by the `where` argument doesn't exist, create a new ContactNote with this data.
     */
    create: XOR<ContactNoteCreateInput, ContactNoteUncheckedCreateInput>
    /**
     * In case the ContactNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactNoteUpdateInput, ContactNoteUncheckedUpdateInput>
  }

  /**
   * ContactNote delete
   */
  export type ContactNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * Filter which ContactNote to delete.
     */
    where: ContactNoteWhereUniqueInput
  }

  /**
   * ContactNote deleteMany
   */
  export type ContactNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactNotes to delete
     */
    where?: ContactNoteWhereInput
    /**
     * Limit how many ContactNotes to delete.
     */
    limit?: number
  }

  /**
   * ContactNote.order
   */
  export type ContactNote$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * ContactNote.purchaseLog
   */
  export type ContactNote$purchaseLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLog
     */
    select?: PurchaseLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLog
     */
    omit?: PurchaseLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLogInclude<ExtArgs> | null
    where?: PurchaseLogWhereInput
  }

  /**
   * ContactNote without action
   */
  export type ContactNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    whatsappPhone: 'whatsappPhone',
    passwordHash: 'passwordHash',
    role: 'role',
    isActive: 'isActive',
    loginEnabled: 'loginEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    code: 'code',
    unit: 'unit',
    qtyOnHand: 'qtyOnHand',
    minStock: 'minStock',
    maxStock: 'maxStock',
    reorderPoint: 'reorderPoint',
    reorderQty: 'reorderQty',
    location: 'location',
    attributeType: 'attributeType',
    attributeValue: 'attributeValue',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    materialId: 'materialId',
    category: 'category',
    price: 'price',
    qtyOnHand: 'qtyOnHand',
    unit: 'unit',
    description: 'description',
    defaultTarget: 'defaultTarget',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    status: 'status',
    targetPcs: 'targetPcs',
    completedPcs: 'completedPcs',
    customerNote: 'customerNote',
    dueDate: 'dueDate',
    userId: 'userId',
    workerId: 'workerId',
    workerContactId: 'workerContactId',
    description: 'description',
    priority: 'priority',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderProductScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    notes: 'notes',
    completedQty: 'completedQty',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderProductScalarFieldEnum = (typeof OrderProductScalarFieldEnum)[keyof typeof OrderProductScalarFieldEnum]


  export const MaterialMovementScalarFieldEnum: {
    id: 'id',
    materialId: 'materialId',
    orderId: 'orderId',
    userId: 'userId',
    purchaseLogId: 'purchaseLogId',
    movementType: 'movementType',
    quantity: 'quantity',
    unit: 'unit',
    costPerUnit: 'costPerUnit',
    totalCost: 'totalCost',
    notes: 'notes',
    qtyAfter: 'qtyAfter',
    movementDate: 'movementDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterialMovementScalarFieldEnum = (typeof MaterialMovementScalarFieldEnum)[keyof typeof MaterialMovementScalarFieldEnum]


  export const ProgressReportScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    orderProductId: 'orderProductId',
    productId: 'productId',
    userId: 'userId',
    reportText: 'reportText',
    photoPath: 'photoPath',
    percentage: 'percentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgressReportScalarFieldEnum = (typeof ProgressReportScalarFieldEnum)[keyof typeof ProgressReportScalarFieldEnum]


  export const ProductProgressReportScalarFieldEnum: {
    id: 'id',
    progressReportId: 'progressReportId',
    productId: 'productId',
    orderProductId: 'orderProductId',
    itemsCompleted: 'itemsCompleted',
    itemsTarget: 'itemsTarget',
    status: 'status',
    notes: 'notes',
    completionDate: 'completionDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductProgressReportScalarFieldEnum = (typeof ProductProgressReportScalarFieldEnum)[keyof typeof ProductProgressReportScalarFieldEnum]


  export const ProductProgressPhotoScalarFieldEnum: {
    id: 'id',
    productProgressReportId: 'productProgressReportId',
    photoPath: 'photoPath',
    thumbnailPath: 'thumbnailPath',
    description: 'description',
    uploadDate: 'uploadDate',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductProgressPhotoScalarFieldEnum = (typeof ProductProgressPhotoScalarFieldEnum)[keyof typeof ProductProgressPhotoScalarFieldEnum]


  export const RemainingMaterialScalarFieldEnum: {
    id: 'id',
    materialId: 'materialId',
    quantity: 'quantity',
    unit: 'unit',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RemainingMaterialScalarFieldEnum = (typeof RemainingMaterialScalarFieldEnum)[keyof typeof RemainingMaterialScalarFieldEnum]


  export const InventarisScalarFieldEnum: {
    id: 'id',
    name: 'name',
    quantity: 'quantity',
    unit: 'unit',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventarisScalarFieldEnum = (typeof InventarisScalarFieldEnum)[keyof typeof InventarisScalarFieldEnum]


  export const OrderLinkScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    userId: 'userId',
    linkToken: 'linkToken',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderLinkScalarFieldEnum = (typeof OrderLinkScalarFieldEnum)[keyof typeof OrderLinkScalarFieldEnum]


  export const ProductMaterialScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    materialId: 'materialId',
    quantity: 'quantity',
    unit: 'unit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductMaterialScalarFieldEnum = (typeof ProductMaterialScalarFieldEnum)[keyof typeof ProductMaterialScalarFieldEnum]


  export const ShipmentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    trackingNumber: 'trackingNumber',
    carrier: 'carrier',
    shippedDate: 'shippedDate',
    deliveredDate: 'deliveredDate',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShipmentScalarFieldEnum = (typeof ShipmentScalarFieldEnum)[keyof typeof ShipmentScalarFieldEnum]


  export const RecurringPlanScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    quantity: 'quantity',
    frequency: 'frequency',
    isActive: 'isActive',
    nextDue: 'nextDue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecurringPlanScalarFieldEnum = (typeof RecurringPlanScalarFieldEnum)[keyof typeof RecurringPlanScalarFieldEnum]


  export const StatusChangeScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    changedBy: 'changedBy',
    fromStatus: 'fromStatus',
    toStatus: 'toStatus',
    reason: 'reason',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatusChangeScalarFieldEnum = (typeof StatusChangeScalarFieldEnum)[keyof typeof StatusChangeScalarFieldEnum]


  export const ProductColourScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    colorName: 'colorName',
    colorCode: 'colorCode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductColourScalarFieldEnum = (typeof ProductColourScalarFieldEnum)[keyof typeof ProductColourScalarFieldEnum]


  export const ProductVariationScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    variationType: 'variationType',
    variationValue: 'variationValue',
    priceAdjustment: 'priceAdjustment',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVariationScalarFieldEnum = (typeof ProductVariationScalarFieldEnum)[keyof typeof ProductVariationScalarFieldEnum]


  export const ProductPhotoScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    photoPath: 'photoPath',
    thumbnailPath: 'thumbnailPath',
    description: 'description',
    isPrimary: 'isPrimary',
    sortOrder: 'sortOrder',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductPhotoScalarFieldEnum = (typeof ProductPhotoScalarFieldEnum)[keyof typeof ProductPhotoScalarFieldEnum]


  export const MaterialPurchaseAlertScalarFieldEnum: {
    id: 'id',
    materialId: 'materialId',
    orderId: 'orderId',
    alertType: 'alertType',
    requiredQuantity: 'requiredQuantity',
    currentStock: 'currentStock',
    urgencyLevel: 'urgencyLevel',
    message: 'message',
    status: 'status',
    createdBy: 'createdBy',
    resolvedBy: 'resolvedBy',
    resolvedAt: 'resolvedAt',
    resolution: 'resolution',
    estimatedCost: 'estimatedCost',
    suggestedSupplier: 'suggestedSupplier',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterialPurchaseAlertScalarFieldEnum = (typeof MaterialPurchaseAlertScalarFieldEnum)[keyof typeof MaterialPurchaseAlertScalarFieldEnum]


  export const PurchaseLogScalarFieldEnum: {
    id: 'id',
    materialId: 'materialId',
    supplier: 'supplier',
    quantity: 'quantity',
    unit: 'unit',
    pricePerUnit: 'pricePerUnit',
    totalCost: 'totalCost',
    purchaseDate: 'purchaseDate',
    invoiceNumber: 'invoiceNumber',
    receiptPath: 'receiptPath',
    notes: 'notes',
    status: 'status',
    deliveryDate: 'deliveryDate',
    receivedQuantity: 'receivedQuantity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseLogScalarFieldEnum = (typeof PurchaseLogScalarFieldEnum)[keyof typeof PurchaseLogScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    whatsappPhone: 'whatsappPhone',
    email: 'email',
    address: 'address',
    contactType: 'contactType',
    company: 'company',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ContactNoteScalarFieldEnum: {
    id: 'id',
    contactId: 'contactId',
    orderId: 'orderId',
    purchaseLogId: 'purchaseLogId',
    createdBy: 'createdBy',
    noteType: 'noteType',
    subject: 'subject',
    content: 'content',
    followUpDate: 'followUpDate',
    isImportant: 'isImportant',
    tags: 'tags',
    attachmentPath: 'attachmentPath',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactNoteScalarFieldEnum = (typeof ContactNoteScalarFieldEnum)[keyof typeof ContactNoteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'OrderProductStatus'
   */
  export type EnumOrderProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderProductStatus'>
    


  /**
   * Reference to a field of type 'OrderProductStatus[]'
   */
  export type ListEnumOrderProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderProductStatus[]'>
    


  /**
   * Reference to a field of type 'MaterialMovementType'
   */
  export type EnumMaterialMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialMovementType'>
    


  /**
   * Reference to a field of type 'MaterialMovementType[]'
   */
  export type ListEnumMaterialMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialMovementType[]'>
    


  /**
   * Reference to a field of type 'ShipmentStatus'
   */
  export type EnumShipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShipmentStatus'>
    


  /**
   * Reference to a field of type 'ShipmentStatus[]'
   */
  export type ListEnumShipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShipmentStatus[]'>
    


  /**
   * Reference to a field of type 'MaterialPurchaseAlertType'
   */
  export type EnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialPurchaseAlertType'>
    


  /**
   * Reference to a field of type 'MaterialPurchaseAlertType[]'
   */
  export type ListEnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialPurchaseAlertType[]'>
    


  /**
   * Reference to a field of type 'UrgencyLevel'
   */
  export type EnumUrgencyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UrgencyLevel'>
    


  /**
   * Reference to a field of type 'UrgencyLevel[]'
   */
  export type ListEnumUrgencyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UrgencyLevel[]'>
    


  /**
   * Reference to a field of type 'AlertStatus'
   */
  export type EnumAlertStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertStatus'>
    


  /**
   * Reference to a field of type 'AlertStatus[]'
   */
  export type ListEnumAlertStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertStatus[]'>
    


  /**
   * Reference to a field of type 'PurchaseStatus'
   */
  export type EnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus'>
    


  /**
   * Reference to a field of type 'PurchaseStatus[]'
   */
  export type ListEnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus[]'>
    


  /**
   * Reference to a field of type 'ContactType'
   */
  export type EnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType'>
    


  /**
   * Reference to a field of type 'ContactType[]'
   */
  export type ListEnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType[]'>
    


  /**
   * Reference to a field of type 'NoteType'
   */
  export type EnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType'>
    


  /**
   * Reference to a field of type 'NoteType[]'
   */
  export type ListEnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    whatsappPhone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    loginEnabled?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    orders?: OrderListRelationFilter
    workerOrders?: OrderListRelationFilter
    materialMovements?: MaterialMovementListRelationFilter
    progressReports?: ProgressReportListRelationFilter
    orderLinks?: OrderLinkListRelationFilter
    statusChanges?: StatusChangeListRelationFilter
    createdAlerts?: MaterialPurchaseAlertListRelationFilter
    resolvedAlerts?: MaterialPurchaseAlertListRelationFilter
    createdContactNotes?: ContactNoteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    whatsappPhone?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    loginEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    workerOrders?: OrderOrderByRelationAggregateInput
    materialMovements?: MaterialMovementOrderByRelationAggregateInput
    progressReports?: ProgressReportOrderByRelationAggregateInput
    orderLinks?: OrderLinkOrderByRelationAggregateInput
    statusChanges?: StatusChangeOrderByRelationAggregateInput
    createdAlerts?: MaterialPurchaseAlertOrderByRelationAggregateInput
    resolvedAlerts?: MaterialPurchaseAlertOrderByRelationAggregateInput
    createdContactNotes?: ContactNoteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    whatsappPhone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    loginEnabled?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    orders?: OrderListRelationFilter
    workerOrders?: OrderListRelationFilter
    materialMovements?: MaterialMovementListRelationFilter
    progressReports?: ProgressReportListRelationFilter
    orderLinks?: OrderLinkListRelationFilter
    statusChanges?: StatusChangeListRelationFilter
    createdAlerts?: MaterialPurchaseAlertListRelationFilter
    resolvedAlerts?: MaterialPurchaseAlertListRelationFilter
    createdContactNotes?: ContactNoteListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    whatsappPhone?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    loginEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    whatsappPhone?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    loginEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: IntFilter<"Material"> | number
    name?: StringFilter<"Material"> | string
    description?: StringNullableFilter<"Material"> | string | null
    code?: StringFilter<"Material"> | string
    unit?: StringFilter<"Material"> | string
    qtyOnHand?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    location?: StringNullableFilter<"Material"> | string | null
    attributeType?: StringNullableFilter<"Material"> | string | null
    attributeValue?: StringNullableFilter<"Material"> | string | null
    isActive?: BoolFilter<"Material"> | boolean
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    materialMovements?: MaterialMovementListRelationFilter
    productMaterials?: ProductMaterialListRelationFilter
    remainingMaterials?: RemainingMaterialListRelationFilter
    products?: ProductListRelationFilter
    purchaseAlerts?: MaterialPurchaseAlertListRelationFilter
    purchaseLogs?: PurchaseLogListRelationFilter
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrder
    unit?: SortOrder
    qtyOnHand?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
    location?: SortOrderInput | SortOrder
    attributeType?: SortOrderInput | SortOrder
    attributeValue?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    materialMovements?: MaterialMovementOrderByRelationAggregateInput
    productMaterials?: ProductMaterialOrderByRelationAggregateInput
    remainingMaterials?: RemainingMaterialOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    purchaseAlerts?: MaterialPurchaseAlertOrderByRelationAggregateInput
    purchaseLogs?: PurchaseLogOrderByRelationAggregateInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    name?: StringFilter<"Material"> | string
    description?: StringNullableFilter<"Material"> | string | null
    unit?: StringFilter<"Material"> | string
    qtyOnHand?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    location?: StringNullableFilter<"Material"> | string | null
    attributeType?: StringNullableFilter<"Material"> | string | null
    attributeValue?: StringNullableFilter<"Material"> | string | null
    isActive?: BoolFilter<"Material"> | boolean
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    materialMovements?: MaterialMovementListRelationFilter
    productMaterials?: ProductMaterialListRelationFilter
    remainingMaterials?: RemainingMaterialListRelationFilter
    products?: ProductListRelationFilter
    purchaseAlerts?: MaterialPurchaseAlertListRelationFilter
    purchaseLogs?: PurchaseLogListRelationFilter
  }, "id" | "code">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrder
    unit?: SortOrder
    qtyOnHand?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
    location?: SortOrderInput | SortOrder
    attributeType?: SortOrderInput | SortOrder
    attributeValue?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Material"> | number
    name?: StringWithAggregatesFilter<"Material"> | string
    description?: StringNullableWithAggregatesFilter<"Material"> | string | null
    code?: StringWithAggregatesFilter<"Material"> | string
    unit?: StringWithAggregatesFilter<"Material"> | string
    qtyOnHand?: DecimalWithAggregatesFilter<"Material"> | Decimal | DecimalJsLike | number | string
    minStock?: DecimalWithAggregatesFilter<"Material"> | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalWithAggregatesFilter<"Material"> | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalWithAggregatesFilter<"Material"> | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalWithAggregatesFilter<"Material"> | Decimal | DecimalJsLike | number | string
    location?: StringNullableWithAggregatesFilter<"Material"> | string | null
    attributeType?: StringNullableWithAggregatesFilter<"Material"> | string | null
    attributeValue?: StringNullableWithAggregatesFilter<"Material"> | string | null
    isActive?: BoolWithAggregatesFilter<"Material"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    code?: StringFilter<"Product"> | string
    materialId?: IntNullableFilter<"Product"> | number | null
    category?: StringNullableFilter<"Product"> | string | null
    price?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFilter<"Product"> | number
    unit?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    defaultTarget?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    baseMaterial?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    orderProducts?: OrderProductListRelationFilter
    productMaterials?: ProductMaterialListRelationFilter
    recurringPlans?: RecurringPlanListRelationFilter
    colours?: ProductColourListRelationFilter
    variations?: ProductVariationListRelationFilter
    photos?: ProductPhotoListRelationFilter
    individualProgressReports?: ProgressReportListRelationFilter
    productProgressReports?: ProductProgressReportListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    materialId?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    qtyOnHand?: SortOrder
    unit?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultTarget?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    baseMaterial?: MaterialOrderByWithRelationInput
    orderProducts?: OrderProductOrderByRelationAggregateInput
    productMaterials?: ProductMaterialOrderByRelationAggregateInput
    recurringPlans?: RecurringPlanOrderByRelationAggregateInput
    colours?: ProductColourOrderByRelationAggregateInput
    variations?: ProductVariationOrderByRelationAggregateInput
    photos?: ProductPhotoOrderByRelationAggregateInput
    individualProgressReports?: ProgressReportOrderByRelationAggregateInput
    productProgressReports?: ProductProgressReportOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    materialId?: IntNullableFilter<"Product"> | number | null
    category?: StringNullableFilter<"Product"> | string | null
    price?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFilter<"Product"> | number
    unit?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    defaultTarget?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    baseMaterial?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    orderProducts?: OrderProductListRelationFilter
    productMaterials?: ProductMaterialListRelationFilter
    recurringPlans?: RecurringPlanListRelationFilter
    colours?: ProductColourListRelationFilter
    variations?: ProductVariationListRelationFilter
    photos?: ProductPhotoListRelationFilter
    individualProgressReports?: ProgressReportListRelationFilter
    productProgressReports?: ProductProgressReportListRelationFilter
  }, "id" | "code">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    materialId?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    qtyOnHand?: SortOrder
    unit?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultTarget?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    code?: StringWithAggregatesFilter<"Product"> | string
    materialId?: IntNullableWithAggregatesFilter<"Product"> | number | null
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntWithAggregatesFilter<"Product"> | number
    unit?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    defaultTarget?: IntWithAggregatesFilter<"Product"> | number
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    orderNumber?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    targetPcs?: IntFilter<"Order"> | number
    completedPcs?: IntFilter<"Order"> | number
    customerNote?: StringNullableFilter<"Order"> | string | null
    dueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    userId?: IntFilter<"Order"> | number
    workerId?: IntNullableFilter<"Order"> | number | null
    workerContactId?: IntNullableFilter<"Order"> | number | null
    description?: StringNullableFilter<"Order"> | string | null
    priority?: EnumPriorityFilter<"Order"> | $Enums.Priority
    isActive?: BoolFilter<"Order"> | boolean
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    worker?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    workerContact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    orderProducts?: OrderProductListRelationFilter
    materialMovements?: MaterialMovementListRelationFilter
    progressReports?: ProgressReportListRelationFilter
    orderLink?: XOR<OrderLinkNullableScalarRelationFilter, OrderLinkWhereInput> | null
    shipment?: XOR<ShipmentNullableScalarRelationFilter, ShipmentWhereInput> | null
    statusChanges?: StatusChangeListRelationFilter
    purchaseAlerts?: MaterialPurchaseAlertListRelationFilter
    contactNotes?: ContactNoteListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    targetPcs?: SortOrder
    completedPcs?: SortOrder
    customerNote?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    userId?: SortOrder
    workerId?: SortOrderInput | SortOrder
    workerContactId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    worker?: UserOrderByWithRelationInput
    workerContact?: ContactOrderByWithRelationInput
    orderProducts?: OrderProductOrderByRelationAggregateInput
    materialMovements?: MaterialMovementOrderByRelationAggregateInput
    progressReports?: ProgressReportOrderByRelationAggregateInput
    orderLink?: OrderLinkOrderByWithRelationInput
    shipment?: ShipmentOrderByWithRelationInput
    statusChanges?: StatusChangeOrderByRelationAggregateInput
    purchaseAlerts?: MaterialPurchaseAlertOrderByRelationAggregateInput
    contactNotes?: ContactNoteOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderNumber?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    targetPcs?: IntFilter<"Order"> | number
    completedPcs?: IntFilter<"Order"> | number
    customerNote?: StringNullableFilter<"Order"> | string | null
    dueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    userId?: IntFilter<"Order"> | number
    workerId?: IntNullableFilter<"Order"> | number | null
    workerContactId?: IntNullableFilter<"Order"> | number | null
    description?: StringNullableFilter<"Order"> | string | null
    priority?: EnumPriorityFilter<"Order"> | $Enums.Priority
    isActive?: BoolFilter<"Order"> | boolean
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    worker?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    workerContact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    orderProducts?: OrderProductListRelationFilter
    materialMovements?: MaterialMovementListRelationFilter
    progressReports?: ProgressReportListRelationFilter
    orderLink?: XOR<OrderLinkNullableScalarRelationFilter, OrderLinkWhereInput> | null
    shipment?: XOR<ShipmentNullableScalarRelationFilter, ShipmentWhereInput> | null
    statusChanges?: StatusChangeListRelationFilter
    purchaseAlerts?: MaterialPurchaseAlertListRelationFilter
    contactNotes?: ContactNoteListRelationFilter
  }, "id" | "orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    targetPcs?: SortOrder
    completedPcs?: SortOrder
    customerNote?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    userId?: SortOrder
    workerId?: SortOrderInput | SortOrder
    workerContactId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    targetPcs?: IntWithAggregatesFilter<"Order"> | number
    completedPcs?: IntWithAggregatesFilter<"Order"> | number
    customerNote?: StringNullableWithAggregatesFilter<"Order"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    userId?: IntWithAggregatesFilter<"Order"> | number
    workerId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    workerContactId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    description?: StringNullableWithAggregatesFilter<"Order"> | string | null
    priority?: EnumPriorityWithAggregatesFilter<"Order"> | $Enums.Priority
    isActive?: BoolWithAggregatesFilter<"Order"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderProductWhereInput = {
    AND?: OrderProductWhereInput | OrderProductWhereInput[]
    OR?: OrderProductWhereInput[]
    NOT?: OrderProductWhereInput | OrderProductWhereInput[]
    id?: IntFilter<"OrderProduct"> | number
    orderId?: IntFilter<"OrderProduct"> | number
    productId?: IntFilter<"OrderProduct"> | number
    quantity?: IntFilter<"OrderProduct"> | number
    unitPrice?: DecimalNullableFilter<"OrderProduct"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"OrderProduct"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"OrderProduct"> | string | null
    completedQty?: IntFilter<"OrderProduct"> | number
    status?: EnumOrderProductStatusFilter<"OrderProduct"> | $Enums.OrderProductStatus
    createdAt?: DateTimeFilter<"OrderProduct"> | Date | string
    updatedAt?: DateTimeFilter<"OrderProduct"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    individualProgressReports?: ProgressReportListRelationFilter
    productProgressReports?: ProductProgressReportListRelationFilter
  }

  export type OrderProductOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    completedQty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    individualProgressReports?: ProgressReportOrderByRelationAggregateInput
    productProgressReports?: ProductProgressReportOrderByRelationAggregateInput
  }

  export type OrderProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderProductWhereInput | OrderProductWhereInput[]
    OR?: OrderProductWhereInput[]
    NOT?: OrderProductWhereInput | OrderProductWhereInput[]
    orderId?: IntFilter<"OrderProduct"> | number
    productId?: IntFilter<"OrderProduct"> | number
    quantity?: IntFilter<"OrderProduct"> | number
    unitPrice?: DecimalNullableFilter<"OrderProduct"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"OrderProduct"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"OrderProduct"> | string | null
    completedQty?: IntFilter<"OrderProduct"> | number
    status?: EnumOrderProductStatusFilter<"OrderProduct"> | $Enums.OrderProductStatus
    createdAt?: DateTimeFilter<"OrderProduct"> | Date | string
    updatedAt?: DateTimeFilter<"OrderProduct"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    individualProgressReports?: ProgressReportListRelationFilter
    productProgressReports?: ProductProgressReportListRelationFilter
  }, "id">

  export type OrderProductOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    completedQty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderProductCountOrderByAggregateInput
    _avg?: OrderProductAvgOrderByAggregateInput
    _max?: OrderProductMaxOrderByAggregateInput
    _min?: OrderProductMinOrderByAggregateInput
    _sum?: OrderProductSumOrderByAggregateInput
  }

  export type OrderProductScalarWhereWithAggregatesInput = {
    AND?: OrderProductScalarWhereWithAggregatesInput | OrderProductScalarWhereWithAggregatesInput[]
    OR?: OrderProductScalarWhereWithAggregatesInput[]
    NOT?: OrderProductScalarWhereWithAggregatesInput | OrderProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderProduct"> | number
    orderId?: IntWithAggregatesFilter<"OrderProduct"> | number
    productId?: IntWithAggregatesFilter<"OrderProduct"> | number
    quantity?: IntWithAggregatesFilter<"OrderProduct"> | number
    unitPrice?: DecimalNullableWithAggregatesFilter<"OrderProduct"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableWithAggregatesFilter<"OrderProduct"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"OrderProduct"> | string | null
    completedQty?: IntWithAggregatesFilter<"OrderProduct"> | number
    status?: EnumOrderProductStatusWithAggregatesFilter<"OrderProduct"> | $Enums.OrderProductStatus
    createdAt?: DateTimeWithAggregatesFilter<"OrderProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderProduct"> | Date | string
  }

  export type MaterialMovementWhereInput = {
    AND?: MaterialMovementWhereInput | MaterialMovementWhereInput[]
    OR?: MaterialMovementWhereInput[]
    NOT?: MaterialMovementWhereInput | MaterialMovementWhereInput[]
    id?: IntFilter<"MaterialMovement"> | number
    materialId?: IntFilter<"MaterialMovement"> | number
    orderId?: IntNullableFilter<"MaterialMovement"> | number | null
    userId?: IntFilter<"MaterialMovement"> | number
    purchaseLogId?: IntNullableFilter<"MaterialMovement"> | number | null
    movementType?: EnumMaterialMovementTypeFilter<"MaterialMovement"> | $Enums.MaterialMovementType
    quantity?: DecimalFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"MaterialMovement"> | string
    costPerUnit?: DecimalNullableFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"MaterialMovement"> | string | null
    qtyAfter?: DecimalFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFilter<"MaterialMovement"> | Date | string
    isActive?: BoolFilter<"MaterialMovement"> | boolean
    createdAt?: DateTimeFilter<"MaterialMovement"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialMovement"> | Date | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    purchaseLog?: XOR<PurchaseLogNullableScalarRelationFilter, PurchaseLogWhereInput> | null
  }

  export type MaterialMovementOrderByWithRelationInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    userId?: SortOrder
    purchaseLogId?: SortOrderInput | SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    costPerUnit?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    qtyAfter?: SortOrder
    movementDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    material?: MaterialOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    purchaseLog?: PurchaseLogOrderByWithRelationInput
  }

  export type MaterialMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    purchaseLogId?: number
    AND?: MaterialMovementWhereInput | MaterialMovementWhereInput[]
    OR?: MaterialMovementWhereInput[]
    NOT?: MaterialMovementWhereInput | MaterialMovementWhereInput[]
    materialId?: IntFilter<"MaterialMovement"> | number
    orderId?: IntNullableFilter<"MaterialMovement"> | number | null
    userId?: IntFilter<"MaterialMovement"> | number
    movementType?: EnumMaterialMovementTypeFilter<"MaterialMovement"> | $Enums.MaterialMovementType
    quantity?: DecimalFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"MaterialMovement"> | string
    costPerUnit?: DecimalNullableFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"MaterialMovement"> | string | null
    qtyAfter?: DecimalFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFilter<"MaterialMovement"> | Date | string
    isActive?: BoolFilter<"MaterialMovement"> | boolean
    createdAt?: DateTimeFilter<"MaterialMovement"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialMovement"> | Date | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    purchaseLog?: XOR<PurchaseLogNullableScalarRelationFilter, PurchaseLogWhereInput> | null
  }, "id" | "purchaseLogId">

  export type MaterialMovementOrderByWithAggregationInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    userId?: SortOrder
    purchaseLogId?: SortOrderInput | SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    costPerUnit?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    qtyAfter?: SortOrder
    movementDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterialMovementCountOrderByAggregateInput
    _avg?: MaterialMovementAvgOrderByAggregateInput
    _max?: MaterialMovementMaxOrderByAggregateInput
    _min?: MaterialMovementMinOrderByAggregateInput
    _sum?: MaterialMovementSumOrderByAggregateInput
  }

  export type MaterialMovementScalarWhereWithAggregatesInput = {
    AND?: MaterialMovementScalarWhereWithAggregatesInput | MaterialMovementScalarWhereWithAggregatesInput[]
    OR?: MaterialMovementScalarWhereWithAggregatesInput[]
    NOT?: MaterialMovementScalarWhereWithAggregatesInput | MaterialMovementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaterialMovement"> | number
    materialId?: IntWithAggregatesFilter<"MaterialMovement"> | number
    orderId?: IntNullableWithAggregatesFilter<"MaterialMovement"> | number | null
    userId?: IntWithAggregatesFilter<"MaterialMovement"> | number
    purchaseLogId?: IntNullableWithAggregatesFilter<"MaterialMovement"> | number | null
    movementType?: EnumMaterialMovementTypeWithAggregatesFilter<"MaterialMovement"> | $Enums.MaterialMovementType
    quantity?: DecimalWithAggregatesFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"MaterialMovement"> | string
    costPerUnit?: DecimalNullableWithAggregatesFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableWithAggregatesFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"MaterialMovement"> | string | null
    qtyAfter?: DecimalWithAggregatesFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeWithAggregatesFilter<"MaterialMovement"> | Date | string
    isActive?: BoolWithAggregatesFilter<"MaterialMovement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MaterialMovement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaterialMovement"> | Date | string
  }

  export type ProgressReportWhereInput = {
    AND?: ProgressReportWhereInput | ProgressReportWhereInput[]
    OR?: ProgressReportWhereInput[]
    NOT?: ProgressReportWhereInput | ProgressReportWhereInput[]
    id?: IntFilter<"ProgressReport"> | number
    orderId?: IntNullableFilter<"ProgressReport"> | number | null
    orderProductId?: IntNullableFilter<"ProgressReport"> | number | null
    productId?: IntNullableFilter<"ProgressReport"> | number | null
    userId?: IntFilter<"ProgressReport"> | number
    reportText?: StringFilter<"ProgressReport"> | string
    photoPath?: StringNullableFilter<"ProgressReport"> | string | null
    percentage?: IntFilter<"ProgressReport"> | number
    createdAt?: DateTimeFilter<"ProgressReport"> | Date | string
    updatedAt?: DateTimeFilter<"ProgressReport"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    orderProduct?: XOR<OrderProductNullableScalarRelationFilter, OrderProductWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    productReports?: ProductProgressReportListRelationFilter
  }

  export type ProgressReportOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    orderProductId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    userId?: SortOrder
    reportText?: SortOrder
    photoPath?: SortOrderInput | SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    orderProduct?: OrderProductOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    productReports?: ProductProgressReportOrderByRelationAggregateInput
  }

  export type ProgressReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProgressReportWhereInput | ProgressReportWhereInput[]
    OR?: ProgressReportWhereInput[]
    NOT?: ProgressReportWhereInput | ProgressReportWhereInput[]
    orderId?: IntNullableFilter<"ProgressReport"> | number | null
    orderProductId?: IntNullableFilter<"ProgressReport"> | number | null
    productId?: IntNullableFilter<"ProgressReport"> | number | null
    userId?: IntFilter<"ProgressReport"> | number
    reportText?: StringFilter<"ProgressReport"> | string
    photoPath?: StringNullableFilter<"ProgressReport"> | string | null
    percentage?: IntFilter<"ProgressReport"> | number
    createdAt?: DateTimeFilter<"ProgressReport"> | Date | string
    updatedAt?: DateTimeFilter<"ProgressReport"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    orderProduct?: XOR<OrderProductNullableScalarRelationFilter, OrderProductWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    productReports?: ProductProgressReportListRelationFilter
  }, "id">

  export type ProgressReportOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    orderProductId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    userId?: SortOrder
    reportText?: SortOrder
    photoPath?: SortOrderInput | SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgressReportCountOrderByAggregateInput
    _avg?: ProgressReportAvgOrderByAggregateInput
    _max?: ProgressReportMaxOrderByAggregateInput
    _min?: ProgressReportMinOrderByAggregateInput
    _sum?: ProgressReportSumOrderByAggregateInput
  }

  export type ProgressReportScalarWhereWithAggregatesInput = {
    AND?: ProgressReportScalarWhereWithAggregatesInput | ProgressReportScalarWhereWithAggregatesInput[]
    OR?: ProgressReportScalarWhereWithAggregatesInput[]
    NOT?: ProgressReportScalarWhereWithAggregatesInput | ProgressReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProgressReport"> | number
    orderId?: IntNullableWithAggregatesFilter<"ProgressReport"> | number | null
    orderProductId?: IntNullableWithAggregatesFilter<"ProgressReport"> | number | null
    productId?: IntNullableWithAggregatesFilter<"ProgressReport"> | number | null
    userId?: IntWithAggregatesFilter<"ProgressReport"> | number
    reportText?: StringWithAggregatesFilter<"ProgressReport"> | string
    photoPath?: StringNullableWithAggregatesFilter<"ProgressReport"> | string | null
    percentage?: IntWithAggregatesFilter<"ProgressReport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProgressReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProgressReport"> | Date | string
  }

  export type ProductProgressReportWhereInput = {
    AND?: ProductProgressReportWhereInput | ProductProgressReportWhereInput[]
    OR?: ProductProgressReportWhereInput[]
    NOT?: ProductProgressReportWhereInput | ProductProgressReportWhereInput[]
    id?: IntFilter<"ProductProgressReport"> | number
    progressReportId?: IntFilter<"ProductProgressReport"> | number
    productId?: IntFilter<"ProductProgressReport"> | number
    orderProductId?: IntNullableFilter<"ProductProgressReport"> | number | null
    itemsCompleted?: IntFilter<"ProductProgressReport"> | number
    itemsTarget?: IntFilter<"ProductProgressReport"> | number
    status?: StringFilter<"ProductProgressReport"> | string
    notes?: StringNullableFilter<"ProductProgressReport"> | string | null
    completionDate?: DateTimeNullableFilter<"ProductProgressReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductProgressReport"> | Date | string
    updatedAt?: DateTimeFilter<"ProductProgressReport"> | Date | string
    progressReport?: XOR<ProgressReportScalarRelationFilter, ProgressReportWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    orderProduct?: XOR<OrderProductNullableScalarRelationFilter, OrderProductWhereInput> | null
    photos?: ProductProgressPhotoListRelationFilter
  }

  export type ProductProgressReportOrderByWithRelationInput = {
    id?: SortOrder
    progressReportId?: SortOrder
    productId?: SortOrder
    orderProductId?: SortOrderInput | SortOrder
    itemsCompleted?: SortOrder
    itemsTarget?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    completionDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    progressReport?: ProgressReportOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    orderProduct?: OrderProductOrderByWithRelationInput
    photos?: ProductProgressPhotoOrderByRelationAggregateInput
  }

  export type ProductProgressReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductProgressReportWhereInput | ProductProgressReportWhereInput[]
    OR?: ProductProgressReportWhereInput[]
    NOT?: ProductProgressReportWhereInput | ProductProgressReportWhereInput[]
    progressReportId?: IntFilter<"ProductProgressReport"> | number
    productId?: IntFilter<"ProductProgressReport"> | number
    orderProductId?: IntNullableFilter<"ProductProgressReport"> | number | null
    itemsCompleted?: IntFilter<"ProductProgressReport"> | number
    itemsTarget?: IntFilter<"ProductProgressReport"> | number
    status?: StringFilter<"ProductProgressReport"> | string
    notes?: StringNullableFilter<"ProductProgressReport"> | string | null
    completionDate?: DateTimeNullableFilter<"ProductProgressReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductProgressReport"> | Date | string
    updatedAt?: DateTimeFilter<"ProductProgressReport"> | Date | string
    progressReport?: XOR<ProgressReportScalarRelationFilter, ProgressReportWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    orderProduct?: XOR<OrderProductNullableScalarRelationFilter, OrderProductWhereInput> | null
    photos?: ProductProgressPhotoListRelationFilter
  }, "id">

  export type ProductProgressReportOrderByWithAggregationInput = {
    id?: SortOrder
    progressReportId?: SortOrder
    productId?: SortOrder
    orderProductId?: SortOrderInput | SortOrder
    itemsCompleted?: SortOrder
    itemsTarget?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    completionDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductProgressReportCountOrderByAggregateInput
    _avg?: ProductProgressReportAvgOrderByAggregateInput
    _max?: ProductProgressReportMaxOrderByAggregateInput
    _min?: ProductProgressReportMinOrderByAggregateInput
    _sum?: ProductProgressReportSumOrderByAggregateInput
  }

  export type ProductProgressReportScalarWhereWithAggregatesInput = {
    AND?: ProductProgressReportScalarWhereWithAggregatesInput | ProductProgressReportScalarWhereWithAggregatesInput[]
    OR?: ProductProgressReportScalarWhereWithAggregatesInput[]
    NOT?: ProductProgressReportScalarWhereWithAggregatesInput | ProductProgressReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductProgressReport"> | number
    progressReportId?: IntWithAggregatesFilter<"ProductProgressReport"> | number
    productId?: IntWithAggregatesFilter<"ProductProgressReport"> | number
    orderProductId?: IntNullableWithAggregatesFilter<"ProductProgressReport"> | number | null
    itemsCompleted?: IntWithAggregatesFilter<"ProductProgressReport"> | number
    itemsTarget?: IntWithAggregatesFilter<"ProductProgressReport"> | number
    status?: StringWithAggregatesFilter<"ProductProgressReport"> | string
    notes?: StringNullableWithAggregatesFilter<"ProductProgressReport"> | string | null
    completionDate?: DateTimeNullableWithAggregatesFilter<"ProductProgressReport"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductProgressReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductProgressReport"> | Date | string
  }

  export type ProductProgressPhotoWhereInput = {
    AND?: ProductProgressPhotoWhereInput | ProductProgressPhotoWhereInput[]
    OR?: ProductProgressPhotoWhereInput[]
    NOT?: ProductProgressPhotoWhereInput | ProductProgressPhotoWhereInput[]
    id?: IntFilter<"ProductProgressPhoto"> | number
    productProgressReportId?: IntFilter<"ProductProgressPhoto"> | number
    photoPath?: StringFilter<"ProductProgressPhoto"> | string
    thumbnailPath?: StringNullableFilter<"ProductProgressPhoto"> | string | null
    description?: StringNullableFilter<"ProductProgressPhoto"> | string | null
    uploadDate?: DateTimeFilter<"ProductProgressPhoto"> | Date | string
    fileSize?: IntNullableFilter<"ProductProgressPhoto"> | number | null
    mimeType?: StringNullableFilter<"ProductProgressPhoto"> | string | null
    isActive?: BoolFilter<"ProductProgressPhoto"> | boolean
    createdAt?: DateTimeFilter<"ProductProgressPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ProductProgressPhoto"> | Date | string
    productProgressReport?: XOR<ProductProgressReportScalarRelationFilter, ProductProgressReportWhereInput>
  }

  export type ProductProgressPhotoOrderByWithRelationInput = {
    id?: SortOrder
    productProgressReportId?: SortOrder
    photoPath?: SortOrder
    thumbnailPath?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    uploadDate?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productProgressReport?: ProductProgressReportOrderByWithRelationInput
  }

  export type ProductProgressPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductProgressPhotoWhereInput | ProductProgressPhotoWhereInput[]
    OR?: ProductProgressPhotoWhereInput[]
    NOT?: ProductProgressPhotoWhereInput | ProductProgressPhotoWhereInput[]
    productProgressReportId?: IntFilter<"ProductProgressPhoto"> | number
    photoPath?: StringFilter<"ProductProgressPhoto"> | string
    thumbnailPath?: StringNullableFilter<"ProductProgressPhoto"> | string | null
    description?: StringNullableFilter<"ProductProgressPhoto"> | string | null
    uploadDate?: DateTimeFilter<"ProductProgressPhoto"> | Date | string
    fileSize?: IntNullableFilter<"ProductProgressPhoto"> | number | null
    mimeType?: StringNullableFilter<"ProductProgressPhoto"> | string | null
    isActive?: BoolFilter<"ProductProgressPhoto"> | boolean
    createdAt?: DateTimeFilter<"ProductProgressPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ProductProgressPhoto"> | Date | string
    productProgressReport?: XOR<ProductProgressReportScalarRelationFilter, ProductProgressReportWhereInput>
  }, "id">

  export type ProductProgressPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    productProgressReportId?: SortOrder
    photoPath?: SortOrder
    thumbnailPath?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    uploadDate?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductProgressPhotoCountOrderByAggregateInput
    _avg?: ProductProgressPhotoAvgOrderByAggregateInput
    _max?: ProductProgressPhotoMaxOrderByAggregateInput
    _min?: ProductProgressPhotoMinOrderByAggregateInput
    _sum?: ProductProgressPhotoSumOrderByAggregateInput
  }

  export type ProductProgressPhotoScalarWhereWithAggregatesInput = {
    AND?: ProductProgressPhotoScalarWhereWithAggregatesInput | ProductProgressPhotoScalarWhereWithAggregatesInput[]
    OR?: ProductProgressPhotoScalarWhereWithAggregatesInput[]
    NOT?: ProductProgressPhotoScalarWhereWithAggregatesInput | ProductProgressPhotoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductProgressPhoto"> | number
    productProgressReportId?: IntWithAggregatesFilter<"ProductProgressPhoto"> | number
    photoPath?: StringWithAggregatesFilter<"ProductProgressPhoto"> | string
    thumbnailPath?: StringNullableWithAggregatesFilter<"ProductProgressPhoto"> | string | null
    description?: StringNullableWithAggregatesFilter<"ProductProgressPhoto"> | string | null
    uploadDate?: DateTimeWithAggregatesFilter<"ProductProgressPhoto"> | Date | string
    fileSize?: IntNullableWithAggregatesFilter<"ProductProgressPhoto"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"ProductProgressPhoto"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProductProgressPhoto"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductProgressPhoto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductProgressPhoto"> | Date | string
  }

  export type RemainingMaterialWhereInput = {
    AND?: RemainingMaterialWhereInput | RemainingMaterialWhereInput[]
    OR?: RemainingMaterialWhereInput[]
    NOT?: RemainingMaterialWhereInput | RemainingMaterialWhereInput[]
    id?: IntFilter<"RemainingMaterial"> | number
    materialId?: IntFilter<"RemainingMaterial"> | number
    quantity?: DecimalFilter<"RemainingMaterial"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RemainingMaterial"> | string
    notes?: StringNullableFilter<"RemainingMaterial"> | string | null
    createdAt?: DateTimeFilter<"RemainingMaterial"> | Date | string
    updatedAt?: DateTimeFilter<"RemainingMaterial"> | Date | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }

  export type RemainingMaterialOrderByWithRelationInput = {
    id?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    material?: MaterialOrderByWithRelationInput
  }

  export type RemainingMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RemainingMaterialWhereInput | RemainingMaterialWhereInput[]
    OR?: RemainingMaterialWhereInput[]
    NOT?: RemainingMaterialWhereInput | RemainingMaterialWhereInput[]
    materialId?: IntFilter<"RemainingMaterial"> | number
    quantity?: DecimalFilter<"RemainingMaterial"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RemainingMaterial"> | string
    notes?: StringNullableFilter<"RemainingMaterial"> | string | null
    createdAt?: DateTimeFilter<"RemainingMaterial"> | Date | string
    updatedAt?: DateTimeFilter<"RemainingMaterial"> | Date | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }, "id">

  export type RemainingMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RemainingMaterialCountOrderByAggregateInput
    _avg?: RemainingMaterialAvgOrderByAggregateInput
    _max?: RemainingMaterialMaxOrderByAggregateInput
    _min?: RemainingMaterialMinOrderByAggregateInput
    _sum?: RemainingMaterialSumOrderByAggregateInput
  }

  export type RemainingMaterialScalarWhereWithAggregatesInput = {
    AND?: RemainingMaterialScalarWhereWithAggregatesInput | RemainingMaterialScalarWhereWithAggregatesInput[]
    OR?: RemainingMaterialScalarWhereWithAggregatesInput[]
    NOT?: RemainingMaterialScalarWhereWithAggregatesInput | RemainingMaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RemainingMaterial"> | number
    materialId?: IntWithAggregatesFilter<"RemainingMaterial"> | number
    quantity?: DecimalWithAggregatesFilter<"RemainingMaterial"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"RemainingMaterial"> | string
    notes?: StringNullableWithAggregatesFilter<"RemainingMaterial"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RemainingMaterial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RemainingMaterial"> | Date | string
  }

  export type InventarisWhereInput = {
    AND?: InventarisWhereInput | InventarisWhereInput[]
    OR?: InventarisWhereInput[]
    NOT?: InventarisWhereInput | InventarisWhereInput[]
    id?: IntFilter<"Inventaris"> | number
    name?: StringFilter<"Inventaris"> | string
    quantity?: IntFilter<"Inventaris"> | number
    unit?: StringFilter<"Inventaris"> | string
    notes?: StringNullableFilter<"Inventaris"> | string | null
    createdAt?: DateTimeFilter<"Inventaris"> | Date | string
    updatedAt?: DateTimeFilter<"Inventaris"> | Date | string
  }

  export type InventarisOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventarisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventarisWhereInput | InventarisWhereInput[]
    OR?: InventarisWhereInput[]
    NOT?: InventarisWhereInput | InventarisWhereInput[]
    name?: StringFilter<"Inventaris"> | string
    quantity?: IntFilter<"Inventaris"> | number
    unit?: StringFilter<"Inventaris"> | string
    notes?: StringNullableFilter<"Inventaris"> | string | null
    createdAt?: DateTimeFilter<"Inventaris"> | Date | string
    updatedAt?: DateTimeFilter<"Inventaris"> | Date | string
  }, "id">

  export type InventarisOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventarisCountOrderByAggregateInput
    _avg?: InventarisAvgOrderByAggregateInput
    _max?: InventarisMaxOrderByAggregateInput
    _min?: InventarisMinOrderByAggregateInput
    _sum?: InventarisSumOrderByAggregateInput
  }

  export type InventarisScalarWhereWithAggregatesInput = {
    AND?: InventarisScalarWhereWithAggregatesInput | InventarisScalarWhereWithAggregatesInput[]
    OR?: InventarisScalarWhereWithAggregatesInput[]
    NOT?: InventarisScalarWhereWithAggregatesInput | InventarisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inventaris"> | number
    name?: StringWithAggregatesFilter<"Inventaris"> | string
    quantity?: IntWithAggregatesFilter<"Inventaris"> | number
    unit?: StringWithAggregatesFilter<"Inventaris"> | string
    notes?: StringNullableWithAggregatesFilter<"Inventaris"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inventaris"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventaris"> | Date | string
  }

  export type OrderLinkWhereInput = {
    AND?: OrderLinkWhereInput | OrderLinkWhereInput[]
    OR?: OrderLinkWhereInput[]
    NOT?: OrderLinkWhereInput | OrderLinkWhereInput[]
    id?: IntFilter<"OrderLink"> | number
    orderId?: IntFilter<"OrderLink"> | number
    userId?: IntFilter<"OrderLink"> | number
    linkToken?: StringFilter<"OrderLink"> | string
    isActive?: BoolFilter<"OrderLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"OrderLink"> | Date | string | null
    createdAt?: DateTimeFilter<"OrderLink"> | Date | string
    updatedAt?: DateTimeFilter<"OrderLink"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrderLinkOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    linkToken?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OrderLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId?: number
    linkToken?: string
    AND?: OrderLinkWhereInput | OrderLinkWhereInput[]
    OR?: OrderLinkWhereInput[]
    NOT?: OrderLinkWhereInput | OrderLinkWhereInput[]
    userId?: IntFilter<"OrderLink"> | number
    isActive?: BoolFilter<"OrderLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"OrderLink"> | Date | string | null
    createdAt?: DateTimeFilter<"OrderLink"> | Date | string
    updatedAt?: DateTimeFilter<"OrderLink"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "orderId" | "linkToken">

  export type OrderLinkOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    linkToken?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderLinkCountOrderByAggregateInput
    _avg?: OrderLinkAvgOrderByAggregateInput
    _max?: OrderLinkMaxOrderByAggregateInput
    _min?: OrderLinkMinOrderByAggregateInput
    _sum?: OrderLinkSumOrderByAggregateInput
  }

  export type OrderLinkScalarWhereWithAggregatesInput = {
    AND?: OrderLinkScalarWhereWithAggregatesInput | OrderLinkScalarWhereWithAggregatesInput[]
    OR?: OrderLinkScalarWhereWithAggregatesInput[]
    NOT?: OrderLinkScalarWhereWithAggregatesInput | OrderLinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderLink"> | number
    orderId?: IntWithAggregatesFilter<"OrderLink"> | number
    userId?: IntWithAggregatesFilter<"OrderLink"> | number
    linkToken?: StringWithAggregatesFilter<"OrderLink"> | string
    isActive?: BoolWithAggregatesFilter<"OrderLink"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"OrderLink"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderLink"> | Date | string
  }

  export type ProductMaterialWhereInput = {
    AND?: ProductMaterialWhereInput | ProductMaterialWhereInput[]
    OR?: ProductMaterialWhereInput[]
    NOT?: ProductMaterialWhereInput | ProductMaterialWhereInput[]
    id?: IntFilter<"ProductMaterial"> | number
    productId?: IntFilter<"ProductMaterial"> | number
    materialId?: IntFilter<"ProductMaterial"> | number
    quantity?: DecimalFilter<"ProductMaterial"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"ProductMaterial"> | string
    createdAt?: DateTimeFilter<"ProductMaterial"> | Date | string
    updatedAt?: DateTimeFilter<"ProductMaterial"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }

  export type ProductMaterialOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
  }

  export type ProductMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductMaterialWhereInput | ProductMaterialWhereInput[]
    OR?: ProductMaterialWhereInput[]
    NOT?: ProductMaterialWhereInput | ProductMaterialWhereInput[]
    productId?: IntFilter<"ProductMaterial"> | number
    materialId?: IntFilter<"ProductMaterial"> | number
    quantity?: DecimalFilter<"ProductMaterial"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"ProductMaterial"> | string
    createdAt?: DateTimeFilter<"ProductMaterial"> | Date | string
    updatedAt?: DateTimeFilter<"ProductMaterial"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
  }, "id">

  export type ProductMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductMaterialCountOrderByAggregateInput
    _avg?: ProductMaterialAvgOrderByAggregateInput
    _max?: ProductMaterialMaxOrderByAggregateInput
    _min?: ProductMaterialMinOrderByAggregateInput
    _sum?: ProductMaterialSumOrderByAggregateInput
  }

  export type ProductMaterialScalarWhereWithAggregatesInput = {
    AND?: ProductMaterialScalarWhereWithAggregatesInput | ProductMaterialScalarWhereWithAggregatesInput[]
    OR?: ProductMaterialScalarWhereWithAggregatesInput[]
    NOT?: ProductMaterialScalarWhereWithAggregatesInput | ProductMaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductMaterial"> | number
    productId?: IntWithAggregatesFilter<"ProductMaterial"> | number
    materialId?: IntWithAggregatesFilter<"ProductMaterial"> | number
    quantity?: DecimalWithAggregatesFilter<"ProductMaterial"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"ProductMaterial"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductMaterial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductMaterial"> | Date | string
  }

  export type ShipmentWhereInput = {
    AND?: ShipmentWhereInput | ShipmentWhereInput[]
    OR?: ShipmentWhereInput[]
    NOT?: ShipmentWhereInput | ShipmentWhereInput[]
    id?: IntFilter<"Shipment"> | number
    orderId?: IntFilter<"Shipment"> | number
    trackingNumber?: StringNullableFilter<"Shipment"> | string | null
    carrier?: StringNullableFilter<"Shipment"> | string | null
    shippedDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    deliveredDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    status?: EnumShipmentStatusFilter<"Shipment"> | $Enums.ShipmentStatus
    notes?: StringNullableFilter<"Shipment"> | string | null
    createdAt?: DateTimeFilter<"Shipment"> | Date | string
    updatedAt?: DateTimeFilter<"Shipment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type ShipmentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    shippedDate?: SortOrderInput | SortOrder
    deliveredDate?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type ShipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId?: number
    AND?: ShipmentWhereInput | ShipmentWhereInput[]
    OR?: ShipmentWhereInput[]
    NOT?: ShipmentWhereInput | ShipmentWhereInput[]
    trackingNumber?: StringNullableFilter<"Shipment"> | string | null
    carrier?: StringNullableFilter<"Shipment"> | string | null
    shippedDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    deliveredDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    status?: EnumShipmentStatusFilter<"Shipment"> | $Enums.ShipmentStatus
    notes?: StringNullableFilter<"Shipment"> | string | null
    createdAt?: DateTimeFilter<"Shipment"> | Date | string
    updatedAt?: DateTimeFilter<"Shipment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id" | "orderId">

  export type ShipmentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    shippedDate?: SortOrderInput | SortOrder
    deliveredDate?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShipmentCountOrderByAggregateInput
    _avg?: ShipmentAvgOrderByAggregateInput
    _max?: ShipmentMaxOrderByAggregateInput
    _min?: ShipmentMinOrderByAggregateInput
    _sum?: ShipmentSumOrderByAggregateInput
  }

  export type ShipmentScalarWhereWithAggregatesInput = {
    AND?: ShipmentScalarWhereWithAggregatesInput | ShipmentScalarWhereWithAggregatesInput[]
    OR?: ShipmentScalarWhereWithAggregatesInput[]
    NOT?: ShipmentScalarWhereWithAggregatesInput | ShipmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shipment"> | number
    orderId?: IntWithAggregatesFilter<"Shipment"> | number
    trackingNumber?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    carrier?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    shippedDate?: DateTimeNullableWithAggregatesFilter<"Shipment"> | Date | string | null
    deliveredDate?: DateTimeNullableWithAggregatesFilter<"Shipment"> | Date | string | null
    status?: EnumShipmentStatusWithAggregatesFilter<"Shipment"> | $Enums.ShipmentStatus
    notes?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Shipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shipment"> | Date | string
  }

  export type RecurringPlanWhereInput = {
    AND?: RecurringPlanWhereInput | RecurringPlanWhereInput[]
    OR?: RecurringPlanWhereInput[]
    NOT?: RecurringPlanWhereInput | RecurringPlanWhereInput[]
    id?: IntFilter<"RecurringPlan"> | number
    productId?: IntFilter<"RecurringPlan"> | number
    quantity?: IntFilter<"RecurringPlan"> | number
    frequency?: StringFilter<"RecurringPlan"> | string
    isActive?: BoolFilter<"RecurringPlan"> | boolean
    nextDue?: DateTimeNullableFilter<"RecurringPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"RecurringPlan"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringPlan"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type RecurringPlanOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    nextDue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type RecurringPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecurringPlanWhereInput | RecurringPlanWhereInput[]
    OR?: RecurringPlanWhereInput[]
    NOT?: RecurringPlanWhereInput | RecurringPlanWhereInput[]
    productId?: IntFilter<"RecurringPlan"> | number
    quantity?: IntFilter<"RecurringPlan"> | number
    frequency?: StringFilter<"RecurringPlan"> | string
    isActive?: BoolFilter<"RecurringPlan"> | boolean
    nextDue?: DateTimeNullableFilter<"RecurringPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"RecurringPlan"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringPlan"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type RecurringPlanOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    nextDue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecurringPlanCountOrderByAggregateInput
    _avg?: RecurringPlanAvgOrderByAggregateInput
    _max?: RecurringPlanMaxOrderByAggregateInput
    _min?: RecurringPlanMinOrderByAggregateInput
    _sum?: RecurringPlanSumOrderByAggregateInput
  }

  export type RecurringPlanScalarWhereWithAggregatesInput = {
    AND?: RecurringPlanScalarWhereWithAggregatesInput | RecurringPlanScalarWhereWithAggregatesInput[]
    OR?: RecurringPlanScalarWhereWithAggregatesInput[]
    NOT?: RecurringPlanScalarWhereWithAggregatesInput | RecurringPlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RecurringPlan"> | number
    productId?: IntWithAggregatesFilter<"RecurringPlan"> | number
    quantity?: IntWithAggregatesFilter<"RecurringPlan"> | number
    frequency?: StringWithAggregatesFilter<"RecurringPlan"> | string
    isActive?: BoolWithAggregatesFilter<"RecurringPlan"> | boolean
    nextDue?: DateTimeNullableWithAggregatesFilter<"RecurringPlan"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RecurringPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecurringPlan"> | Date | string
  }

  export type StatusChangeWhereInput = {
    AND?: StatusChangeWhereInput | StatusChangeWhereInput[]
    OR?: StatusChangeWhereInput[]
    NOT?: StatusChangeWhereInput | StatusChangeWhereInput[]
    id?: IntFilter<"StatusChange"> | number
    orderId?: IntFilter<"StatusChange"> | number
    changedBy?: IntFilter<"StatusChange"> | number
    fromStatus?: EnumOrderStatusFilter<"StatusChange"> | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFilter<"StatusChange"> | $Enums.OrderStatus
    reason?: StringNullableFilter<"StatusChange"> | string | null
    notes?: StringNullableFilter<"StatusChange"> | string | null
    createdAt?: DateTimeFilter<"StatusChange"> | Date | string
    updatedAt?: DateTimeFilter<"StatusChange"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StatusChangeOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    changedBy?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StatusChangeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StatusChangeWhereInput | StatusChangeWhereInput[]
    OR?: StatusChangeWhereInput[]
    NOT?: StatusChangeWhereInput | StatusChangeWhereInput[]
    orderId?: IntFilter<"StatusChange"> | number
    changedBy?: IntFilter<"StatusChange"> | number
    fromStatus?: EnumOrderStatusFilter<"StatusChange"> | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFilter<"StatusChange"> | $Enums.OrderStatus
    reason?: StringNullableFilter<"StatusChange"> | string | null
    notes?: StringNullableFilter<"StatusChange"> | string | null
    createdAt?: DateTimeFilter<"StatusChange"> | Date | string
    updatedAt?: DateTimeFilter<"StatusChange"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type StatusChangeOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    changedBy?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StatusChangeCountOrderByAggregateInput
    _avg?: StatusChangeAvgOrderByAggregateInput
    _max?: StatusChangeMaxOrderByAggregateInput
    _min?: StatusChangeMinOrderByAggregateInput
    _sum?: StatusChangeSumOrderByAggregateInput
  }

  export type StatusChangeScalarWhereWithAggregatesInput = {
    AND?: StatusChangeScalarWhereWithAggregatesInput | StatusChangeScalarWhereWithAggregatesInput[]
    OR?: StatusChangeScalarWhereWithAggregatesInput[]
    NOT?: StatusChangeScalarWhereWithAggregatesInput | StatusChangeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StatusChange"> | number
    orderId?: IntWithAggregatesFilter<"StatusChange"> | number
    changedBy?: IntWithAggregatesFilter<"StatusChange"> | number
    fromStatus?: EnumOrderStatusWithAggregatesFilter<"StatusChange"> | $Enums.OrderStatus
    toStatus?: EnumOrderStatusWithAggregatesFilter<"StatusChange"> | $Enums.OrderStatus
    reason?: StringNullableWithAggregatesFilter<"StatusChange"> | string | null
    notes?: StringNullableWithAggregatesFilter<"StatusChange"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StatusChange"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StatusChange"> | Date | string
  }

  export type ProductColourWhereInput = {
    AND?: ProductColourWhereInput | ProductColourWhereInput[]
    OR?: ProductColourWhereInput[]
    NOT?: ProductColourWhereInput | ProductColourWhereInput[]
    id?: IntFilter<"ProductColour"> | number
    productId?: IntFilter<"ProductColour"> | number
    colorName?: StringFilter<"ProductColour"> | string
    colorCode?: StringNullableFilter<"ProductColour"> | string | null
    isActive?: BoolFilter<"ProductColour"> | boolean
    createdAt?: DateTimeFilter<"ProductColour"> | Date | string
    updatedAt?: DateTimeFilter<"ProductColour"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductColourOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    colorName?: SortOrder
    colorCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductColourWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductColourWhereInput | ProductColourWhereInput[]
    OR?: ProductColourWhereInput[]
    NOT?: ProductColourWhereInput | ProductColourWhereInput[]
    productId?: IntFilter<"ProductColour"> | number
    colorName?: StringFilter<"ProductColour"> | string
    colorCode?: StringNullableFilter<"ProductColour"> | string | null
    isActive?: BoolFilter<"ProductColour"> | boolean
    createdAt?: DateTimeFilter<"ProductColour"> | Date | string
    updatedAt?: DateTimeFilter<"ProductColour"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductColourOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    colorName?: SortOrder
    colorCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductColourCountOrderByAggregateInput
    _avg?: ProductColourAvgOrderByAggregateInput
    _max?: ProductColourMaxOrderByAggregateInput
    _min?: ProductColourMinOrderByAggregateInput
    _sum?: ProductColourSumOrderByAggregateInput
  }

  export type ProductColourScalarWhereWithAggregatesInput = {
    AND?: ProductColourScalarWhereWithAggregatesInput | ProductColourScalarWhereWithAggregatesInput[]
    OR?: ProductColourScalarWhereWithAggregatesInput[]
    NOT?: ProductColourScalarWhereWithAggregatesInput | ProductColourScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductColour"> | number
    productId?: IntWithAggregatesFilter<"ProductColour"> | number
    colorName?: StringWithAggregatesFilter<"ProductColour"> | string
    colorCode?: StringNullableWithAggregatesFilter<"ProductColour"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProductColour"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductColour"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductColour"> | Date | string
  }

  export type ProductVariationWhereInput = {
    AND?: ProductVariationWhereInput | ProductVariationWhereInput[]
    OR?: ProductVariationWhereInput[]
    NOT?: ProductVariationWhereInput | ProductVariationWhereInput[]
    id?: IntFilter<"ProductVariation"> | number
    productId?: IntFilter<"ProductVariation"> | number
    variationType?: StringFilter<"ProductVariation"> | string
    variationValue?: StringFilter<"ProductVariation"> | string
    priceAdjustment?: DecimalNullableFilter<"ProductVariation"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"ProductVariation"> | boolean
    createdAt?: DateTimeFilter<"ProductVariation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariation"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductVariationOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    variationType?: SortOrder
    variationValue?: SortOrder
    priceAdjustment?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductVariationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductVariationWhereInput | ProductVariationWhereInput[]
    OR?: ProductVariationWhereInput[]
    NOT?: ProductVariationWhereInput | ProductVariationWhereInput[]
    productId?: IntFilter<"ProductVariation"> | number
    variationType?: StringFilter<"ProductVariation"> | string
    variationValue?: StringFilter<"ProductVariation"> | string
    priceAdjustment?: DecimalNullableFilter<"ProductVariation"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"ProductVariation"> | boolean
    createdAt?: DateTimeFilter<"ProductVariation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariation"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductVariationOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    variationType?: SortOrder
    variationValue?: SortOrder
    priceAdjustment?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVariationCountOrderByAggregateInput
    _avg?: ProductVariationAvgOrderByAggregateInput
    _max?: ProductVariationMaxOrderByAggregateInput
    _min?: ProductVariationMinOrderByAggregateInput
    _sum?: ProductVariationSumOrderByAggregateInput
  }

  export type ProductVariationScalarWhereWithAggregatesInput = {
    AND?: ProductVariationScalarWhereWithAggregatesInput | ProductVariationScalarWhereWithAggregatesInput[]
    OR?: ProductVariationScalarWhereWithAggregatesInput[]
    NOT?: ProductVariationScalarWhereWithAggregatesInput | ProductVariationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductVariation"> | number
    productId?: IntWithAggregatesFilter<"ProductVariation"> | number
    variationType?: StringWithAggregatesFilter<"ProductVariation"> | string
    variationValue?: StringWithAggregatesFilter<"ProductVariation"> | string
    priceAdjustment?: DecimalNullableWithAggregatesFilter<"ProductVariation"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"ProductVariation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariation"> | Date | string
  }

  export type ProductPhotoWhereInput = {
    AND?: ProductPhotoWhereInput | ProductPhotoWhereInput[]
    OR?: ProductPhotoWhereInput[]
    NOT?: ProductPhotoWhereInput | ProductPhotoWhereInput[]
    id?: IntFilter<"ProductPhoto"> | number
    productId?: IntFilter<"ProductPhoto"> | number
    photoPath?: StringFilter<"ProductPhoto"> | string
    thumbnailPath?: StringNullableFilter<"ProductPhoto"> | string | null
    description?: StringNullableFilter<"ProductPhoto"> | string | null
    isPrimary?: BoolFilter<"ProductPhoto"> | boolean
    sortOrder?: IntFilter<"ProductPhoto"> | number
    fileSize?: IntNullableFilter<"ProductPhoto"> | number | null
    mimeType?: StringNullableFilter<"ProductPhoto"> | string | null
    isActive?: BoolFilter<"ProductPhoto"> | boolean
    createdAt?: DateTimeFilter<"ProductPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ProductPhoto"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductPhotoOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    photoPath?: SortOrder
    thumbnailPath?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductPhotoWhereInput | ProductPhotoWhereInput[]
    OR?: ProductPhotoWhereInput[]
    NOT?: ProductPhotoWhereInput | ProductPhotoWhereInput[]
    productId?: IntFilter<"ProductPhoto"> | number
    photoPath?: StringFilter<"ProductPhoto"> | string
    thumbnailPath?: StringNullableFilter<"ProductPhoto"> | string | null
    description?: StringNullableFilter<"ProductPhoto"> | string | null
    isPrimary?: BoolFilter<"ProductPhoto"> | boolean
    sortOrder?: IntFilter<"ProductPhoto"> | number
    fileSize?: IntNullableFilter<"ProductPhoto"> | number | null
    mimeType?: StringNullableFilter<"ProductPhoto"> | string | null
    isActive?: BoolFilter<"ProductPhoto"> | boolean
    createdAt?: DateTimeFilter<"ProductPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ProductPhoto"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    photoPath?: SortOrder
    thumbnailPath?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductPhotoCountOrderByAggregateInput
    _avg?: ProductPhotoAvgOrderByAggregateInput
    _max?: ProductPhotoMaxOrderByAggregateInput
    _min?: ProductPhotoMinOrderByAggregateInput
    _sum?: ProductPhotoSumOrderByAggregateInput
  }

  export type ProductPhotoScalarWhereWithAggregatesInput = {
    AND?: ProductPhotoScalarWhereWithAggregatesInput | ProductPhotoScalarWhereWithAggregatesInput[]
    OR?: ProductPhotoScalarWhereWithAggregatesInput[]
    NOT?: ProductPhotoScalarWhereWithAggregatesInput | ProductPhotoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductPhoto"> | number
    productId?: IntWithAggregatesFilter<"ProductPhoto"> | number
    photoPath?: StringWithAggregatesFilter<"ProductPhoto"> | string
    thumbnailPath?: StringNullableWithAggregatesFilter<"ProductPhoto"> | string | null
    description?: StringNullableWithAggregatesFilter<"ProductPhoto"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"ProductPhoto"> | boolean
    sortOrder?: IntWithAggregatesFilter<"ProductPhoto"> | number
    fileSize?: IntNullableWithAggregatesFilter<"ProductPhoto"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"ProductPhoto"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProductPhoto"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductPhoto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductPhoto"> | Date | string
  }

  export type MaterialPurchaseAlertWhereInput = {
    AND?: MaterialPurchaseAlertWhereInput | MaterialPurchaseAlertWhereInput[]
    OR?: MaterialPurchaseAlertWhereInput[]
    NOT?: MaterialPurchaseAlertWhereInput | MaterialPurchaseAlertWhereInput[]
    id?: IntFilter<"MaterialPurchaseAlert"> | number
    materialId?: IntFilter<"MaterialPurchaseAlert"> | number
    orderId?: IntNullableFilter<"MaterialPurchaseAlert"> | number | null
    alertType?: EnumMaterialPurchaseAlertTypeFilter<"MaterialPurchaseAlert"> | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFilter<"MaterialPurchaseAlert"> | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFilter<"MaterialPurchaseAlert"> | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFilter<"MaterialPurchaseAlert"> | $Enums.UrgencyLevel
    message?: StringFilter<"MaterialPurchaseAlert"> | string
    status?: EnumAlertStatusFilter<"MaterialPurchaseAlert"> | $Enums.AlertStatus
    createdBy?: IntFilter<"MaterialPurchaseAlert"> | number
    resolvedBy?: IntNullableFilter<"MaterialPurchaseAlert"> | number | null
    resolvedAt?: DateTimeNullableFilter<"MaterialPurchaseAlert"> | Date | string | null
    resolution?: StringNullableFilter<"MaterialPurchaseAlert"> | string | null
    estimatedCost?: DecimalNullableFilter<"MaterialPurchaseAlert"> | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: StringNullableFilter<"MaterialPurchaseAlert"> | string | null
    createdAt?: DateTimeFilter<"MaterialPurchaseAlert"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialPurchaseAlert"> | Date | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    createdByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    resolvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type MaterialPurchaseAlertOrderByWithRelationInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    alertType?: SortOrder
    requiredQuantity?: SortOrder
    currentStock?: SortOrder
    urgencyLevel?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    suggestedSupplier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    material?: MaterialOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
    resolvedByUser?: UserOrderByWithRelationInput
  }

  export type MaterialPurchaseAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MaterialPurchaseAlertWhereInput | MaterialPurchaseAlertWhereInput[]
    OR?: MaterialPurchaseAlertWhereInput[]
    NOT?: MaterialPurchaseAlertWhereInput | MaterialPurchaseAlertWhereInput[]
    materialId?: IntFilter<"MaterialPurchaseAlert"> | number
    orderId?: IntNullableFilter<"MaterialPurchaseAlert"> | number | null
    alertType?: EnumMaterialPurchaseAlertTypeFilter<"MaterialPurchaseAlert"> | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFilter<"MaterialPurchaseAlert"> | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFilter<"MaterialPurchaseAlert"> | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFilter<"MaterialPurchaseAlert"> | $Enums.UrgencyLevel
    message?: StringFilter<"MaterialPurchaseAlert"> | string
    status?: EnumAlertStatusFilter<"MaterialPurchaseAlert"> | $Enums.AlertStatus
    createdBy?: IntFilter<"MaterialPurchaseAlert"> | number
    resolvedBy?: IntNullableFilter<"MaterialPurchaseAlert"> | number | null
    resolvedAt?: DateTimeNullableFilter<"MaterialPurchaseAlert"> | Date | string | null
    resolution?: StringNullableFilter<"MaterialPurchaseAlert"> | string | null
    estimatedCost?: DecimalNullableFilter<"MaterialPurchaseAlert"> | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: StringNullableFilter<"MaterialPurchaseAlert"> | string | null
    createdAt?: DateTimeFilter<"MaterialPurchaseAlert"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialPurchaseAlert"> | Date | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    createdByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    resolvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type MaterialPurchaseAlertOrderByWithAggregationInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    alertType?: SortOrder
    requiredQuantity?: SortOrder
    currentStock?: SortOrder
    urgencyLevel?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    suggestedSupplier?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterialPurchaseAlertCountOrderByAggregateInput
    _avg?: MaterialPurchaseAlertAvgOrderByAggregateInput
    _max?: MaterialPurchaseAlertMaxOrderByAggregateInput
    _min?: MaterialPurchaseAlertMinOrderByAggregateInput
    _sum?: MaterialPurchaseAlertSumOrderByAggregateInput
  }

  export type MaterialPurchaseAlertScalarWhereWithAggregatesInput = {
    AND?: MaterialPurchaseAlertScalarWhereWithAggregatesInput | MaterialPurchaseAlertScalarWhereWithAggregatesInput[]
    OR?: MaterialPurchaseAlertScalarWhereWithAggregatesInput[]
    NOT?: MaterialPurchaseAlertScalarWhereWithAggregatesInput | MaterialPurchaseAlertScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaterialPurchaseAlert"> | number
    materialId?: IntWithAggregatesFilter<"MaterialPurchaseAlert"> | number
    orderId?: IntNullableWithAggregatesFilter<"MaterialPurchaseAlert"> | number | null
    alertType?: EnumMaterialPurchaseAlertTypeWithAggregatesFilter<"MaterialPurchaseAlert"> | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalWithAggregatesFilter<"MaterialPurchaseAlert"> | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalWithAggregatesFilter<"MaterialPurchaseAlert"> | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelWithAggregatesFilter<"MaterialPurchaseAlert"> | $Enums.UrgencyLevel
    message?: StringWithAggregatesFilter<"MaterialPurchaseAlert"> | string
    status?: EnumAlertStatusWithAggregatesFilter<"MaterialPurchaseAlert"> | $Enums.AlertStatus
    createdBy?: IntWithAggregatesFilter<"MaterialPurchaseAlert"> | number
    resolvedBy?: IntNullableWithAggregatesFilter<"MaterialPurchaseAlert"> | number | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"MaterialPurchaseAlert"> | Date | string | null
    resolution?: StringNullableWithAggregatesFilter<"MaterialPurchaseAlert"> | string | null
    estimatedCost?: DecimalNullableWithAggregatesFilter<"MaterialPurchaseAlert"> | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: StringNullableWithAggregatesFilter<"MaterialPurchaseAlert"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MaterialPurchaseAlert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaterialPurchaseAlert"> | Date | string
  }

  export type PurchaseLogWhereInput = {
    AND?: PurchaseLogWhereInput | PurchaseLogWhereInput[]
    OR?: PurchaseLogWhereInput[]
    NOT?: PurchaseLogWhereInput | PurchaseLogWhereInput[]
    id?: IntFilter<"PurchaseLog"> | number
    materialId?: IntFilter<"PurchaseLog"> | number
    supplier?: StringFilter<"PurchaseLog"> | string
    quantity?: DecimalFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"PurchaseLog"> | string
    pricePerUnit?: DecimalFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFilter<"PurchaseLog"> | Date | string
    invoiceNumber?: StringNullableFilter<"PurchaseLog"> | string | null
    receiptPath?: StringNullableFilter<"PurchaseLog"> | string | null
    notes?: StringNullableFilter<"PurchaseLog"> | string | null
    status?: EnumPurchaseStatusFilter<"PurchaseLog"> | $Enums.PurchaseStatus
    deliveryDate?: DateTimeNullableFilter<"PurchaseLog"> | Date | string | null
    receivedQuantity?: DecimalNullableFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"PurchaseLog"> | boolean
    createdAt?: DateTimeFilter<"PurchaseLog"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseLog"> | Date | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
    movement?: XOR<MaterialMovementNullableScalarRelationFilter, MaterialMovementWhereInput> | null
    contactNotes?: ContactNoteListRelationFilter
  }

  export type PurchaseLogOrderByWithRelationInput = {
    id?: SortOrder
    materialId?: SortOrder
    supplier?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    pricePerUnit?: SortOrder
    totalCost?: SortOrder
    purchaseDate?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    receiptPath?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    receivedQuantity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    material?: MaterialOrderByWithRelationInput
    movement?: MaterialMovementOrderByWithRelationInput
    contactNotes?: ContactNoteOrderByRelationAggregateInput
  }

  export type PurchaseLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseLogWhereInput | PurchaseLogWhereInput[]
    OR?: PurchaseLogWhereInput[]
    NOT?: PurchaseLogWhereInput | PurchaseLogWhereInput[]
    materialId?: IntFilter<"PurchaseLog"> | number
    supplier?: StringFilter<"PurchaseLog"> | string
    quantity?: DecimalFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"PurchaseLog"> | string
    pricePerUnit?: DecimalFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFilter<"PurchaseLog"> | Date | string
    invoiceNumber?: StringNullableFilter<"PurchaseLog"> | string | null
    receiptPath?: StringNullableFilter<"PurchaseLog"> | string | null
    notes?: StringNullableFilter<"PurchaseLog"> | string | null
    status?: EnumPurchaseStatusFilter<"PurchaseLog"> | $Enums.PurchaseStatus
    deliveryDate?: DateTimeNullableFilter<"PurchaseLog"> | Date | string | null
    receivedQuantity?: DecimalNullableFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"PurchaseLog"> | boolean
    createdAt?: DateTimeFilter<"PurchaseLog"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseLog"> | Date | string
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
    movement?: XOR<MaterialMovementNullableScalarRelationFilter, MaterialMovementWhereInput> | null
    contactNotes?: ContactNoteListRelationFilter
  }, "id">

  export type PurchaseLogOrderByWithAggregationInput = {
    id?: SortOrder
    materialId?: SortOrder
    supplier?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    pricePerUnit?: SortOrder
    totalCost?: SortOrder
    purchaseDate?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    receiptPath?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    receivedQuantity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseLogCountOrderByAggregateInput
    _avg?: PurchaseLogAvgOrderByAggregateInput
    _max?: PurchaseLogMaxOrderByAggregateInput
    _min?: PurchaseLogMinOrderByAggregateInput
    _sum?: PurchaseLogSumOrderByAggregateInput
  }

  export type PurchaseLogScalarWhereWithAggregatesInput = {
    AND?: PurchaseLogScalarWhereWithAggregatesInput | PurchaseLogScalarWhereWithAggregatesInput[]
    OR?: PurchaseLogScalarWhereWithAggregatesInput[]
    NOT?: PurchaseLogScalarWhereWithAggregatesInput | PurchaseLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseLog"> | number
    materialId?: IntWithAggregatesFilter<"PurchaseLog"> | number
    supplier?: StringWithAggregatesFilter<"PurchaseLog"> | string
    quantity?: DecimalWithAggregatesFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"PurchaseLog"> | string
    pricePerUnit?: DecimalWithAggregatesFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalWithAggregatesFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeWithAggregatesFilter<"PurchaseLog"> | Date | string
    invoiceNumber?: StringNullableWithAggregatesFilter<"PurchaseLog"> | string | null
    receiptPath?: StringNullableWithAggregatesFilter<"PurchaseLog"> | string | null
    notes?: StringNullableWithAggregatesFilter<"PurchaseLog"> | string | null
    status?: EnumPurchaseStatusWithAggregatesFilter<"PurchaseLog"> | $Enums.PurchaseStatus
    deliveryDate?: DateTimeNullableWithAggregatesFilter<"PurchaseLog"> | Date | string | null
    receivedQuantity?: DecimalNullableWithAggregatesFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"PurchaseLog"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseLog"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: IntFilter<"Contact"> | number
    name?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    whatsappPhone?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    address?: StringNullableFilter<"Contact"> | string | null
    contactType?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    company?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    workerOrders?: OrderListRelationFilter
    contactNotes?: ContactNoteListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    whatsappPhone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contactType?: SortOrder
    company?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workerOrders?: OrderOrderByRelationAggregateInput
    contactNotes?: ContactNoteOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    name?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    whatsappPhone?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    address?: StringNullableFilter<"Contact"> | string | null
    contactType?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    company?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    workerOrders?: OrderListRelationFilter
    contactNotes?: ContactNoteListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    whatsappPhone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contactType?: SortOrder
    company?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact"> | number
    name?: StringWithAggregatesFilter<"Contact"> | string
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    whatsappPhone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    address?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    contactType?: EnumContactTypeWithAggregatesFilter<"Contact"> | $Enums.ContactType
    company?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    isActive?: BoolWithAggregatesFilter<"Contact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type ContactNoteWhereInput = {
    AND?: ContactNoteWhereInput | ContactNoteWhereInput[]
    OR?: ContactNoteWhereInput[]
    NOT?: ContactNoteWhereInput | ContactNoteWhereInput[]
    id?: IntFilter<"ContactNote"> | number
    contactId?: IntFilter<"ContactNote"> | number
    orderId?: IntNullableFilter<"ContactNote"> | number | null
    purchaseLogId?: IntNullableFilter<"ContactNote"> | number | null
    createdBy?: IntFilter<"ContactNote"> | number
    noteType?: EnumNoteTypeFilter<"ContactNote"> | $Enums.NoteType
    subject?: StringNullableFilter<"ContactNote"> | string | null
    content?: StringFilter<"ContactNote"> | string
    followUpDate?: DateTimeNullableFilter<"ContactNote"> | Date | string | null
    isImportant?: BoolFilter<"ContactNote"> | boolean
    tags?: StringNullableFilter<"ContactNote"> | string | null
    attachmentPath?: StringNullableFilter<"ContactNote"> | string | null
    isActive?: BoolFilter<"ContactNote"> | boolean
    createdAt?: DateTimeFilter<"ContactNote"> | Date | string
    updatedAt?: DateTimeFilter<"ContactNote"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    purchaseLog?: XOR<PurchaseLogNullableScalarRelationFilter, PurchaseLogWhereInput> | null
    createdByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ContactNoteOrderByWithRelationInput = {
    id?: SortOrder
    contactId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    purchaseLogId?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    noteType?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    isImportant?: SortOrder
    tags?: SortOrderInput | SortOrder
    attachmentPath?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    purchaseLog?: PurchaseLogOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
  }

  export type ContactNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactNoteWhereInput | ContactNoteWhereInput[]
    OR?: ContactNoteWhereInput[]
    NOT?: ContactNoteWhereInput | ContactNoteWhereInput[]
    contactId?: IntFilter<"ContactNote"> | number
    orderId?: IntNullableFilter<"ContactNote"> | number | null
    purchaseLogId?: IntNullableFilter<"ContactNote"> | number | null
    createdBy?: IntFilter<"ContactNote"> | number
    noteType?: EnumNoteTypeFilter<"ContactNote"> | $Enums.NoteType
    subject?: StringNullableFilter<"ContactNote"> | string | null
    content?: StringFilter<"ContactNote"> | string
    followUpDate?: DateTimeNullableFilter<"ContactNote"> | Date | string | null
    isImportant?: BoolFilter<"ContactNote"> | boolean
    tags?: StringNullableFilter<"ContactNote"> | string | null
    attachmentPath?: StringNullableFilter<"ContactNote"> | string | null
    isActive?: BoolFilter<"ContactNote"> | boolean
    createdAt?: DateTimeFilter<"ContactNote"> | Date | string
    updatedAt?: DateTimeFilter<"ContactNote"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    purchaseLog?: XOR<PurchaseLogNullableScalarRelationFilter, PurchaseLogWhereInput> | null
    createdByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ContactNoteOrderByWithAggregationInput = {
    id?: SortOrder
    contactId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    purchaseLogId?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    noteType?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    isImportant?: SortOrder
    tags?: SortOrderInput | SortOrder
    attachmentPath?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactNoteCountOrderByAggregateInput
    _avg?: ContactNoteAvgOrderByAggregateInput
    _max?: ContactNoteMaxOrderByAggregateInput
    _min?: ContactNoteMinOrderByAggregateInput
    _sum?: ContactNoteSumOrderByAggregateInput
  }

  export type ContactNoteScalarWhereWithAggregatesInput = {
    AND?: ContactNoteScalarWhereWithAggregatesInput | ContactNoteScalarWhereWithAggregatesInput[]
    OR?: ContactNoteScalarWhereWithAggregatesInput[]
    NOT?: ContactNoteScalarWhereWithAggregatesInput | ContactNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactNote"> | number
    contactId?: IntWithAggregatesFilter<"ContactNote"> | number
    orderId?: IntNullableWithAggregatesFilter<"ContactNote"> | number | null
    purchaseLogId?: IntNullableWithAggregatesFilter<"ContactNote"> | number | null
    createdBy?: IntWithAggregatesFilter<"ContactNote"> | number
    noteType?: EnumNoteTypeWithAggregatesFilter<"ContactNote"> | $Enums.NoteType
    subject?: StringNullableWithAggregatesFilter<"ContactNote"> | string | null
    content?: StringWithAggregatesFilter<"ContactNote"> | string
    followUpDate?: DateTimeNullableWithAggregatesFilter<"ContactNote"> | Date | string | null
    isImportant?: BoolWithAggregatesFilter<"ContactNote"> | boolean
    tags?: StringNullableWithAggregatesFilter<"ContactNote"> | string | null
    attachmentPath?: StringNullableWithAggregatesFilter<"ContactNote"> | string | null
    isActive?: BoolWithAggregatesFilter<"ContactNote"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ContactNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactNote"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    workerOrders?: OrderCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerOrders?: OrderUncheckedCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkUncheckedCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUncheckedUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUncheckedUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateInput = {
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementCreateNestedManyWithoutMaterialInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutMaterialInput
    remainingMaterials?: RemainingMaterialCreateNestedManyWithoutMaterialInput
    products?: ProductCreateNestedManyWithoutBaseMaterialInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutMaterialInput
    purchaseLogs?: PurchaseLogCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutMaterialInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutMaterialInput
    remainingMaterials?: RemainingMaterialUncheckedCreateNestedManyWithoutMaterialInput
    products?: ProductUncheckedCreateNestedManyWithoutBaseMaterialInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutMaterialInput
    purchaseLogs?: PurchaseLogUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUpdateManyWithoutMaterialNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutMaterialNestedInput
    remainingMaterials?: RemainingMaterialUpdateManyWithoutMaterialNestedInput
    products?: ProductUpdateManyWithoutBaseMaterialNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutMaterialNestedInput
    purchaseLogs?: PurchaseLogUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutMaterialNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutMaterialNestedInput
    remainingMaterials?: RemainingMaterialUncheckedUpdateManyWithoutMaterialNestedInput
    products?: ProductUncheckedUpdateManyWithoutBaseMaterialNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutMaterialNestedInput
    purchaseLogs?: PurchaseLogUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    name: string
    code: string
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseMaterial?: MaterialCreateNestedOneWithoutProductsInput
    orderProducts?: OrderProductCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanCreateNestedManyWithoutProductInput
    colours?: ProductColourCreateNestedManyWithoutProductInput
    variations?: ProductVariationCreateNestedManyWithoutProductInput
    photos?: ProductPhotoCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    materialId?: number | null
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanUncheckedCreateNestedManyWithoutProductInput
    colours?: ProductColourUncheckedCreateNestedManyWithoutProductInput
    variations?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    photos?: ProductPhotoUncheckedCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseMaterial?: MaterialUpdateOneWithoutProductsNestedInput
    orderProducts?: OrderProductUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUpdateManyWithoutProductNestedInput
    colours?: ProductColourUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUncheckedUpdateManyWithoutProductNestedInput
    colours?: ProductColourUncheckedUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUncheckedUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    code: string
    materialId?: number | null
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    worker?: UserCreateNestedOneWithoutWorkerOrdersInput
    workerContact?: ContactCreateNestedOneWithoutWorkerOrdersInput
    orderProducts?: OrderProductCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkCreateNestedOneWithoutOrderInput
    shipment?: ShipmentCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerId?: number | null
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkUncheckedCreateNestedOneWithoutOrderInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    worker?: UserUpdateOneWithoutWorkerOrdersNestedInput
    workerContact?: ContactUpdateOneWithoutWorkerOrdersNestedInput
    orderProducts?: OrderProductUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUncheckedUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerId?: number | null
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderProductCreateInput = {
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderProductsInput
    product: ProductCreateNestedOneWithoutOrderProductsInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutOrderProductInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutOrderProductInput
  }

  export type OrderProductUncheckedCreateInput = {
    id?: number
    orderId: number
    productId: number
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderProductInput
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutOrderProductInput
  }

  export type OrderProductUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderProductsNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutOrderProductNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutOrderProductNestedInput
  }

  export type OrderProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutOrderProductNestedInput
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutOrderProductNestedInput
  }

  export type OrderProductCreateManyInput = {
    id?: number
    orderId: number
    productId: number
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderProductUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialMovementCreateInput = {
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutMaterialMovementsInput
    order?: OrderCreateNestedOneWithoutMaterialMovementsInput
    user: UserCreateNestedOneWithoutMaterialMovementsInput
    purchaseLog?: PurchaseLogCreateNestedOneWithoutMovementInput
  }

  export type MaterialMovementUncheckedCreateInput = {
    id?: number
    materialId: number
    orderId?: number | null
    userId: number
    purchaseLogId?: number | null
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialMovementUpdateInput = {
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutMaterialMovementsNestedInput
    order?: OrderUpdateOneWithoutMaterialMovementsNestedInput
    user?: UserUpdateOneRequiredWithoutMaterialMovementsNestedInput
    purchaseLog?: PurchaseLogUpdateOneWithoutMovementNestedInput
  }

  export type MaterialMovementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialMovementCreateManyInput = {
    id?: number
    materialId: number
    orderId?: number | null
    userId: number
    purchaseLogId?: number | null
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialMovementUpdateManyMutationInput = {
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialMovementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressReportCreateInput = {
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutProgressReportsInput
    orderProduct?: OrderProductCreateNestedOneWithoutIndividualProgressReportsInput
    product?: ProductCreateNestedOneWithoutIndividualProgressReportsInput
    user: UserCreateNestedOneWithoutProgressReportsInput
    productReports?: ProductProgressReportCreateNestedManyWithoutProgressReportInput
  }

  export type ProgressReportUncheckedCreateInput = {
    id?: number
    orderId?: number | null
    orderProductId?: number | null
    productId?: number | null
    userId: number
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProgressReportInput
  }

  export type ProgressReportUpdateInput = {
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutProgressReportsNestedInput
    orderProduct?: OrderProductUpdateOneWithoutIndividualProgressReportsNestedInput
    product?: ProductUpdateOneWithoutIndividualProgressReportsNestedInput
    user?: UserUpdateOneRequiredWithoutProgressReportsNestedInput
    productReports?: ProductProgressReportUpdateManyWithoutProgressReportNestedInput
  }

  export type ProgressReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productReports?: ProductProgressReportUncheckedUpdateManyWithoutProgressReportNestedInput
  }

  export type ProgressReportCreateManyInput = {
    id?: number
    orderId?: number | null
    orderProductId?: number | null
    productId?: number | null
    userId: number
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgressReportUpdateManyMutationInput = {
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProgressReportCreateInput = {
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progressReport: ProgressReportCreateNestedOneWithoutProductReportsInput
    product: ProductCreateNestedOneWithoutProductProgressReportsInput
    orderProduct?: OrderProductCreateNestedOneWithoutProductProgressReportsInput
    photos?: ProductProgressPhotoCreateNestedManyWithoutProductProgressReportInput
  }

  export type ProductProgressReportUncheckedCreateInput = {
    id?: number
    progressReportId: number
    productId: number
    orderProductId?: number | null
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ProductProgressPhotoUncheckedCreateNestedManyWithoutProductProgressReportInput
  }

  export type ProductProgressReportUpdateInput = {
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressReport?: ProgressReportUpdateOneRequiredWithoutProductReportsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductProgressReportsNestedInput
    orderProduct?: OrderProductUpdateOneWithoutProductProgressReportsNestedInput
    photos?: ProductProgressPhotoUpdateManyWithoutProductProgressReportNestedInput
  }

  export type ProductProgressReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    progressReportId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ProductProgressPhotoUncheckedUpdateManyWithoutProductProgressReportNestedInput
  }

  export type ProductProgressReportCreateManyInput = {
    id?: number
    progressReportId: number
    productId: number
    orderProductId?: number | null
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProgressReportUpdateManyMutationInput = {
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProgressReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    progressReportId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProgressPhotoCreateInput = {
    photoPath: string
    thumbnailPath?: string | null
    description?: string | null
    uploadDate?: Date | string
    fileSize?: number | null
    mimeType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productProgressReport: ProductProgressReportCreateNestedOneWithoutPhotosInput
  }

  export type ProductProgressPhotoUncheckedCreateInput = {
    id?: number
    productProgressReportId: number
    photoPath: string
    thumbnailPath?: string | null
    description?: string | null
    uploadDate?: Date | string
    fileSize?: number | null
    mimeType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProgressPhotoUpdateInput = {
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProgressReport?: ProductProgressReportUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type ProductProgressPhotoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productProgressReportId?: IntFieldUpdateOperationsInput | number
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProgressPhotoCreateManyInput = {
    id?: number
    productProgressReportId: number
    photoPath: string
    thumbnailPath?: string | null
    description?: string | null
    uploadDate?: Date | string
    fileSize?: number | null
    mimeType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProgressPhotoUpdateManyMutationInput = {
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProgressPhotoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productProgressReportId?: IntFieldUpdateOperationsInput | number
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemainingMaterialCreateInput = {
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutRemainingMaterialsInput
  }

  export type RemainingMaterialUncheckedCreateInput = {
    id?: number
    materialId: number
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RemainingMaterialUpdateInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutRemainingMaterialsNestedInput
  }

  export type RemainingMaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemainingMaterialCreateManyInput = {
    id?: number
    materialId: number
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RemainingMaterialUpdateManyMutationInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemainingMaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarisCreateInput = {
    name: string
    quantity?: number
    unit?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventarisUncheckedCreateInput = {
    id?: number
    name: string
    quantity?: number
    unit?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventarisUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarisCreateManyInput = {
    id?: number
    name: string
    quantity?: number
    unit?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventarisUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventarisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderLinkCreateInput = {
    linkToken: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderLinkInput
    user: UserCreateNestedOneWithoutOrderLinksInput
  }

  export type OrderLinkUncheckedCreateInput = {
    id?: number
    orderId: number
    userId: number
    linkToken: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderLinkUpdateInput = {
    linkToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderLinkNestedInput
    user?: UserUpdateOneRequiredWithoutOrderLinksNestedInput
  }

  export type OrderLinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    linkToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderLinkCreateManyInput = {
    id?: number
    orderId: number
    userId: number
    linkToken: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderLinkUpdateManyMutationInput = {
    linkToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderLinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    linkToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMaterialCreateInput = {
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductMaterialsInput
    material: MaterialCreateNestedOneWithoutProductMaterialsInput
  }

  export type ProductMaterialUncheckedCreateInput = {
    id?: number
    productId: number
    materialId: number
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductMaterialUpdateInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductMaterialsNestedInput
    material?: MaterialUpdateOneRequiredWithoutProductMaterialsNestedInput
  }

  export type ProductMaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMaterialCreateManyInput = {
    id?: number
    productId: number
    materialId: number
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductMaterialUpdateManyMutationInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentCreateInput = {
    trackingNumber?: string | null
    carrier?: string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    status?: $Enums.ShipmentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateInput = {
    id?: number
    orderId: number
    trackingNumber?: string | null
    carrier?: string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    status?: $Enums.ShipmentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShipmentUpdateInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentCreateManyInput = {
    id?: number
    orderId: number
    trackingNumber?: string | null
    carrier?: string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    status?: $Enums.ShipmentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShipmentUpdateManyMutationInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringPlanCreateInput = {
    quantity?: number
    frequency?: string
    isActive?: boolean
    nextDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutRecurringPlansInput
  }

  export type RecurringPlanUncheckedCreateInput = {
    id?: number
    productId: number
    quantity?: number
    frequency?: string
    isActive?: boolean
    nextDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringPlanUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutRecurringPlansNestedInput
  }

  export type RecurringPlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringPlanCreateManyInput = {
    id?: number
    productId: number
    quantity?: number
    frequency?: string
    isActive?: boolean
    nextDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringPlanUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringPlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusChangeCreateInput = {
    fromStatus: $Enums.OrderStatus
    toStatus: $Enums.OrderStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutStatusChangesInput
    user: UserCreateNestedOneWithoutStatusChangesInput
  }

  export type StatusChangeUncheckedCreateInput = {
    id?: number
    orderId: number
    changedBy: number
    fromStatus: $Enums.OrderStatus
    toStatus: $Enums.OrderStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusChangeUpdateInput = {
    fromStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutStatusChangesNestedInput
    user?: UserUpdateOneRequiredWithoutStatusChangesNestedInput
  }

  export type StatusChangeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    changedBy?: IntFieldUpdateOperationsInput | number
    fromStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusChangeCreateManyInput = {
    id?: number
    orderId: number
    changedBy: number
    fromStatus: $Enums.OrderStatus
    toStatus: $Enums.OrderStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusChangeUpdateManyMutationInput = {
    fromStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusChangeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    changedBy?: IntFieldUpdateOperationsInput | number
    fromStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductColourCreateInput = {
    colorName: string
    colorCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutColoursInput
  }

  export type ProductColourUncheckedCreateInput = {
    id?: number
    productId: number
    colorName: string
    colorCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductColourUpdateInput = {
    colorName?: StringFieldUpdateOperationsInput | string
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutColoursNestedInput
  }

  export type ProductColourUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    colorName?: StringFieldUpdateOperationsInput | string
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductColourCreateManyInput = {
    id?: number
    productId: number
    colorName: string
    colorCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductColourUpdateManyMutationInput = {
    colorName?: StringFieldUpdateOperationsInput | string
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductColourUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    colorName?: StringFieldUpdateOperationsInput | string
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationCreateInput = {
    variationType: string
    variationValue: string
    priceAdjustment?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariationsInput
  }

  export type ProductVariationUncheckedCreateInput = {
    id?: number
    productId: number
    variationType: string
    variationValue: string
    priceAdjustment?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationUpdateInput = {
    variationType?: StringFieldUpdateOperationsInput | string
    variationValue?: StringFieldUpdateOperationsInput | string
    priceAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariationsNestedInput
  }

  export type ProductVariationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    variationType?: StringFieldUpdateOperationsInput | string
    variationValue?: StringFieldUpdateOperationsInput | string
    priceAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationCreateManyInput = {
    id?: number
    productId: number
    variationType: string
    variationValue: string
    priceAdjustment?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationUpdateManyMutationInput = {
    variationType?: StringFieldUpdateOperationsInput | string
    variationValue?: StringFieldUpdateOperationsInput | string
    priceAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    variationType?: StringFieldUpdateOperationsInput | string
    variationValue?: StringFieldUpdateOperationsInput | string
    priceAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPhotoCreateInput = {
    photoPath: string
    thumbnailPath?: string | null
    description?: string | null
    isPrimary?: boolean
    sortOrder?: number
    fileSize?: number | null
    mimeType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutPhotosInput
  }

  export type ProductPhotoUncheckedCreateInput = {
    id?: number
    productId: number
    photoPath: string
    thumbnailPath?: string | null
    description?: string | null
    isPrimary?: boolean
    sortOrder?: number
    fileSize?: number | null
    mimeType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductPhotoUpdateInput = {
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type ProductPhotoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPhotoCreateManyInput = {
    id?: number
    productId: number
    photoPath: string
    thumbnailPath?: string | null
    description?: string | null
    isPrimary?: boolean
    sortOrder?: number
    fileSize?: number | null
    mimeType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductPhotoUpdateManyMutationInput = {
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPhotoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialPurchaseAlertCreateInput = {
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutPurchaseAlertsInput
    order?: OrderCreateNestedOneWithoutPurchaseAlertsInput
    createdByUser: UserCreateNestedOneWithoutCreatedAlertsInput
    resolvedByUser?: UserCreateNestedOneWithoutResolvedAlertsInput
  }

  export type MaterialPurchaseAlertUncheckedCreateInput = {
    id?: number
    materialId: number
    orderId?: number | null
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    createdBy: number
    resolvedBy?: number | null
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialPurchaseAlertUpdateInput = {
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutPurchaseAlertsNestedInput
    order?: OrderUpdateOneWithoutPurchaseAlertsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutCreatedAlertsNestedInput
    resolvedByUser?: UserUpdateOneWithoutResolvedAlertsNestedInput
  }

  export type MaterialPurchaseAlertUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    createdBy?: IntFieldUpdateOperationsInput | number
    resolvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialPurchaseAlertCreateManyInput = {
    id?: number
    materialId: number
    orderId?: number | null
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    createdBy: number
    resolvedBy?: number | null
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialPurchaseAlertUpdateManyMutationInput = {
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialPurchaseAlertUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    createdBy?: IntFieldUpdateOperationsInput | number
    resolvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseLogCreateInput = {
    supplier: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    pricePerUnit?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    invoiceNumber?: string | null
    receiptPath?: string | null
    notes?: string | null
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    receivedQuantity?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutPurchaseLogsInput
    movement?: MaterialMovementCreateNestedOneWithoutPurchaseLogInput
    contactNotes?: ContactNoteCreateNestedManyWithoutPurchaseLogInput
  }

  export type PurchaseLogUncheckedCreateInput = {
    id?: number
    materialId: number
    supplier: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    pricePerUnit?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    invoiceNumber?: string | null
    receiptPath?: string | null
    notes?: string | null
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    receivedQuantity?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movement?: MaterialMovementUncheckedCreateNestedOneWithoutPurchaseLogInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutPurchaseLogInput
  }

  export type PurchaseLogUpdateInput = {
    supplier?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    pricePerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedQuantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutPurchaseLogsNestedInput
    movement?: MaterialMovementUpdateOneWithoutPurchaseLogNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutPurchaseLogNestedInput
  }

  export type PurchaseLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    supplier?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    pricePerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedQuantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movement?: MaterialMovementUncheckedUpdateOneWithoutPurchaseLogNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutPurchaseLogNestedInput
  }

  export type PurchaseLogCreateManyInput = {
    id?: number
    materialId: number
    supplier: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    pricePerUnit?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    invoiceNumber?: string | null
    receiptPath?: string | null
    notes?: string | null
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    receivedQuantity?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseLogUpdateManyMutationInput = {
    supplier?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    pricePerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedQuantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    supplier?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    pricePerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedQuantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    name: string
    phone?: string | null
    whatsappPhone?: string | null
    email?: string | null
    address?: string | null
    contactType: $Enums.ContactType
    company?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workerOrders?: OrderCreateNestedManyWithoutWorkerContactInput
    contactNotes?: ContactNoteCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: number
    name: string
    phone?: string | null
    whatsappPhone?: string | null
    email?: string | null
    address?: string | null
    contactType: $Enums.ContactType
    company?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workerOrders?: OrderUncheckedCreateNestedManyWithoutWorkerContactInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workerOrders?: OrderUpdateManyWithoutWorkerContactNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workerOrders?: OrderUncheckedUpdateManyWithoutWorkerContactNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: number
    name: string
    phone?: string | null
    whatsappPhone?: string | null
    email?: string | null
    address?: string | null
    contactType: $Enums.ContactType
    company?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteCreateInput = {
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutContactNotesInput
    order?: OrderCreateNestedOneWithoutContactNotesInput
    purchaseLog?: PurchaseLogCreateNestedOneWithoutContactNotesInput
    createdByUser: UserCreateNestedOneWithoutCreatedContactNotesInput
  }

  export type ContactNoteUncheckedCreateInput = {
    id?: number
    contactId: number
    orderId?: number | null
    purchaseLogId?: number | null
    createdBy: number
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactNoteUpdateInput = {
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutContactNotesNestedInput
    order?: OrderUpdateOneWithoutContactNotesNestedInput
    purchaseLog?: PurchaseLogUpdateOneWithoutContactNotesNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutCreatedContactNotesNestedInput
  }

  export type ContactNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: IntFieldUpdateOperationsInput | number
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteCreateManyInput = {
    id?: number
    contactId: number
    orderId?: number | null
    purchaseLogId?: number | null
    createdBy: number
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactNoteUpdateManyMutationInput = {
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: IntFieldUpdateOperationsInput | number
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type MaterialMovementListRelationFilter = {
    every?: MaterialMovementWhereInput
    some?: MaterialMovementWhereInput
    none?: MaterialMovementWhereInput
  }

  export type ProgressReportListRelationFilter = {
    every?: ProgressReportWhereInput
    some?: ProgressReportWhereInput
    none?: ProgressReportWhereInput
  }

  export type OrderLinkListRelationFilter = {
    every?: OrderLinkWhereInput
    some?: OrderLinkWhereInput
    none?: OrderLinkWhereInput
  }

  export type StatusChangeListRelationFilter = {
    every?: StatusChangeWhereInput
    some?: StatusChangeWhereInput
    none?: StatusChangeWhereInput
  }

  export type MaterialPurchaseAlertListRelationFilter = {
    every?: MaterialPurchaseAlertWhereInput
    some?: MaterialPurchaseAlertWhereInput
    none?: MaterialPurchaseAlertWhereInput
  }

  export type ContactNoteListRelationFilter = {
    every?: ContactNoteWhereInput
    some?: ContactNoteWhereInput
    none?: ContactNoteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgressReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StatusChangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialPurchaseAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsappPhone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    loginEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsappPhone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    loginEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsappPhone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    loginEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ProductMaterialListRelationFilter = {
    every?: ProductMaterialWhereInput
    some?: ProductMaterialWhereInput
    none?: ProductMaterialWhereInput
  }

  export type RemainingMaterialListRelationFilter = {
    every?: RemainingMaterialWhereInput
    some?: RemainingMaterialWhereInput
    none?: RemainingMaterialWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type PurchaseLogListRelationFilter = {
    every?: PurchaseLogWhereInput
    some?: PurchaseLogWhereInput
    none?: PurchaseLogWhereInput
  }

  export type ProductMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RemainingMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    unit?: SortOrder
    qtyOnHand?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
    location?: SortOrder
    attributeType?: SortOrder
    attributeValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    id?: SortOrder
    qtyOnHand?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    unit?: SortOrder
    qtyOnHand?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
    location?: SortOrder
    attributeType?: SortOrder
    attributeValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    unit?: SortOrder
    qtyOnHand?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
    location?: SortOrder
    attributeType?: SortOrder
    attributeValue?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    id?: SortOrder
    qtyOnHand?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type MaterialNullableScalarRelationFilter = {
    is?: MaterialWhereInput | null
    isNot?: MaterialWhereInput | null
  }

  export type OrderProductListRelationFilter = {
    every?: OrderProductWhereInput
    some?: OrderProductWhereInput
    none?: OrderProductWhereInput
  }

  export type RecurringPlanListRelationFilter = {
    every?: RecurringPlanWhereInput
    some?: RecurringPlanWhereInput
    none?: RecurringPlanWhereInput
  }

  export type ProductColourListRelationFilter = {
    every?: ProductColourWhereInput
    some?: ProductColourWhereInput
    none?: ProductColourWhereInput
  }

  export type ProductVariationListRelationFilter = {
    every?: ProductVariationWhereInput
    some?: ProductVariationWhereInput
    none?: ProductVariationWhereInput
  }

  export type ProductPhotoListRelationFilter = {
    every?: ProductPhotoWhereInput
    some?: ProductPhotoWhereInput
    none?: ProductPhotoWhereInput
  }

  export type ProductProgressReportListRelationFilter = {
    every?: ProductProgressReportWhereInput
    some?: ProductProgressReportWhereInput
    none?: ProductProgressReportWhereInput
  }

  export type OrderProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecurringPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductColourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductVariationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductProgressReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    materialId?: SortOrder
    category?: SortOrder
    price?: SortOrder
    qtyOnHand?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    defaultTarget?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    price?: SortOrder
    qtyOnHand?: SortOrder
    defaultTarget?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    materialId?: SortOrder
    category?: SortOrder
    price?: SortOrder
    qtyOnHand?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    defaultTarget?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    materialId?: SortOrder
    category?: SortOrder
    price?: SortOrder
    qtyOnHand?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    defaultTarget?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    price?: SortOrder
    qtyOnHand?: SortOrder
    defaultTarget?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type OrderLinkNullableScalarRelationFilter = {
    is?: OrderLinkWhereInput | null
    isNot?: OrderLinkWhereInput | null
  }

  export type ShipmentNullableScalarRelationFilter = {
    is?: ShipmentWhereInput | null
    isNot?: ShipmentWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    targetPcs?: SortOrder
    completedPcs?: SortOrder
    customerNote?: SortOrder
    dueDate?: SortOrder
    userId?: SortOrder
    workerId?: SortOrder
    workerContactId?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    targetPcs?: SortOrder
    completedPcs?: SortOrder
    userId?: SortOrder
    workerId?: SortOrder
    workerContactId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    targetPcs?: SortOrder
    completedPcs?: SortOrder
    customerNote?: SortOrder
    dueDate?: SortOrder
    userId?: SortOrder
    workerId?: SortOrder
    workerContactId?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    targetPcs?: SortOrder
    completedPcs?: SortOrder
    customerNote?: SortOrder
    dueDate?: SortOrder
    userId?: SortOrder
    workerId?: SortOrder
    workerContactId?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    targetPcs?: SortOrder
    completedPcs?: SortOrder
    userId?: SortOrder
    workerId?: SortOrder
    workerContactId?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumOrderProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderProductStatus | EnumOrderProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderProductStatus[] | ListEnumOrderProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderProductStatus[] | ListEnumOrderProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderProductStatusFilter<$PrismaModel> | $Enums.OrderProductStatus
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type OrderProductCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    notes?: SortOrder
    completedQty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderProductAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    completedQty?: SortOrder
  }

  export type OrderProductMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    notes?: SortOrder
    completedQty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderProductMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    notes?: SortOrder
    completedQty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderProductSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    completedQty?: SortOrder
  }

  export type EnumOrderProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderProductStatus | EnumOrderProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderProductStatus[] | ListEnumOrderProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderProductStatus[] | ListEnumOrderProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderProductStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderProductStatusFilter<$PrismaModel>
  }

  export type EnumMaterialMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialMovementType | EnumMaterialMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialMovementType[] | ListEnumMaterialMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialMovementType[] | ListEnumMaterialMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialMovementTypeFilter<$PrismaModel> | $Enums.MaterialMovementType
  }

  export type MaterialScalarRelationFilter = {
    is?: MaterialWhereInput
    isNot?: MaterialWhereInput
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type PurchaseLogNullableScalarRelationFilter = {
    is?: PurchaseLogWhereInput | null
    isNot?: PurchaseLogWhereInput | null
  }

  export type MaterialMovementCountOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    purchaseLogId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    costPerUnit?: SortOrder
    totalCost?: SortOrder
    notes?: SortOrder
    qtyAfter?: SortOrder
    movementDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialMovementAvgOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    purchaseLogId?: SortOrder
    quantity?: SortOrder
    costPerUnit?: SortOrder
    totalCost?: SortOrder
    qtyAfter?: SortOrder
  }

  export type MaterialMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    purchaseLogId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    costPerUnit?: SortOrder
    totalCost?: SortOrder
    notes?: SortOrder
    qtyAfter?: SortOrder
    movementDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialMovementMinOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    purchaseLogId?: SortOrder
    movementType?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    costPerUnit?: SortOrder
    totalCost?: SortOrder
    notes?: SortOrder
    qtyAfter?: SortOrder
    movementDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialMovementSumOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    purchaseLogId?: SortOrder
    quantity?: SortOrder
    costPerUnit?: SortOrder
    totalCost?: SortOrder
    qtyAfter?: SortOrder
  }

  export type EnumMaterialMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialMovementType | EnumMaterialMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialMovementType[] | ListEnumMaterialMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialMovementType[] | ListEnumMaterialMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaterialMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumMaterialMovementTypeFilter<$PrismaModel>
  }

  export type OrderProductNullableScalarRelationFilter = {
    is?: OrderProductWhereInput | null
    isNot?: OrderProductWhereInput | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ProgressReportCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderProductId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    reportText?: SortOrder
    photoPath?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgressReportAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderProductId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    percentage?: SortOrder
  }

  export type ProgressReportMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderProductId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    reportText?: SortOrder
    photoPath?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgressReportMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderProductId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    reportText?: SortOrder
    photoPath?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgressReportSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderProductId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    percentage?: SortOrder
  }

  export type ProgressReportScalarRelationFilter = {
    is?: ProgressReportWhereInput
    isNot?: ProgressReportWhereInput
  }

  export type ProductProgressPhotoListRelationFilter = {
    every?: ProductProgressPhotoWhereInput
    some?: ProductProgressPhotoWhereInput
    none?: ProductProgressPhotoWhereInput
  }

  export type ProductProgressPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductProgressReportCountOrderByAggregateInput = {
    id?: SortOrder
    progressReportId?: SortOrder
    productId?: SortOrder
    orderProductId?: SortOrder
    itemsCompleted?: SortOrder
    itemsTarget?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    completionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductProgressReportAvgOrderByAggregateInput = {
    id?: SortOrder
    progressReportId?: SortOrder
    productId?: SortOrder
    orderProductId?: SortOrder
    itemsCompleted?: SortOrder
    itemsTarget?: SortOrder
  }

  export type ProductProgressReportMaxOrderByAggregateInput = {
    id?: SortOrder
    progressReportId?: SortOrder
    productId?: SortOrder
    orderProductId?: SortOrder
    itemsCompleted?: SortOrder
    itemsTarget?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    completionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductProgressReportMinOrderByAggregateInput = {
    id?: SortOrder
    progressReportId?: SortOrder
    productId?: SortOrder
    orderProductId?: SortOrder
    itemsCompleted?: SortOrder
    itemsTarget?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    completionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductProgressReportSumOrderByAggregateInput = {
    id?: SortOrder
    progressReportId?: SortOrder
    productId?: SortOrder
    orderProductId?: SortOrder
    itemsCompleted?: SortOrder
    itemsTarget?: SortOrder
  }

  export type ProductProgressReportScalarRelationFilter = {
    is?: ProductProgressReportWhereInput
    isNot?: ProductProgressReportWhereInput
  }

  export type ProductProgressPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    productProgressReportId?: SortOrder
    photoPath?: SortOrder
    thumbnailPath?: SortOrder
    description?: SortOrder
    uploadDate?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductProgressPhotoAvgOrderByAggregateInput = {
    id?: SortOrder
    productProgressReportId?: SortOrder
    fileSize?: SortOrder
  }

  export type ProductProgressPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    productProgressReportId?: SortOrder
    photoPath?: SortOrder
    thumbnailPath?: SortOrder
    description?: SortOrder
    uploadDate?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductProgressPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    productProgressReportId?: SortOrder
    photoPath?: SortOrder
    thumbnailPath?: SortOrder
    description?: SortOrder
    uploadDate?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductProgressPhotoSumOrderByAggregateInput = {
    id?: SortOrder
    productProgressReportId?: SortOrder
    fileSize?: SortOrder
  }

  export type RemainingMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RemainingMaterialAvgOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
  }

  export type RemainingMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RemainingMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RemainingMaterialSumOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
  }

  export type InventarisCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventarisAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
  }

  export type InventarisMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventarisMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventarisSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
  }

  export type OrderLinkCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    linkToken?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderLinkAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
  }

  export type OrderLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    linkToken?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderLinkMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    linkToken?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderLinkSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
  }

  export type ProductMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMaterialAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMaterialSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
  }

  export type EnumShipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusFilter<$PrismaModel> | $Enums.ShipmentStatus
  }

  export type ShipmentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    shippedDate?: SortOrder
    deliveredDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type ShipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    shippedDate?: SortOrder
    deliveredDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShipmentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    shippedDate?: SortOrder
    deliveredDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShipmentSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type EnumShipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumShipmentStatusFilter<$PrismaModel>
  }

  export type RecurringPlanCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    nextDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringPlanAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type RecurringPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    nextDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringPlanMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    frequency?: SortOrder
    isActive?: SortOrder
    nextDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringPlanSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type StatusChangeCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    changedBy?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusChangeAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    changedBy?: SortOrder
  }

  export type StatusChangeMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    changedBy?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusChangeMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    changedBy?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusChangeSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    changedBy?: SortOrder
  }

  export type ProductColourCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    colorName?: SortOrder
    colorCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductColourAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductColourMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    colorName?: SortOrder
    colorCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductColourMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    colorName?: SortOrder
    colorCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductColourSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductVariationCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    variationType?: SortOrder
    variationValue?: SortOrder
    priceAdjustment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariationAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    priceAdjustment?: SortOrder
  }

  export type ProductVariationMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    variationType?: SortOrder
    variationValue?: SortOrder
    priceAdjustment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariationMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    variationType?: SortOrder
    variationValue?: SortOrder
    priceAdjustment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariationSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    priceAdjustment?: SortOrder
  }

  export type ProductPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    photoPath?: SortOrder
    thumbnailPath?: SortOrder
    description?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductPhotoAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    fileSize?: SortOrder
  }

  export type ProductPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    photoPath?: SortOrder
    thumbnailPath?: SortOrder
    description?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    photoPath?: SortOrder
    thumbnailPath?: SortOrder
    description?: SortOrder
    isPrimary?: SortOrder
    sortOrder?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductPhotoSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sortOrder?: SortOrder
    fileSize?: SortOrder
  }

  export type EnumMaterialPurchaseAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialPurchaseAlertType | EnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialPurchaseAlertType[] | ListEnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialPurchaseAlertType[] | ListEnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialPurchaseAlertTypeFilter<$PrismaModel> | $Enums.MaterialPurchaseAlertType
  }

  export type EnumUrgencyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.UrgencyLevel | EnumUrgencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumUrgencyLevelFilter<$PrismaModel> | $Enums.UrgencyLevel
  }

  export type EnumAlertStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusFilter<$PrismaModel> | $Enums.AlertStatus
  }

  export type MaterialPurchaseAlertCountOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrder
    alertType?: SortOrder
    requiredQuantity?: SortOrder
    currentStock?: SortOrder
    urgencyLevel?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    resolution?: SortOrder
    estimatedCost?: SortOrder
    suggestedSupplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialPurchaseAlertAvgOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrder
    requiredQuantity?: SortOrder
    currentStock?: SortOrder
    createdBy?: SortOrder
    resolvedBy?: SortOrder
    estimatedCost?: SortOrder
  }

  export type MaterialPurchaseAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrder
    alertType?: SortOrder
    requiredQuantity?: SortOrder
    currentStock?: SortOrder
    urgencyLevel?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    resolution?: SortOrder
    estimatedCost?: SortOrder
    suggestedSupplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialPurchaseAlertMinOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrder
    alertType?: SortOrder
    requiredQuantity?: SortOrder
    currentStock?: SortOrder
    urgencyLevel?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    resolution?: SortOrder
    estimatedCost?: SortOrder
    suggestedSupplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialPurchaseAlertSumOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    orderId?: SortOrder
    requiredQuantity?: SortOrder
    currentStock?: SortOrder
    createdBy?: SortOrder
    resolvedBy?: SortOrder
    estimatedCost?: SortOrder
  }

  export type EnumMaterialPurchaseAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialPurchaseAlertType | EnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialPurchaseAlertType[] | ListEnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialPurchaseAlertType[] | ListEnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialPurchaseAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaterialPurchaseAlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialPurchaseAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumMaterialPurchaseAlertTypeFilter<$PrismaModel>
  }

  export type EnumUrgencyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UrgencyLevel | EnumUrgencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumUrgencyLevelWithAggregatesFilter<$PrismaModel> | $Enums.UrgencyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUrgencyLevelFilter<$PrismaModel>
    _max?: NestedEnumUrgencyLevelFilter<$PrismaModel>
  }

  export type EnumAlertStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertStatusFilter<$PrismaModel>
  }

  export type EnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type MaterialMovementNullableScalarRelationFilter = {
    is?: MaterialMovementWhereInput | null
    isNot?: MaterialMovementWhereInput | null
  }

  export type PurchaseLogCountOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    supplier?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    pricePerUnit?: SortOrder
    totalCost?: SortOrder
    purchaseDate?: SortOrder
    invoiceNumber?: SortOrder
    receiptPath?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    deliveryDate?: SortOrder
    receivedQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseLogAvgOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalCost?: SortOrder
    receivedQuantity?: SortOrder
  }

  export type PurchaseLogMaxOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    supplier?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    pricePerUnit?: SortOrder
    totalCost?: SortOrder
    purchaseDate?: SortOrder
    invoiceNumber?: SortOrder
    receiptPath?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    deliveryDate?: SortOrder
    receivedQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseLogMinOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    supplier?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    pricePerUnit?: SortOrder
    totalCost?: SortOrder
    purchaseDate?: SortOrder
    invoiceNumber?: SortOrder
    receiptPath?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    deliveryDate?: SortOrder
    receivedQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseLogSumOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    pricePerUnit?: SortOrder
    totalCost?: SortOrder
    receivedQuantity?: SortOrder
  }

  export type EnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type EnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    whatsappPhone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    contactType?: SortOrder
    company?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    whatsappPhone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    contactType?: SortOrder
    company?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    whatsappPhone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    contactType?: SortOrder
    company?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type EnumNoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeFilter<$PrismaModel> | $Enums.NoteType
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type ContactNoteCountOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    orderId?: SortOrder
    purchaseLogId?: SortOrder
    createdBy?: SortOrder
    noteType?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    followUpDate?: SortOrder
    isImportant?: SortOrder
    tags?: SortOrder
    attachmentPath?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    orderId?: SortOrder
    purchaseLogId?: SortOrder
    createdBy?: SortOrder
  }

  export type ContactNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    orderId?: SortOrder
    purchaseLogId?: SortOrder
    createdBy?: SortOrder
    noteType?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    followUpDate?: SortOrder
    isImportant?: SortOrder
    tags?: SortOrder
    attachmentPath?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactNoteMinOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    orderId?: SortOrder
    purchaseLogId?: SortOrder
    createdBy?: SortOrder
    noteType?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    followUpDate?: SortOrder
    isImportant?: SortOrder
    tags?: SortOrder
    attachmentPath?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactNoteSumOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    orderId?: SortOrder
    purchaseLogId?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumNoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.NoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteTypeFilter<$PrismaModel>
    _max?: NestedEnumNoteTypeFilter<$PrismaModel>
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutWorkerInput = {
    create?: XOR<OrderCreateWithoutWorkerInput, OrderUncheckedCreateWithoutWorkerInput> | OrderCreateWithoutWorkerInput[] | OrderUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkerInput | OrderCreateOrConnectWithoutWorkerInput[]
    createMany?: OrderCreateManyWorkerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type MaterialMovementCreateNestedManyWithoutUserInput = {
    create?: XOR<MaterialMovementCreateWithoutUserInput, MaterialMovementUncheckedCreateWithoutUserInput> | MaterialMovementCreateWithoutUserInput[] | MaterialMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutUserInput | MaterialMovementCreateOrConnectWithoutUserInput[]
    createMany?: MaterialMovementCreateManyUserInputEnvelope
    connect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
  }

  export type ProgressReportCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgressReportCreateWithoutUserInput, ProgressReportUncheckedCreateWithoutUserInput> | ProgressReportCreateWithoutUserInput[] | ProgressReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutUserInput | ProgressReportCreateOrConnectWithoutUserInput[]
    createMany?: ProgressReportCreateManyUserInputEnvelope
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
  }

  export type OrderLinkCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderLinkCreateWithoutUserInput, OrderLinkUncheckedCreateWithoutUserInput> | OrderLinkCreateWithoutUserInput[] | OrderLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderLinkCreateOrConnectWithoutUserInput | OrderLinkCreateOrConnectWithoutUserInput[]
    createMany?: OrderLinkCreateManyUserInputEnvelope
    connect?: OrderLinkWhereUniqueInput | OrderLinkWhereUniqueInput[]
  }

  export type StatusChangeCreateNestedManyWithoutUserInput = {
    create?: XOR<StatusChangeCreateWithoutUserInput, StatusChangeUncheckedCreateWithoutUserInput> | StatusChangeCreateWithoutUserInput[] | StatusChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StatusChangeCreateOrConnectWithoutUserInput | StatusChangeCreateOrConnectWithoutUserInput[]
    createMany?: StatusChangeCreateManyUserInputEnvelope
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
  }

  export type MaterialPurchaseAlertCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutCreatedByUserInput, MaterialPurchaseAlertUncheckedCreateWithoutCreatedByUserInput> | MaterialPurchaseAlertCreateWithoutCreatedByUserInput[] | MaterialPurchaseAlertUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutCreatedByUserInput | MaterialPurchaseAlertCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: MaterialPurchaseAlertCreateManyCreatedByUserInputEnvelope
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
  }

  export type MaterialPurchaseAlertCreateNestedManyWithoutResolvedByUserInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutResolvedByUserInput, MaterialPurchaseAlertUncheckedCreateWithoutResolvedByUserInput> | MaterialPurchaseAlertCreateWithoutResolvedByUserInput[] | MaterialPurchaseAlertUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutResolvedByUserInput | MaterialPurchaseAlertCreateOrConnectWithoutResolvedByUserInput[]
    createMany?: MaterialPurchaseAlertCreateManyResolvedByUserInputEnvelope
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
  }

  export type ContactNoteCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<ContactNoteCreateWithoutCreatedByUserInput, ContactNoteUncheckedCreateWithoutCreatedByUserInput> | ContactNoteCreateWithoutCreatedByUserInput[] | ContactNoteUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutCreatedByUserInput | ContactNoteCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: ContactNoteCreateManyCreatedByUserInputEnvelope
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutWorkerInput = {
    create?: XOR<OrderCreateWithoutWorkerInput, OrderUncheckedCreateWithoutWorkerInput> | OrderCreateWithoutWorkerInput[] | OrderUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkerInput | OrderCreateOrConnectWithoutWorkerInput[]
    createMany?: OrderCreateManyWorkerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type MaterialMovementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MaterialMovementCreateWithoutUserInput, MaterialMovementUncheckedCreateWithoutUserInput> | MaterialMovementCreateWithoutUserInput[] | MaterialMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutUserInput | MaterialMovementCreateOrConnectWithoutUserInput[]
    createMany?: MaterialMovementCreateManyUserInputEnvelope
    connect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
  }

  export type ProgressReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgressReportCreateWithoutUserInput, ProgressReportUncheckedCreateWithoutUserInput> | ProgressReportCreateWithoutUserInput[] | ProgressReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutUserInput | ProgressReportCreateOrConnectWithoutUserInput[]
    createMany?: ProgressReportCreateManyUserInputEnvelope
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
  }

  export type OrderLinkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderLinkCreateWithoutUserInput, OrderLinkUncheckedCreateWithoutUserInput> | OrderLinkCreateWithoutUserInput[] | OrderLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderLinkCreateOrConnectWithoutUserInput | OrderLinkCreateOrConnectWithoutUserInput[]
    createMany?: OrderLinkCreateManyUserInputEnvelope
    connect?: OrderLinkWhereUniqueInput | OrderLinkWhereUniqueInput[]
  }

  export type StatusChangeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StatusChangeCreateWithoutUserInput, StatusChangeUncheckedCreateWithoutUserInput> | StatusChangeCreateWithoutUserInput[] | StatusChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StatusChangeCreateOrConnectWithoutUserInput | StatusChangeCreateOrConnectWithoutUserInput[]
    createMany?: StatusChangeCreateManyUserInputEnvelope
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
  }

  export type MaterialPurchaseAlertUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutCreatedByUserInput, MaterialPurchaseAlertUncheckedCreateWithoutCreatedByUserInput> | MaterialPurchaseAlertCreateWithoutCreatedByUserInput[] | MaterialPurchaseAlertUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutCreatedByUserInput | MaterialPurchaseAlertCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: MaterialPurchaseAlertCreateManyCreatedByUserInputEnvelope
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
  }

  export type MaterialPurchaseAlertUncheckedCreateNestedManyWithoutResolvedByUserInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutResolvedByUserInput, MaterialPurchaseAlertUncheckedCreateWithoutResolvedByUserInput> | MaterialPurchaseAlertCreateWithoutResolvedByUserInput[] | MaterialPurchaseAlertUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutResolvedByUserInput | MaterialPurchaseAlertCreateOrConnectWithoutResolvedByUserInput[]
    createMany?: MaterialPurchaseAlertCreateManyResolvedByUserInputEnvelope
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
  }

  export type ContactNoteUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<ContactNoteCreateWithoutCreatedByUserInput, ContactNoteUncheckedCreateWithoutCreatedByUserInput> | ContactNoteCreateWithoutCreatedByUserInput[] | ContactNoteUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutCreatedByUserInput | ContactNoteCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: ContactNoteCreateManyCreatedByUserInputEnvelope
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<OrderCreateWithoutWorkerInput, OrderUncheckedCreateWithoutWorkerInput> | OrderCreateWithoutWorkerInput[] | OrderUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkerInput | OrderCreateOrConnectWithoutWorkerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutWorkerInput | OrderUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: OrderCreateManyWorkerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutWorkerInput | OrderUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutWorkerInput | OrderUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type MaterialMovementUpdateManyWithoutUserNestedInput = {
    create?: XOR<MaterialMovementCreateWithoutUserInput, MaterialMovementUncheckedCreateWithoutUserInput> | MaterialMovementCreateWithoutUserInput[] | MaterialMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutUserInput | MaterialMovementCreateOrConnectWithoutUserInput[]
    upsert?: MaterialMovementUpsertWithWhereUniqueWithoutUserInput | MaterialMovementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MaterialMovementCreateManyUserInputEnvelope
    set?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    disconnect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    delete?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    connect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    update?: MaterialMovementUpdateWithWhereUniqueWithoutUserInput | MaterialMovementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MaterialMovementUpdateManyWithWhereWithoutUserInput | MaterialMovementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MaterialMovementScalarWhereInput | MaterialMovementScalarWhereInput[]
  }

  export type ProgressReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgressReportCreateWithoutUserInput, ProgressReportUncheckedCreateWithoutUserInput> | ProgressReportCreateWithoutUserInput[] | ProgressReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutUserInput | ProgressReportCreateOrConnectWithoutUserInput[]
    upsert?: ProgressReportUpsertWithWhereUniqueWithoutUserInput | ProgressReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgressReportCreateManyUserInputEnvelope
    set?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    disconnect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    delete?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    update?: ProgressReportUpdateWithWhereUniqueWithoutUserInput | ProgressReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgressReportUpdateManyWithWhereWithoutUserInput | ProgressReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
  }

  export type OrderLinkUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderLinkCreateWithoutUserInput, OrderLinkUncheckedCreateWithoutUserInput> | OrderLinkCreateWithoutUserInput[] | OrderLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderLinkCreateOrConnectWithoutUserInput | OrderLinkCreateOrConnectWithoutUserInput[]
    upsert?: OrderLinkUpsertWithWhereUniqueWithoutUserInput | OrderLinkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderLinkCreateManyUserInputEnvelope
    set?: OrderLinkWhereUniqueInput | OrderLinkWhereUniqueInput[]
    disconnect?: OrderLinkWhereUniqueInput | OrderLinkWhereUniqueInput[]
    delete?: OrderLinkWhereUniqueInput | OrderLinkWhereUniqueInput[]
    connect?: OrderLinkWhereUniqueInput | OrderLinkWhereUniqueInput[]
    update?: OrderLinkUpdateWithWhereUniqueWithoutUserInput | OrderLinkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderLinkUpdateManyWithWhereWithoutUserInput | OrderLinkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderLinkScalarWhereInput | OrderLinkScalarWhereInput[]
  }

  export type StatusChangeUpdateManyWithoutUserNestedInput = {
    create?: XOR<StatusChangeCreateWithoutUserInput, StatusChangeUncheckedCreateWithoutUserInput> | StatusChangeCreateWithoutUserInput[] | StatusChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StatusChangeCreateOrConnectWithoutUserInput | StatusChangeCreateOrConnectWithoutUserInput[]
    upsert?: StatusChangeUpsertWithWhereUniqueWithoutUserInput | StatusChangeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StatusChangeCreateManyUserInputEnvelope
    set?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    disconnect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    delete?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    update?: StatusChangeUpdateWithWhereUniqueWithoutUserInput | StatusChangeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StatusChangeUpdateManyWithWhereWithoutUserInput | StatusChangeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StatusChangeScalarWhereInput | StatusChangeScalarWhereInput[]
  }

  export type MaterialPurchaseAlertUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutCreatedByUserInput, MaterialPurchaseAlertUncheckedCreateWithoutCreatedByUserInput> | MaterialPurchaseAlertCreateWithoutCreatedByUserInput[] | MaterialPurchaseAlertUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutCreatedByUserInput | MaterialPurchaseAlertCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: MaterialPurchaseAlertUpsertWithWhereUniqueWithoutCreatedByUserInput | MaterialPurchaseAlertUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: MaterialPurchaseAlertCreateManyCreatedByUserInputEnvelope
    set?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    disconnect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    delete?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    update?: MaterialPurchaseAlertUpdateWithWhereUniqueWithoutCreatedByUserInput | MaterialPurchaseAlertUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: MaterialPurchaseAlertUpdateManyWithWhereWithoutCreatedByUserInput | MaterialPurchaseAlertUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: MaterialPurchaseAlertScalarWhereInput | MaterialPurchaseAlertScalarWhereInput[]
  }

  export type MaterialPurchaseAlertUpdateManyWithoutResolvedByUserNestedInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutResolvedByUserInput, MaterialPurchaseAlertUncheckedCreateWithoutResolvedByUserInput> | MaterialPurchaseAlertCreateWithoutResolvedByUserInput[] | MaterialPurchaseAlertUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutResolvedByUserInput | MaterialPurchaseAlertCreateOrConnectWithoutResolvedByUserInput[]
    upsert?: MaterialPurchaseAlertUpsertWithWhereUniqueWithoutResolvedByUserInput | MaterialPurchaseAlertUpsertWithWhereUniqueWithoutResolvedByUserInput[]
    createMany?: MaterialPurchaseAlertCreateManyResolvedByUserInputEnvelope
    set?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    disconnect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    delete?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    update?: MaterialPurchaseAlertUpdateWithWhereUniqueWithoutResolvedByUserInput | MaterialPurchaseAlertUpdateWithWhereUniqueWithoutResolvedByUserInput[]
    updateMany?: MaterialPurchaseAlertUpdateManyWithWhereWithoutResolvedByUserInput | MaterialPurchaseAlertUpdateManyWithWhereWithoutResolvedByUserInput[]
    deleteMany?: MaterialPurchaseAlertScalarWhereInput | MaterialPurchaseAlertScalarWhereInput[]
  }

  export type ContactNoteUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<ContactNoteCreateWithoutCreatedByUserInput, ContactNoteUncheckedCreateWithoutCreatedByUserInput> | ContactNoteCreateWithoutCreatedByUserInput[] | ContactNoteUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutCreatedByUserInput | ContactNoteCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: ContactNoteUpsertWithWhereUniqueWithoutCreatedByUserInput | ContactNoteUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: ContactNoteCreateManyCreatedByUserInputEnvelope
    set?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    disconnect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    delete?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    update?: ContactNoteUpdateWithWhereUniqueWithoutCreatedByUserInput | ContactNoteUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: ContactNoteUpdateManyWithWhereWithoutCreatedByUserInput | ContactNoteUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<OrderCreateWithoutWorkerInput, OrderUncheckedCreateWithoutWorkerInput> | OrderCreateWithoutWorkerInput[] | OrderUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkerInput | OrderCreateOrConnectWithoutWorkerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutWorkerInput | OrderUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: OrderCreateManyWorkerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutWorkerInput | OrderUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutWorkerInput | OrderUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type MaterialMovementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MaterialMovementCreateWithoutUserInput, MaterialMovementUncheckedCreateWithoutUserInput> | MaterialMovementCreateWithoutUserInput[] | MaterialMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutUserInput | MaterialMovementCreateOrConnectWithoutUserInput[]
    upsert?: MaterialMovementUpsertWithWhereUniqueWithoutUserInput | MaterialMovementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MaterialMovementCreateManyUserInputEnvelope
    set?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    disconnect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    delete?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    connect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    update?: MaterialMovementUpdateWithWhereUniqueWithoutUserInput | MaterialMovementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MaterialMovementUpdateManyWithWhereWithoutUserInput | MaterialMovementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MaterialMovementScalarWhereInput | MaterialMovementScalarWhereInput[]
  }

  export type ProgressReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgressReportCreateWithoutUserInput, ProgressReportUncheckedCreateWithoutUserInput> | ProgressReportCreateWithoutUserInput[] | ProgressReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutUserInput | ProgressReportCreateOrConnectWithoutUserInput[]
    upsert?: ProgressReportUpsertWithWhereUniqueWithoutUserInput | ProgressReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgressReportCreateManyUserInputEnvelope
    set?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    disconnect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    delete?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    update?: ProgressReportUpdateWithWhereUniqueWithoutUserInput | ProgressReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgressReportUpdateManyWithWhereWithoutUserInput | ProgressReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
  }

  export type OrderLinkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderLinkCreateWithoutUserInput, OrderLinkUncheckedCreateWithoutUserInput> | OrderLinkCreateWithoutUserInput[] | OrderLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderLinkCreateOrConnectWithoutUserInput | OrderLinkCreateOrConnectWithoutUserInput[]
    upsert?: OrderLinkUpsertWithWhereUniqueWithoutUserInput | OrderLinkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderLinkCreateManyUserInputEnvelope
    set?: OrderLinkWhereUniqueInput | OrderLinkWhereUniqueInput[]
    disconnect?: OrderLinkWhereUniqueInput | OrderLinkWhereUniqueInput[]
    delete?: OrderLinkWhereUniqueInput | OrderLinkWhereUniqueInput[]
    connect?: OrderLinkWhereUniqueInput | OrderLinkWhereUniqueInput[]
    update?: OrderLinkUpdateWithWhereUniqueWithoutUserInput | OrderLinkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderLinkUpdateManyWithWhereWithoutUserInput | OrderLinkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderLinkScalarWhereInput | OrderLinkScalarWhereInput[]
  }

  export type StatusChangeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StatusChangeCreateWithoutUserInput, StatusChangeUncheckedCreateWithoutUserInput> | StatusChangeCreateWithoutUserInput[] | StatusChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StatusChangeCreateOrConnectWithoutUserInput | StatusChangeCreateOrConnectWithoutUserInput[]
    upsert?: StatusChangeUpsertWithWhereUniqueWithoutUserInput | StatusChangeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StatusChangeCreateManyUserInputEnvelope
    set?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    disconnect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    delete?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    update?: StatusChangeUpdateWithWhereUniqueWithoutUserInput | StatusChangeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StatusChangeUpdateManyWithWhereWithoutUserInput | StatusChangeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StatusChangeScalarWhereInput | StatusChangeScalarWhereInput[]
  }

  export type MaterialPurchaseAlertUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutCreatedByUserInput, MaterialPurchaseAlertUncheckedCreateWithoutCreatedByUserInput> | MaterialPurchaseAlertCreateWithoutCreatedByUserInput[] | MaterialPurchaseAlertUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutCreatedByUserInput | MaterialPurchaseAlertCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: MaterialPurchaseAlertUpsertWithWhereUniqueWithoutCreatedByUserInput | MaterialPurchaseAlertUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: MaterialPurchaseAlertCreateManyCreatedByUserInputEnvelope
    set?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    disconnect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    delete?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    update?: MaterialPurchaseAlertUpdateWithWhereUniqueWithoutCreatedByUserInput | MaterialPurchaseAlertUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: MaterialPurchaseAlertUpdateManyWithWhereWithoutCreatedByUserInput | MaterialPurchaseAlertUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: MaterialPurchaseAlertScalarWhereInput | MaterialPurchaseAlertScalarWhereInput[]
  }

  export type MaterialPurchaseAlertUncheckedUpdateManyWithoutResolvedByUserNestedInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutResolvedByUserInput, MaterialPurchaseAlertUncheckedCreateWithoutResolvedByUserInput> | MaterialPurchaseAlertCreateWithoutResolvedByUserInput[] | MaterialPurchaseAlertUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutResolvedByUserInput | MaterialPurchaseAlertCreateOrConnectWithoutResolvedByUserInput[]
    upsert?: MaterialPurchaseAlertUpsertWithWhereUniqueWithoutResolvedByUserInput | MaterialPurchaseAlertUpsertWithWhereUniqueWithoutResolvedByUserInput[]
    createMany?: MaterialPurchaseAlertCreateManyResolvedByUserInputEnvelope
    set?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    disconnect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    delete?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    update?: MaterialPurchaseAlertUpdateWithWhereUniqueWithoutResolvedByUserInput | MaterialPurchaseAlertUpdateWithWhereUniqueWithoutResolvedByUserInput[]
    updateMany?: MaterialPurchaseAlertUpdateManyWithWhereWithoutResolvedByUserInput | MaterialPurchaseAlertUpdateManyWithWhereWithoutResolvedByUserInput[]
    deleteMany?: MaterialPurchaseAlertScalarWhereInput | MaterialPurchaseAlertScalarWhereInput[]
  }

  export type ContactNoteUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<ContactNoteCreateWithoutCreatedByUserInput, ContactNoteUncheckedCreateWithoutCreatedByUserInput> | ContactNoteCreateWithoutCreatedByUserInput[] | ContactNoteUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutCreatedByUserInput | ContactNoteCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: ContactNoteUpsertWithWhereUniqueWithoutCreatedByUserInput | ContactNoteUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: ContactNoteCreateManyCreatedByUserInputEnvelope
    set?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    disconnect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    delete?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    update?: ContactNoteUpdateWithWhereUniqueWithoutCreatedByUserInput | ContactNoteUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: ContactNoteUpdateManyWithWhereWithoutCreatedByUserInput | ContactNoteUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
  }

  export type MaterialMovementCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MaterialMovementCreateWithoutMaterialInput, MaterialMovementUncheckedCreateWithoutMaterialInput> | MaterialMovementCreateWithoutMaterialInput[] | MaterialMovementUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutMaterialInput | MaterialMovementCreateOrConnectWithoutMaterialInput[]
    createMany?: MaterialMovementCreateManyMaterialInputEnvelope
    connect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
  }

  export type ProductMaterialCreateNestedManyWithoutMaterialInput = {
    create?: XOR<ProductMaterialCreateWithoutMaterialInput, ProductMaterialUncheckedCreateWithoutMaterialInput> | ProductMaterialCreateWithoutMaterialInput[] | ProductMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ProductMaterialCreateOrConnectWithoutMaterialInput | ProductMaterialCreateOrConnectWithoutMaterialInput[]
    createMany?: ProductMaterialCreateManyMaterialInputEnvelope
    connect?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
  }

  export type RemainingMaterialCreateNestedManyWithoutMaterialInput = {
    create?: XOR<RemainingMaterialCreateWithoutMaterialInput, RemainingMaterialUncheckedCreateWithoutMaterialInput> | RemainingMaterialCreateWithoutMaterialInput[] | RemainingMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: RemainingMaterialCreateOrConnectWithoutMaterialInput | RemainingMaterialCreateOrConnectWithoutMaterialInput[]
    createMany?: RemainingMaterialCreateManyMaterialInputEnvelope
    connect?: RemainingMaterialWhereUniqueInput | RemainingMaterialWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutBaseMaterialInput = {
    create?: XOR<ProductCreateWithoutBaseMaterialInput, ProductUncheckedCreateWithoutBaseMaterialInput> | ProductCreateWithoutBaseMaterialInput[] | ProductUncheckedCreateWithoutBaseMaterialInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBaseMaterialInput | ProductCreateOrConnectWithoutBaseMaterialInput[]
    createMany?: ProductCreateManyBaseMaterialInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type MaterialPurchaseAlertCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutMaterialInput, MaterialPurchaseAlertUncheckedCreateWithoutMaterialInput> | MaterialPurchaseAlertCreateWithoutMaterialInput[] | MaterialPurchaseAlertUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutMaterialInput | MaterialPurchaseAlertCreateOrConnectWithoutMaterialInput[]
    createMany?: MaterialPurchaseAlertCreateManyMaterialInputEnvelope
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
  }

  export type PurchaseLogCreateNestedManyWithoutMaterialInput = {
    create?: XOR<PurchaseLogCreateWithoutMaterialInput, PurchaseLogUncheckedCreateWithoutMaterialInput> | PurchaseLogCreateWithoutMaterialInput[] | PurchaseLogUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PurchaseLogCreateOrConnectWithoutMaterialInput | PurchaseLogCreateOrConnectWithoutMaterialInput[]
    createMany?: PurchaseLogCreateManyMaterialInputEnvelope
    connect?: PurchaseLogWhereUniqueInput | PurchaseLogWhereUniqueInput[]
  }

  export type MaterialMovementUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MaterialMovementCreateWithoutMaterialInput, MaterialMovementUncheckedCreateWithoutMaterialInput> | MaterialMovementCreateWithoutMaterialInput[] | MaterialMovementUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutMaterialInput | MaterialMovementCreateOrConnectWithoutMaterialInput[]
    createMany?: MaterialMovementCreateManyMaterialInputEnvelope
    connect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
  }

  export type ProductMaterialUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<ProductMaterialCreateWithoutMaterialInput, ProductMaterialUncheckedCreateWithoutMaterialInput> | ProductMaterialCreateWithoutMaterialInput[] | ProductMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ProductMaterialCreateOrConnectWithoutMaterialInput | ProductMaterialCreateOrConnectWithoutMaterialInput[]
    createMany?: ProductMaterialCreateManyMaterialInputEnvelope
    connect?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
  }

  export type RemainingMaterialUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<RemainingMaterialCreateWithoutMaterialInput, RemainingMaterialUncheckedCreateWithoutMaterialInput> | RemainingMaterialCreateWithoutMaterialInput[] | RemainingMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: RemainingMaterialCreateOrConnectWithoutMaterialInput | RemainingMaterialCreateOrConnectWithoutMaterialInput[]
    createMany?: RemainingMaterialCreateManyMaterialInputEnvelope
    connect?: RemainingMaterialWhereUniqueInput | RemainingMaterialWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBaseMaterialInput = {
    create?: XOR<ProductCreateWithoutBaseMaterialInput, ProductUncheckedCreateWithoutBaseMaterialInput> | ProductCreateWithoutBaseMaterialInput[] | ProductUncheckedCreateWithoutBaseMaterialInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBaseMaterialInput | ProductCreateOrConnectWithoutBaseMaterialInput[]
    createMany?: ProductCreateManyBaseMaterialInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type MaterialPurchaseAlertUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutMaterialInput, MaterialPurchaseAlertUncheckedCreateWithoutMaterialInput> | MaterialPurchaseAlertCreateWithoutMaterialInput[] | MaterialPurchaseAlertUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutMaterialInput | MaterialPurchaseAlertCreateOrConnectWithoutMaterialInput[]
    createMany?: MaterialPurchaseAlertCreateManyMaterialInputEnvelope
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
  }

  export type PurchaseLogUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<PurchaseLogCreateWithoutMaterialInput, PurchaseLogUncheckedCreateWithoutMaterialInput> | PurchaseLogCreateWithoutMaterialInput[] | PurchaseLogUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PurchaseLogCreateOrConnectWithoutMaterialInput | PurchaseLogCreateOrConnectWithoutMaterialInput[]
    createMany?: PurchaseLogCreateManyMaterialInputEnvelope
    connect?: PurchaseLogWhereUniqueInput | PurchaseLogWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type MaterialMovementUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MaterialMovementCreateWithoutMaterialInput, MaterialMovementUncheckedCreateWithoutMaterialInput> | MaterialMovementCreateWithoutMaterialInput[] | MaterialMovementUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutMaterialInput | MaterialMovementCreateOrConnectWithoutMaterialInput[]
    upsert?: MaterialMovementUpsertWithWhereUniqueWithoutMaterialInput | MaterialMovementUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MaterialMovementCreateManyMaterialInputEnvelope
    set?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    disconnect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    delete?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    connect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    update?: MaterialMovementUpdateWithWhereUniqueWithoutMaterialInput | MaterialMovementUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MaterialMovementUpdateManyWithWhereWithoutMaterialInput | MaterialMovementUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MaterialMovementScalarWhereInput | MaterialMovementScalarWhereInput[]
  }

  export type ProductMaterialUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<ProductMaterialCreateWithoutMaterialInput, ProductMaterialUncheckedCreateWithoutMaterialInput> | ProductMaterialCreateWithoutMaterialInput[] | ProductMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ProductMaterialCreateOrConnectWithoutMaterialInput | ProductMaterialCreateOrConnectWithoutMaterialInput[]
    upsert?: ProductMaterialUpsertWithWhereUniqueWithoutMaterialInput | ProductMaterialUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: ProductMaterialCreateManyMaterialInputEnvelope
    set?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    disconnect?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    delete?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    connect?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    update?: ProductMaterialUpdateWithWhereUniqueWithoutMaterialInput | ProductMaterialUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: ProductMaterialUpdateManyWithWhereWithoutMaterialInput | ProductMaterialUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: ProductMaterialScalarWhereInput | ProductMaterialScalarWhereInput[]
  }

  export type RemainingMaterialUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<RemainingMaterialCreateWithoutMaterialInput, RemainingMaterialUncheckedCreateWithoutMaterialInput> | RemainingMaterialCreateWithoutMaterialInput[] | RemainingMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: RemainingMaterialCreateOrConnectWithoutMaterialInput | RemainingMaterialCreateOrConnectWithoutMaterialInput[]
    upsert?: RemainingMaterialUpsertWithWhereUniqueWithoutMaterialInput | RemainingMaterialUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: RemainingMaterialCreateManyMaterialInputEnvelope
    set?: RemainingMaterialWhereUniqueInput | RemainingMaterialWhereUniqueInput[]
    disconnect?: RemainingMaterialWhereUniqueInput | RemainingMaterialWhereUniqueInput[]
    delete?: RemainingMaterialWhereUniqueInput | RemainingMaterialWhereUniqueInput[]
    connect?: RemainingMaterialWhereUniqueInput | RemainingMaterialWhereUniqueInput[]
    update?: RemainingMaterialUpdateWithWhereUniqueWithoutMaterialInput | RemainingMaterialUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: RemainingMaterialUpdateManyWithWhereWithoutMaterialInput | RemainingMaterialUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: RemainingMaterialScalarWhereInput | RemainingMaterialScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutBaseMaterialNestedInput = {
    create?: XOR<ProductCreateWithoutBaseMaterialInput, ProductUncheckedCreateWithoutBaseMaterialInput> | ProductCreateWithoutBaseMaterialInput[] | ProductUncheckedCreateWithoutBaseMaterialInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBaseMaterialInput | ProductCreateOrConnectWithoutBaseMaterialInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBaseMaterialInput | ProductUpsertWithWhereUniqueWithoutBaseMaterialInput[]
    createMany?: ProductCreateManyBaseMaterialInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBaseMaterialInput | ProductUpdateWithWhereUniqueWithoutBaseMaterialInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBaseMaterialInput | ProductUpdateManyWithWhereWithoutBaseMaterialInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MaterialPurchaseAlertUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutMaterialInput, MaterialPurchaseAlertUncheckedCreateWithoutMaterialInput> | MaterialPurchaseAlertCreateWithoutMaterialInput[] | MaterialPurchaseAlertUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutMaterialInput | MaterialPurchaseAlertCreateOrConnectWithoutMaterialInput[]
    upsert?: MaterialPurchaseAlertUpsertWithWhereUniqueWithoutMaterialInput | MaterialPurchaseAlertUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MaterialPurchaseAlertCreateManyMaterialInputEnvelope
    set?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    disconnect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    delete?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    update?: MaterialPurchaseAlertUpdateWithWhereUniqueWithoutMaterialInput | MaterialPurchaseAlertUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MaterialPurchaseAlertUpdateManyWithWhereWithoutMaterialInput | MaterialPurchaseAlertUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MaterialPurchaseAlertScalarWhereInput | MaterialPurchaseAlertScalarWhereInput[]
  }

  export type PurchaseLogUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<PurchaseLogCreateWithoutMaterialInput, PurchaseLogUncheckedCreateWithoutMaterialInput> | PurchaseLogCreateWithoutMaterialInput[] | PurchaseLogUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PurchaseLogCreateOrConnectWithoutMaterialInput | PurchaseLogCreateOrConnectWithoutMaterialInput[]
    upsert?: PurchaseLogUpsertWithWhereUniqueWithoutMaterialInput | PurchaseLogUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: PurchaseLogCreateManyMaterialInputEnvelope
    set?: PurchaseLogWhereUniqueInput | PurchaseLogWhereUniqueInput[]
    disconnect?: PurchaseLogWhereUniqueInput | PurchaseLogWhereUniqueInput[]
    delete?: PurchaseLogWhereUniqueInput | PurchaseLogWhereUniqueInput[]
    connect?: PurchaseLogWhereUniqueInput | PurchaseLogWhereUniqueInput[]
    update?: PurchaseLogUpdateWithWhereUniqueWithoutMaterialInput | PurchaseLogUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: PurchaseLogUpdateManyWithWhereWithoutMaterialInput | PurchaseLogUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: PurchaseLogScalarWhereInput | PurchaseLogScalarWhereInput[]
  }

  export type MaterialMovementUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MaterialMovementCreateWithoutMaterialInput, MaterialMovementUncheckedCreateWithoutMaterialInput> | MaterialMovementCreateWithoutMaterialInput[] | MaterialMovementUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutMaterialInput | MaterialMovementCreateOrConnectWithoutMaterialInput[]
    upsert?: MaterialMovementUpsertWithWhereUniqueWithoutMaterialInput | MaterialMovementUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MaterialMovementCreateManyMaterialInputEnvelope
    set?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    disconnect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    delete?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    connect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    update?: MaterialMovementUpdateWithWhereUniqueWithoutMaterialInput | MaterialMovementUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MaterialMovementUpdateManyWithWhereWithoutMaterialInput | MaterialMovementUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MaterialMovementScalarWhereInput | MaterialMovementScalarWhereInput[]
  }

  export type ProductMaterialUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<ProductMaterialCreateWithoutMaterialInput, ProductMaterialUncheckedCreateWithoutMaterialInput> | ProductMaterialCreateWithoutMaterialInput[] | ProductMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ProductMaterialCreateOrConnectWithoutMaterialInput | ProductMaterialCreateOrConnectWithoutMaterialInput[]
    upsert?: ProductMaterialUpsertWithWhereUniqueWithoutMaterialInput | ProductMaterialUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: ProductMaterialCreateManyMaterialInputEnvelope
    set?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    disconnect?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    delete?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    connect?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    update?: ProductMaterialUpdateWithWhereUniqueWithoutMaterialInput | ProductMaterialUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: ProductMaterialUpdateManyWithWhereWithoutMaterialInput | ProductMaterialUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: ProductMaterialScalarWhereInput | ProductMaterialScalarWhereInput[]
  }

  export type RemainingMaterialUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<RemainingMaterialCreateWithoutMaterialInput, RemainingMaterialUncheckedCreateWithoutMaterialInput> | RemainingMaterialCreateWithoutMaterialInput[] | RemainingMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: RemainingMaterialCreateOrConnectWithoutMaterialInput | RemainingMaterialCreateOrConnectWithoutMaterialInput[]
    upsert?: RemainingMaterialUpsertWithWhereUniqueWithoutMaterialInput | RemainingMaterialUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: RemainingMaterialCreateManyMaterialInputEnvelope
    set?: RemainingMaterialWhereUniqueInput | RemainingMaterialWhereUniqueInput[]
    disconnect?: RemainingMaterialWhereUniqueInput | RemainingMaterialWhereUniqueInput[]
    delete?: RemainingMaterialWhereUniqueInput | RemainingMaterialWhereUniqueInput[]
    connect?: RemainingMaterialWhereUniqueInput | RemainingMaterialWhereUniqueInput[]
    update?: RemainingMaterialUpdateWithWhereUniqueWithoutMaterialInput | RemainingMaterialUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: RemainingMaterialUpdateManyWithWhereWithoutMaterialInput | RemainingMaterialUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: RemainingMaterialScalarWhereInput | RemainingMaterialScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBaseMaterialNestedInput = {
    create?: XOR<ProductCreateWithoutBaseMaterialInput, ProductUncheckedCreateWithoutBaseMaterialInput> | ProductCreateWithoutBaseMaterialInput[] | ProductUncheckedCreateWithoutBaseMaterialInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBaseMaterialInput | ProductCreateOrConnectWithoutBaseMaterialInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBaseMaterialInput | ProductUpsertWithWhereUniqueWithoutBaseMaterialInput[]
    createMany?: ProductCreateManyBaseMaterialInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBaseMaterialInput | ProductUpdateWithWhereUniqueWithoutBaseMaterialInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBaseMaterialInput | ProductUpdateManyWithWhereWithoutBaseMaterialInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MaterialPurchaseAlertUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutMaterialInput, MaterialPurchaseAlertUncheckedCreateWithoutMaterialInput> | MaterialPurchaseAlertCreateWithoutMaterialInput[] | MaterialPurchaseAlertUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutMaterialInput | MaterialPurchaseAlertCreateOrConnectWithoutMaterialInput[]
    upsert?: MaterialPurchaseAlertUpsertWithWhereUniqueWithoutMaterialInput | MaterialPurchaseAlertUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MaterialPurchaseAlertCreateManyMaterialInputEnvelope
    set?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    disconnect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    delete?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    update?: MaterialPurchaseAlertUpdateWithWhereUniqueWithoutMaterialInput | MaterialPurchaseAlertUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MaterialPurchaseAlertUpdateManyWithWhereWithoutMaterialInput | MaterialPurchaseAlertUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MaterialPurchaseAlertScalarWhereInput | MaterialPurchaseAlertScalarWhereInput[]
  }

  export type PurchaseLogUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<PurchaseLogCreateWithoutMaterialInput, PurchaseLogUncheckedCreateWithoutMaterialInput> | PurchaseLogCreateWithoutMaterialInput[] | PurchaseLogUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: PurchaseLogCreateOrConnectWithoutMaterialInput | PurchaseLogCreateOrConnectWithoutMaterialInput[]
    upsert?: PurchaseLogUpsertWithWhereUniqueWithoutMaterialInput | PurchaseLogUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: PurchaseLogCreateManyMaterialInputEnvelope
    set?: PurchaseLogWhereUniqueInput | PurchaseLogWhereUniqueInput[]
    disconnect?: PurchaseLogWhereUniqueInput | PurchaseLogWhereUniqueInput[]
    delete?: PurchaseLogWhereUniqueInput | PurchaseLogWhereUniqueInput[]
    connect?: PurchaseLogWhereUniqueInput | PurchaseLogWhereUniqueInput[]
    update?: PurchaseLogUpdateWithWhereUniqueWithoutMaterialInput | PurchaseLogUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: PurchaseLogUpdateManyWithWhereWithoutMaterialInput | PurchaseLogUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: PurchaseLogScalarWhereInput | PurchaseLogScalarWhereInput[]
  }

  export type MaterialCreateNestedOneWithoutProductsInput = {
    create?: XOR<MaterialCreateWithoutProductsInput, MaterialUncheckedCreateWithoutProductsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutProductsInput
    connect?: MaterialWhereUniqueInput
  }

  export type OrderProductCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput> | OrderProductCreateWithoutProductInput[] | OrderProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutProductInput | OrderProductCreateOrConnectWithoutProductInput[]
    createMany?: OrderProductCreateManyProductInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type ProductMaterialCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductMaterialCreateWithoutProductInput, ProductMaterialUncheckedCreateWithoutProductInput> | ProductMaterialCreateWithoutProductInput[] | ProductMaterialUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductMaterialCreateOrConnectWithoutProductInput | ProductMaterialCreateOrConnectWithoutProductInput[]
    createMany?: ProductMaterialCreateManyProductInputEnvelope
    connect?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
  }

  export type RecurringPlanCreateNestedManyWithoutProductInput = {
    create?: XOR<RecurringPlanCreateWithoutProductInput, RecurringPlanUncheckedCreateWithoutProductInput> | RecurringPlanCreateWithoutProductInput[] | RecurringPlanUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RecurringPlanCreateOrConnectWithoutProductInput | RecurringPlanCreateOrConnectWithoutProductInput[]
    createMany?: RecurringPlanCreateManyProductInputEnvelope
    connect?: RecurringPlanWhereUniqueInput | RecurringPlanWhereUniqueInput[]
  }

  export type ProductColourCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductColourCreateWithoutProductInput, ProductColourUncheckedCreateWithoutProductInput> | ProductColourCreateWithoutProductInput[] | ProductColourUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductColourCreateOrConnectWithoutProductInput | ProductColourCreateOrConnectWithoutProductInput[]
    createMany?: ProductColourCreateManyProductInputEnvelope
    connect?: ProductColourWhereUniqueInput | ProductColourWhereUniqueInput[]
  }

  export type ProductVariationCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariationCreateWithoutProductInput, ProductVariationUncheckedCreateWithoutProductInput> | ProductVariationCreateWithoutProductInput[] | ProductVariationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariationCreateOrConnectWithoutProductInput | ProductVariationCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariationCreateManyProductInputEnvelope
    connect?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
  }

  export type ProductPhotoCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductPhotoCreateWithoutProductInput, ProductPhotoUncheckedCreateWithoutProductInput> | ProductPhotoCreateWithoutProductInput[] | ProductPhotoUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPhotoCreateOrConnectWithoutProductInput | ProductPhotoCreateOrConnectWithoutProductInput[]
    createMany?: ProductPhotoCreateManyProductInputEnvelope
    connect?: ProductPhotoWhereUniqueInput | ProductPhotoWhereUniqueInput[]
  }

  export type ProgressReportCreateNestedManyWithoutProductInput = {
    create?: XOR<ProgressReportCreateWithoutProductInput, ProgressReportUncheckedCreateWithoutProductInput> | ProgressReportCreateWithoutProductInput[] | ProgressReportUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutProductInput | ProgressReportCreateOrConnectWithoutProductInput[]
    createMany?: ProgressReportCreateManyProductInputEnvelope
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
  }

  export type ProductProgressReportCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductProgressReportCreateWithoutProductInput, ProductProgressReportUncheckedCreateWithoutProductInput> | ProductProgressReportCreateWithoutProductInput[] | ProductProgressReportUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutProductInput | ProductProgressReportCreateOrConnectWithoutProductInput[]
    createMany?: ProductProgressReportCreateManyProductInputEnvelope
    connect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
  }

  export type OrderProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput> | OrderProductCreateWithoutProductInput[] | OrderProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutProductInput | OrderProductCreateOrConnectWithoutProductInput[]
    createMany?: OrderProductCreateManyProductInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type ProductMaterialUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductMaterialCreateWithoutProductInput, ProductMaterialUncheckedCreateWithoutProductInput> | ProductMaterialCreateWithoutProductInput[] | ProductMaterialUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductMaterialCreateOrConnectWithoutProductInput | ProductMaterialCreateOrConnectWithoutProductInput[]
    createMany?: ProductMaterialCreateManyProductInputEnvelope
    connect?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
  }

  export type RecurringPlanUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<RecurringPlanCreateWithoutProductInput, RecurringPlanUncheckedCreateWithoutProductInput> | RecurringPlanCreateWithoutProductInput[] | RecurringPlanUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RecurringPlanCreateOrConnectWithoutProductInput | RecurringPlanCreateOrConnectWithoutProductInput[]
    createMany?: RecurringPlanCreateManyProductInputEnvelope
    connect?: RecurringPlanWhereUniqueInput | RecurringPlanWhereUniqueInput[]
  }

  export type ProductColourUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductColourCreateWithoutProductInput, ProductColourUncheckedCreateWithoutProductInput> | ProductColourCreateWithoutProductInput[] | ProductColourUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductColourCreateOrConnectWithoutProductInput | ProductColourCreateOrConnectWithoutProductInput[]
    createMany?: ProductColourCreateManyProductInputEnvelope
    connect?: ProductColourWhereUniqueInput | ProductColourWhereUniqueInput[]
  }

  export type ProductVariationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariationCreateWithoutProductInput, ProductVariationUncheckedCreateWithoutProductInput> | ProductVariationCreateWithoutProductInput[] | ProductVariationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariationCreateOrConnectWithoutProductInput | ProductVariationCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariationCreateManyProductInputEnvelope
    connect?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
  }

  export type ProductPhotoUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductPhotoCreateWithoutProductInput, ProductPhotoUncheckedCreateWithoutProductInput> | ProductPhotoCreateWithoutProductInput[] | ProductPhotoUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPhotoCreateOrConnectWithoutProductInput | ProductPhotoCreateOrConnectWithoutProductInput[]
    createMany?: ProductPhotoCreateManyProductInputEnvelope
    connect?: ProductPhotoWhereUniqueInput | ProductPhotoWhereUniqueInput[]
  }

  export type ProgressReportUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProgressReportCreateWithoutProductInput, ProgressReportUncheckedCreateWithoutProductInput> | ProgressReportCreateWithoutProductInput[] | ProgressReportUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutProductInput | ProgressReportCreateOrConnectWithoutProductInput[]
    createMany?: ProgressReportCreateManyProductInputEnvelope
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
  }

  export type ProductProgressReportUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductProgressReportCreateWithoutProductInput, ProductProgressReportUncheckedCreateWithoutProductInput> | ProductProgressReportCreateWithoutProductInput[] | ProductProgressReportUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutProductInput | ProductProgressReportCreateOrConnectWithoutProductInput[]
    createMany?: ProductProgressReportCreateManyProductInputEnvelope
    connect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type MaterialUpdateOneWithoutProductsNestedInput = {
    create?: XOR<MaterialCreateWithoutProductsInput, MaterialUncheckedCreateWithoutProductsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutProductsInput
    upsert?: MaterialUpsertWithoutProductsInput
    disconnect?: MaterialWhereInput | boolean
    delete?: MaterialWhereInput | boolean
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutProductsInput, MaterialUpdateWithoutProductsInput>, MaterialUncheckedUpdateWithoutProductsInput>
  }

  export type OrderProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput> | OrderProductCreateWithoutProductInput[] | OrderProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutProductInput | OrderProductCreateOrConnectWithoutProductInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutProductInput | OrderProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderProductCreateManyProductInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutProductInput | OrderProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutProductInput | OrderProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type ProductMaterialUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductMaterialCreateWithoutProductInput, ProductMaterialUncheckedCreateWithoutProductInput> | ProductMaterialCreateWithoutProductInput[] | ProductMaterialUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductMaterialCreateOrConnectWithoutProductInput | ProductMaterialCreateOrConnectWithoutProductInput[]
    upsert?: ProductMaterialUpsertWithWhereUniqueWithoutProductInput | ProductMaterialUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductMaterialCreateManyProductInputEnvelope
    set?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    disconnect?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    delete?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    connect?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    update?: ProductMaterialUpdateWithWhereUniqueWithoutProductInput | ProductMaterialUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductMaterialUpdateManyWithWhereWithoutProductInput | ProductMaterialUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductMaterialScalarWhereInput | ProductMaterialScalarWhereInput[]
  }

  export type RecurringPlanUpdateManyWithoutProductNestedInput = {
    create?: XOR<RecurringPlanCreateWithoutProductInput, RecurringPlanUncheckedCreateWithoutProductInput> | RecurringPlanCreateWithoutProductInput[] | RecurringPlanUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RecurringPlanCreateOrConnectWithoutProductInput | RecurringPlanCreateOrConnectWithoutProductInput[]
    upsert?: RecurringPlanUpsertWithWhereUniqueWithoutProductInput | RecurringPlanUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RecurringPlanCreateManyProductInputEnvelope
    set?: RecurringPlanWhereUniqueInput | RecurringPlanWhereUniqueInput[]
    disconnect?: RecurringPlanWhereUniqueInput | RecurringPlanWhereUniqueInput[]
    delete?: RecurringPlanWhereUniqueInput | RecurringPlanWhereUniqueInput[]
    connect?: RecurringPlanWhereUniqueInput | RecurringPlanWhereUniqueInput[]
    update?: RecurringPlanUpdateWithWhereUniqueWithoutProductInput | RecurringPlanUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RecurringPlanUpdateManyWithWhereWithoutProductInput | RecurringPlanUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RecurringPlanScalarWhereInput | RecurringPlanScalarWhereInput[]
  }

  export type ProductColourUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductColourCreateWithoutProductInput, ProductColourUncheckedCreateWithoutProductInput> | ProductColourCreateWithoutProductInput[] | ProductColourUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductColourCreateOrConnectWithoutProductInput | ProductColourCreateOrConnectWithoutProductInput[]
    upsert?: ProductColourUpsertWithWhereUniqueWithoutProductInput | ProductColourUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductColourCreateManyProductInputEnvelope
    set?: ProductColourWhereUniqueInput | ProductColourWhereUniqueInput[]
    disconnect?: ProductColourWhereUniqueInput | ProductColourWhereUniqueInput[]
    delete?: ProductColourWhereUniqueInput | ProductColourWhereUniqueInput[]
    connect?: ProductColourWhereUniqueInput | ProductColourWhereUniqueInput[]
    update?: ProductColourUpdateWithWhereUniqueWithoutProductInput | ProductColourUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductColourUpdateManyWithWhereWithoutProductInput | ProductColourUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductColourScalarWhereInput | ProductColourScalarWhereInput[]
  }

  export type ProductVariationUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariationCreateWithoutProductInput, ProductVariationUncheckedCreateWithoutProductInput> | ProductVariationCreateWithoutProductInput[] | ProductVariationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariationCreateOrConnectWithoutProductInput | ProductVariationCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariationUpsertWithWhereUniqueWithoutProductInput | ProductVariationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariationCreateManyProductInputEnvelope
    set?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    disconnect?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    delete?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    connect?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    update?: ProductVariationUpdateWithWhereUniqueWithoutProductInput | ProductVariationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariationUpdateManyWithWhereWithoutProductInput | ProductVariationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariationScalarWhereInput | ProductVariationScalarWhereInput[]
  }

  export type ProductPhotoUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductPhotoCreateWithoutProductInput, ProductPhotoUncheckedCreateWithoutProductInput> | ProductPhotoCreateWithoutProductInput[] | ProductPhotoUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPhotoCreateOrConnectWithoutProductInput | ProductPhotoCreateOrConnectWithoutProductInput[]
    upsert?: ProductPhotoUpsertWithWhereUniqueWithoutProductInput | ProductPhotoUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductPhotoCreateManyProductInputEnvelope
    set?: ProductPhotoWhereUniqueInput | ProductPhotoWhereUniqueInput[]
    disconnect?: ProductPhotoWhereUniqueInput | ProductPhotoWhereUniqueInput[]
    delete?: ProductPhotoWhereUniqueInput | ProductPhotoWhereUniqueInput[]
    connect?: ProductPhotoWhereUniqueInput | ProductPhotoWhereUniqueInput[]
    update?: ProductPhotoUpdateWithWhereUniqueWithoutProductInput | ProductPhotoUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductPhotoUpdateManyWithWhereWithoutProductInput | ProductPhotoUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductPhotoScalarWhereInput | ProductPhotoScalarWhereInput[]
  }

  export type ProgressReportUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProgressReportCreateWithoutProductInput, ProgressReportUncheckedCreateWithoutProductInput> | ProgressReportCreateWithoutProductInput[] | ProgressReportUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutProductInput | ProgressReportCreateOrConnectWithoutProductInput[]
    upsert?: ProgressReportUpsertWithWhereUniqueWithoutProductInput | ProgressReportUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProgressReportCreateManyProductInputEnvelope
    set?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    disconnect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    delete?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    update?: ProgressReportUpdateWithWhereUniqueWithoutProductInput | ProgressReportUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProgressReportUpdateManyWithWhereWithoutProductInput | ProgressReportUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
  }

  export type ProductProgressReportUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductProgressReportCreateWithoutProductInput, ProductProgressReportUncheckedCreateWithoutProductInput> | ProductProgressReportCreateWithoutProductInput[] | ProductProgressReportUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutProductInput | ProductProgressReportCreateOrConnectWithoutProductInput[]
    upsert?: ProductProgressReportUpsertWithWhereUniqueWithoutProductInput | ProductProgressReportUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductProgressReportCreateManyProductInputEnvelope
    set?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    disconnect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    delete?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    connect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    update?: ProductProgressReportUpdateWithWhereUniqueWithoutProductInput | ProductProgressReportUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductProgressReportUpdateManyWithWhereWithoutProductInput | ProductProgressReportUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductProgressReportScalarWhereInput | ProductProgressReportScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput> | OrderProductCreateWithoutProductInput[] | OrderProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutProductInput | OrderProductCreateOrConnectWithoutProductInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutProductInput | OrderProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderProductCreateManyProductInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutProductInput | OrderProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutProductInput | OrderProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type ProductMaterialUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductMaterialCreateWithoutProductInput, ProductMaterialUncheckedCreateWithoutProductInput> | ProductMaterialCreateWithoutProductInput[] | ProductMaterialUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductMaterialCreateOrConnectWithoutProductInput | ProductMaterialCreateOrConnectWithoutProductInput[]
    upsert?: ProductMaterialUpsertWithWhereUniqueWithoutProductInput | ProductMaterialUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductMaterialCreateManyProductInputEnvelope
    set?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    disconnect?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    delete?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    connect?: ProductMaterialWhereUniqueInput | ProductMaterialWhereUniqueInput[]
    update?: ProductMaterialUpdateWithWhereUniqueWithoutProductInput | ProductMaterialUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductMaterialUpdateManyWithWhereWithoutProductInput | ProductMaterialUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductMaterialScalarWhereInput | ProductMaterialScalarWhereInput[]
  }

  export type RecurringPlanUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<RecurringPlanCreateWithoutProductInput, RecurringPlanUncheckedCreateWithoutProductInput> | RecurringPlanCreateWithoutProductInput[] | RecurringPlanUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RecurringPlanCreateOrConnectWithoutProductInput | RecurringPlanCreateOrConnectWithoutProductInput[]
    upsert?: RecurringPlanUpsertWithWhereUniqueWithoutProductInput | RecurringPlanUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RecurringPlanCreateManyProductInputEnvelope
    set?: RecurringPlanWhereUniqueInput | RecurringPlanWhereUniqueInput[]
    disconnect?: RecurringPlanWhereUniqueInput | RecurringPlanWhereUniqueInput[]
    delete?: RecurringPlanWhereUniqueInput | RecurringPlanWhereUniqueInput[]
    connect?: RecurringPlanWhereUniqueInput | RecurringPlanWhereUniqueInput[]
    update?: RecurringPlanUpdateWithWhereUniqueWithoutProductInput | RecurringPlanUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RecurringPlanUpdateManyWithWhereWithoutProductInput | RecurringPlanUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RecurringPlanScalarWhereInput | RecurringPlanScalarWhereInput[]
  }

  export type ProductColourUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductColourCreateWithoutProductInput, ProductColourUncheckedCreateWithoutProductInput> | ProductColourCreateWithoutProductInput[] | ProductColourUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductColourCreateOrConnectWithoutProductInput | ProductColourCreateOrConnectWithoutProductInput[]
    upsert?: ProductColourUpsertWithWhereUniqueWithoutProductInput | ProductColourUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductColourCreateManyProductInputEnvelope
    set?: ProductColourWhereUniqueInput | ProductColourWhereUniqueInput[]
    disconnect?: ProductColourWhereUniqueInput | ProductColourWhereUniqueInput[]
    delete?: ProductColourWhereUniqueInput | ProductColourWhereUniqueInput[]
    connect?: ProductColourWhereUniqueInput | ProductColourWhereUniqueInput[]
    update?: ProductColourUpdateWithWhereUniqueWithoutProductInput | ProductColourUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductColourUpdateManyWithWhereWithoutProductInput | ProductColourUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductColourScalarWhereInput | ProductColourScalarWhereInput[]
  }

  export type ProductVariationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariationCreateWithoutProductInput, ProductVariationUncheckedCreateWithoutProductInput> | ProductVariationCreateWithoutProductInput[] | ProductVariationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariationCreateOrConnectWithoutProductInput | ProductVariationCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariationUpsertWithWhereUniqueWithoutProductInput | ProductVariationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariationCreateManyProductInputEnvelope
    set?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    disconnect?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    delete?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    connect?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    update?: ProductVariationUpdateWithWhereUniqueWithoutProductInput | ProductVariationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariationUpdateManyWithWhereWithoutProductInput | ProductVariationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariationScalarWhereInput | ProductVariationScalarWhereInput[]
  }

  export type ProductPhotoUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductPhotoCreateWithoutProductInput, ProductPhotoUncheckedCreateWithoutProductInput> | ProductPhotoCreateWithoutProductInput[] | ProductPhotoUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPhotoCreateOrConnectWithoutProductInput | ProductPhotoCreateOrConnectWithoutProductInput[]
    upsert?: ProductPhotoUpsertWithWhereUniqueWithoutProductInput | ProductPhotoUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductPhotoCreateManyProductInputEnvelope
    set?: ProductPhotoWhereUniqueInput | ProductPhotoWhereUniqueInput[]
    disconnect?: ProductPhotoWhereUniqueInput | ProductPhotoWhereUniqueInput[]
    delete?: ProductPhotoWhereUniqueInput | ProductPhotoWhereUniqueInput[]
    connect?: ProductPhotoWhereUniqueInput | ProductPhotoWhereUniqueInput[]
    update?: ProductPhotoUpdateWithWhereUniqueWithoutProductInput | ProductPhotoUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductPhotoUpdateManyWithWhereWithoutProductInput | ProductPhotoUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductPhotoScalarWhereInput | ProductPhotoScalarWhereInput[]
  }

  export type ProgressReportUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProgressReportCreateWithoutProductInput, ProgressReportUncheckedCreateWithoutProductInput> | ProgressReportCreateWithoutProductInput[] | ProgressReportUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutProductInput | ProgressReportCreateOrConnectWithoutProductInput[]
    upsert?: ProgressReportUpsertWithWhereUniqueWithoutProductInput | ProgressReportUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProgressReportCreateManyProductInputEnvelope
    set?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    disconnect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    delete?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    update?: ProgressReportUpdateWithWhereUniqueWithoutProductInput | ProgressReportUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProgressReportUpdateManyWithWhereWithoutProductInput | ProgressReportUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
  }

  export type ProductProgressReportUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductProgressReportCreateWithoutProductInput, ProductProgressReportUncheckedCreateWithoutProductInput> | ProductProgressReportCreateWithoutProductInput[] | ProductProgressReportUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutProductInput | ProductProgressReportCreateOrConnectWithoutProductInput[]
    upsert?: ProductProgressReportUpsertWithWhereUniqueWithoutProductInput | ProductProgressReportUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductProgressReportCreateManyProductInputEnvelope
    set?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    disconnect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    delete?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    connect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    update?: ProductProgressReportUpdateWithWhereUniqueWithoutProductInput | ProductProgressReportUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductProgressReportUpdateManyWithWhereWithoutProductInput | ProductProgressReportUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductProgressReportScalarWhereInput | ProductProgressReportScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkerOrdersInput = {
    create?: XOR<UserCreateWithoutWorkerOrdersInput, UserUncheckedCreateWithoutWorkerOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkerOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutWorkerOrdersInput = {
    create?: XOR<ContactCreateWithoutWorkerOrdersInput, ContactUncheckedCreateWithoutWorkerOrdersInput>
    connectOrCreate?: ContactCreateOrConnectWithoutWorkerOrdersInput
    connect?: ContactWhereUniqueInput
  }

  export type OrderProductCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput> | OrderProductCreateWithoutOrderInput[] | OrderProductUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutOrderInput | OrderProductCreateOrConnectWithoutOrderInput[]
    createMany?: OrderProductCreateManyOrderInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type MaterialMovementCreateNestedManyWithoutOrderInput = {
    create?: XOR<MaterialMovementCreateWithoutOrderInput, MaterialMovementUncheckedCreateWithoutOrderInput> | MaterialMovementCreateWithoutOrderInput[] | MaterialMovementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutOrderInput | MaterialMovementCreateOrConnectWithoutOrderInput[]
    createMany?: MaterialMovementCreateManyOrderInputEnvelope
    connect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
  }

  export type ProgressReportCreateNestedManyWithoutOrderInput = {
    create?: XOR<ProgressReportCreateWithoutOrderInput, ProgressReportUncheckedCreateWithoutOrderInput> | ProgressReportCreateWithoutOrderInput[] | ProgressReportUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutOrderInput | ProgressReportCreateOrConnectWithoutOrderInput[]
    createMany?: ProgressReportCreateManyOrderInputEnvelope
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
  }

  export type OrderLinkCreateNestedOneWithoutOrderInput = {
    create?: XOR<OrderLinkCreateWithoutOrderInput, OrderLinkUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrderLinkCreateOrConnectWithoutOrderInput
    connect?: OrderLinkWhereUniqueInput
  }

  export type ShipmentCreateNestedOneWithoutOrderInput = {
    create?: XOR<ShipmentCreateWithoutOrderInput, ShipmentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutOrderInput
    connect?: ShipmentWhereUniqueInput
  }

  export type StatusChangeCreateNestedManyWithoutOrderInput = {
    create?: XOR<StatusChangeCreateWithoutOrderInput, StatusChangeUncheckedCreateWithoutOrderInput> | StatusChangeCreateWithoutOrderInput[] | StatusChangeUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: StatusChangeCreateOrConnectWithoutOrderInput | StatusChangeCreateOrConnectWithoutOrderInput[]
    createMany?: StatusChangeCreateManyOrderInputEnvelope
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
  }

  export type MaterialPurchaseAlertCreateNestedManyWithoutOrderInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutOrderInput, MaterialPurchaseAlertUncheckedCreateWithoutOrderInput> | MaterialPurchaseAlertCreateWithoutOrderInput[] | MaterialPurchaseAlertUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutOrderInput | MaterialPurchaseAlertCreateOrConnectWithoutOrderInput[]
    createMany?: MaterialPurchaseAlertCreateManyOrderInputEnvelope
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
  }

  export type ContactNoteCreateNestedManyWithoutOrderInput = {
    create?: XOR<ContactNoteCreateWithoutOrderInput, ContactNoteUncheckedCreateWithoutOrderInput> | ContactNoteCreateWithoutOrderInput[] | ContactNoteUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutOrderInput | ContactNoteCreateOrConnectWithoutOrderInput[]
    createMany?: ContactNoteCreateManyOrderInputEnvelope
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
  }

  export type OrderProductUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput> | OrderProductCreateWithoutOrderInput[] | OrderProductUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutOrderInput | OrderProductCreateOrConnectWithoutOrderInput[]
    createMany?: OrderProductCreateManyOrderInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type MaterialMovementUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<MaterialMovementCreateWithoutOrderInput, MaterialMovementUncheckedCreateWithoutOrderInput> | MaterialMovementCreateWithoutOrderInput[] | MaterialMovementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutOrderInput | MaterialMovementCreateOrConnectWithoutOrderInput[]
    createMany?: MaterialMovementCreateManyOrderInputEnvelope
    connect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
  }

  export type ProgressReportUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ProgressReportCreateWithoutOrderInput, ProgressReportUncheckedCreateWithoutOrderInput> | ProgressReportCreateWithoutOrderInput[] | ProgressReportUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutOrderInput | ProgressReportCreateOrConnectWithoutOrderInput[]
    createMany?: ProgressReportCreateManyOrderInputEnvelope
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
  }

  export type OrderLinkUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<OrderLinkCreateWithoutOrderInput, OrderLinkUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrderLinkCreateOrConnectWithoutOrderInput
    connect?: OrderLinkWhereUniqueInput
  }

  export type ShipmentUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<ShipmentCreateWithoutOrderInput, ShipmentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutOrderInput
    connect?: ShipmentWhereUniqueInput
  }

  export type StatusChangeUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<StatusChangeCreateWithoutOrderInput, StatusChangeUncheckedCreateWithoutOrderInput> | StatusChangeCreateWithoutOrderInput[] | StatusChangeUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: StatusChangeCreateOrConnectWithoutOrderInput | StatusChangeCreateOrConnectWithoutOrderInput[]
    createMany?: StatusChangeCreateManyOrderInputEnvelope
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
  }

  export type MaterialPurchaseAlertUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutOrderInput, MaterialPurchaseAlertUncheckedCreateWithoutOrderInput> | MaterialPurchaseAlertCreateWithoutOrderInput[] | MaterialPurchaseAlertUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutOrderInput | MaterialPurchaseAlertCreateOrConnectWithoutOrderInput[]
    createMany?: MaterialPurchaseAlertCreateManyOrderInputEnvelope
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
  }

  export type ContactNoteUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ContactNoteCreateWithoutOrderInput, ContactNoteUncheckedCreateWithoutOrderInput> | ContactNoteCreateWithoutOrderInput[] | ContactNoteUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutOrderInput | ContactNoteCreateOrConnectWithoutOrderInput[]
    createMany?: ContactNoteCreateManyOrderInputEnvelope
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneWithoutWorkerOrdersNestedInput = {
    create?: XOR<UserCreateWithoutWorkerOrdersInput, UserUncheckedCreateWithoutWorkerOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkerOrdersInput
    upsert?: UserUpsertWithoutWorkerOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkerOrdersInput, UserUpdateWithoutWorkerOrdersInput>, UserUncheckedUpdateWithoutWorkerOrdersInput>
  }

  export type ContactUpdateOneWithoutWorkerOrdersNestedInput = {
    create?: XOR<ContactCreateWithoutWorkerOrdersInput, ContactUncheckedCreateWithoutWorkerOrdersInput>
    connectOrCreate?: ContactCreateOrConnectWithoutWorkerOrdersInput
    upsert?: ContactUpsertWithoutWorkerOrdersInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutWorkerOrdersInput, ContactUpdateWithoutWorkerOrdersInput>, ContactUncheckedUpdateWithoutWorkerOrdersInput>
  }

  export type OrderProductUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput> | OrderProductCreateWithoutOrderInput[] | OrderProductUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutOrderInput | OrderProductCreateOrConnectWithoutOrderInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutOrderInput | OrderProductUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderProductCreateManyOrderInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutOrderInput | OrderProductUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutOrderInput | OrderProductUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type MaterialMovementUpdateManyWithoutOrderNestedInput = {
    create?: XOR<MaterialMovementCreateWithoutOrderInput, MaterialMovementUncheckedCreateWithoutOrderInput> | MaterialMovementCreateWithoutOrderInput[] | MaterialMovementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutOrderInput | MaterialMovementCreateOrConnectWithoutOrderInput[]
    upsert?: MaterialMovementUpsertWithWhereUniqueWithoutOrderInput | MaterialMovementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: MaterialMovementCreateManyOrderInputEnvelope
    set?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    disconnect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    delete?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    connect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    update?: MaterialMovementUpdateWithWhereUniqueWithoutOrderInput | MaterialMovementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: MaterialMovementUpdateManyWithWhereWithoutOrderInput | MaterialMovementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: MaterialMovementScalarWhereInput | MaterialMovementScalarWhereInput[]
  }

  export type ProgressReportUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ProgressReportCreateWithoutOrderInput, ProgressReportUncheckedCreateWithoutOrderInput> | ProgressReportCreateWithoutOrderInput[] | ProgressReportUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutOrderInput | ProgressReportCreateOrConnectWithoutOrderInput[]
    upsert?: ProgressReportUpsertWithWhereUniqueWithoutOrderInput | ProgressReportUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ProgressReportCreateManyOrderInputEnvelope
    set?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    disconnect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    delete?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    update?: ProgressReportUpdateWithWhereUniqueWithoutOrderInput | ProgressReportUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ProgressReportUpdateManyWithWhereWithoutOrderInput | ProgressReportUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
  }

  export type OrderLinkUpdateOneWithoutOrderNestedInput = {
    create?: XOR<OrderLinkCreateWithoutOrderInput, OrderLinkUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrderLinkCreateOrConnectWithoutOrderInput
    upsert?: OrderLinkUpsertWithoutOrderInput
    disconnect?: OrderLinkWhereInput | boolean
    delete?: OrderLinkWhereInput | boolean
    connect?: OrderLinkWhereUniqueInput
    update?: XOR<XOR<OrderLinkUpdateToOneWithWhereWithoutOrderInput, OrderLinkUpdateWithoutOrderInput>, OrderLinkUncheckedUpdateWithoutOrderInput>
  }

  export type ShipmentUpdateOneWithoutOrderNestedInput = {
    create?: XOR<ShipmentCreateWithoutOrderInput, ShipmentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutOrderInput
    upsert?: ShipmentUpsertWithoutOrderInput
    disconnect?: ShipmentWhereInput | boolean
    delete?: ShipmentWhereInput | boolean
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutOrderInput, ShipmentUpdateWithoutOrderInput>, ShipmentUncheckedUpdateWithoutOrderInput>
  }

  export type StatusChangeUpdateManyWithoutOrderNestedInput = {
    create?: XOR<StatusChangeCreateWithoutOrderInput, StatusChangeUncheckedCreateWithoutOrderInput> | StatusChangeCreateWithoutOrderInput[] | StatusChangeUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: StatusChangeCreateOrConnectWithoutOrderInput | StatusChangeCreateOrConnectWithoutOrderInput[]
    upsert?: StatusChangeUpsertWithWhereUniqueWithoutOrderInput | StatusChangeUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: StatusChangeCreateManyOrderInputEnvelope
    set?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    disconnect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    delete?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    update?: StatusChangeUpdateWithWhereUniqueWithoutOrderInput | StatusChangeUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: StatusChangeUpdateManyWithWhereWithoutOrderInput | StatusChangeUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: StatusChangeScalarWhereInput | StatusChangeScalarWhereInput[]
  }

  export type MaterialPurchaseAlertUpdateManyWithoutOrderNestedInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutOrderInput, MaterialPurchaseAlertUncheckedCreateWithoutOrderInput> | MaterialPurchaseAlertCreateWithoutOrderInput[] | MaterialPurchaseAlertUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutOrderInput | MaterialPurchaseAlertCreateOrConnectWithoutOrderInput[]
    upsert?: MaterialPurchaseAlertUpsertWithWhereUniqueWithoutOrderInput | MaterialPurchaseAlertUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: MaterialPurchaseAlertCreateManyOrderInputEnvelope
    set?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    disconnect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    delete?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    update?: MaterialPurchaseAlertUpdateWithWhereUniqueWithoutOrderInput | MaterialPurchaseAlertUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: MaterialPurchaseAlertUpdateManyWithWhereWithoutOrderInput | MaterialPurchaseAlertUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: MaterialPurchaseAlertScalarWhereInput | MaterialPurchaseAlertScalarWhereInput[]
  }

  export type ContactNoteUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ContactNoteCreateWithoutOrderInput, ContactNoteUncheckedCreateWithoutOrderInput> | ContactNoteCreateWithoutOrderInput[] | ContactNoteUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutOrderInput | ContactNoteCreateOrConnectWithoutOrderInput[]
    upsert?: ContactNoteUpsertWithWhereUniqueWithoutOrderInput | ContactNoteUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ContactNoteCreateManyOrderInputEnvelope
    set?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    disconnect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    delete?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    update?: ContactNoteUpdateWithWhereUniqueWithoutOrderInput | ContactNoteUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ContactNoteUpdateManyWithWhereWithoutOrderInput | ContactNoteUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
  }

  export type OrderProductUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput> | OrderProductCreateWithoutOrderInput[] | OrderProductUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutOrderInput | OrderProductCreateOrConnectWithoutOrderInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutOrderInput | OrderProductUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderProductCreateManyOrderInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutOrderInput | OrderProductUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutOrderInput | OrderProductUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type MaterialMovementUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<MaterialMovementCreateWithoutOrderInput, MaterialMovementUncheckedCreateWithoutOrderInput> | MaterialMovementCreateWithoutOrderInput[] | MaterialMovementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutOrderInput | MaterialMovementCreateOrConnectWithoutOrderInput[]
    upsert?: MaterialMovementUpsertWithWhereUniqueWithoutOrderInput | MaterialMovementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: MaterialMovementCreateManyOrderInputEnvelope
    set?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    disconnect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    delete?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    connect?: MaterialMovementWhereUniqueInput | MaterialMovementWhereUniqueInput[]
    update?: MaterialMovementUpdateWithWhereUniqueWithoutOrderInput | MaterialMovementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: MaterialMovementUpdateManyWithWhereWithoutOrderInput | MaterialMovementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: MaterialMovementScalarWhereInput | MaterialMovementScalarWhereInput[]
  }

  export type ProgressReportUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ProgressReportCreateWithoutOrderInput, ProgressReportUncheckedCreateWithoutOrderInput> | ProgressReportCreateWithoutOrderInput[] | ProgressReportUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutOrderInput | ProgressReportCreateOrConnectWithoutOrderInput[]
    upsert?: ProgressReportUpsertWithWhereUniqueWithoutOrderInput | ProgressReportUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ProgressReportCreateManyOrderInputEnvelope
    set?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    disconnect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    delete?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    update?: ProgressReportUpdateWithWhereUniqueWithoutOrderInput | ProgressReportUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ProgressReportUpdateManyWithWhereWithoutOrderInput | ProgressReportUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
  }

  export type OrderLinkUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<OrderLinkCreateWithoutOrderInput, OrderLinkUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrderLinkCreateOrConnectWithoutOrderInput
    upsert?: OrderLinkUpsertWithoutOrderInput
    disconnect?: OrderLinkWhereInput | boolean
    delete?: OrderLinkWhereInput | boolean
    connect?: OrderLinkWhereUniqueInput
    update?: XOR<XOR<OrderLinkUpdateToOneWithWhereWithoutOrderInput, OrderLinkUpdateWithoutOrderInput>, OrderLinkUncheckedUpdateWithoutOrderInput>
  }

  export type ShipmentUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<ShipmentCreateWithoutOrderInput, ShipmentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutOrderInput
    upsert?: ShipmentUpsertWithoutOrderInput
    disconnect?: ShipmentWhereInput | boolean
    delete?: ShipmentWhereInput | boolean
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutOrderInput, ShipmentUpdateWithoutOrderInput>, ShipmentUncheckedUpdateWithoutOrderInput>
  }

  export type StatusChangeUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<StatusChangeCreateWithoutOrderInput, StatusChangeUncheckedCreateWithoutOrderInput> | StatusChangeCreateWithoutOrderInput[] | StatusChangeUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: StatusChangeCreateOrConnectWithoutOrderInput | StatusChangeCreateOrConnectWithoutOrderInput[]
    upsert?: StatusChangeUpsertWithWhereUniqueWithoutOrderInput | StatusChangeUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: StatusChangeCreateManyOrderInputEnvelope
    set?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    disconnect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    delete?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[]
    update?: StatusChangeUpdateWithWhereUniqueWithoutOrderInput | StatusChangeUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: StatusChangeUpdateManyWithWhereWithoutOrderInput | StatusChangeUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: StatusChangeScalarWhereInput | StatusChangeScalarWhereInput[]
  }

  export type MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<MaterialPurchaseAlertCreateWithoutOrderInput, MaterialPurchaseAlertUncheckedCreateWithoutOrderInput> | MaterialPurchaseAlertCreateWithoutOrderInput[] | MaterialPurchaseAlertUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MaterialPurchaseAlertCreateOrConnectWithoutOrderInput | MaterialPurchaseAlertCreateOrConnectWithoutOrderInput[]
    upsert?: MaterialPurchaseAlertUpsertWithWhereUniqueWithoutOrderInput | MaterialPurchaseAlertUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: MaterialPurchaseAlertCreateManyOrderInputEnvelope
    set?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    disconnect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    delete?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    connect?: MaterialPurchaseAlertWhereUniqueInput | MaterialPurchaseAlertWhereUniqueInput[]
    update?: MaterialPurchaseAlertUpdateWithWhereUniqueWithoutOrderInput | MaterialPurchaseAlertUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: MaterialPurchaseAlertUpdateManyWithWhereWithoutOrderInput | MaterialPurchaseAlertUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: MaterialPurchaseAlertScalarWhereInput | MaterialPurchaseAlertScalarWhereInput[]
  }

  export type ContactNoteUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ContactNoteCreateWithoutOrderInput, ContactNoteUncheckedCreateWithoutOrderInput> | ContactNoteCreateWithoutOrderInput[] | ContactNoteUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutOrderInput | ContactNoteCreateOrConnectWithoutOrderInput[]
    upsert?: ContactNoteUpsertWithWhereUniqueWithoutOrderInput | ContactNoteUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ContactNoteCreateManyOrderInputEnvelope
    set?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    disconnect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    delete?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    update?: ContactNoteUpdateWithWhereUniqueWithoutOrderInput | ContactNoteUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ContactNoteUpdateManyWithWhereWithoutOrderInput | ContactNoteUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutOrderProductsInput = {
    create?: XOR<OrderCreateWithoutOrderProductsInput, OrderUncheckedCreateWithoutOrderProductsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderProductsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderProductsInput = {
    create?: XOR<ProductCreateWithoutOrderProductsInput, ProductUncheckedCreateWithoutOrderProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProgressReportCreateNestedManyWithoutOrderProductInput = {
    create?: XOR<ProgressReportCreateWithoutOrderProductInput, ProgressReportUncheckedCreateWithoutOrderProductInput> | ProgressReportCreateWithoutOrderProductInput[] | ProgressReportUncheckedCreateWithoutOrderProductInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutOrderProductInput | ProgressReportCreateOrConnectWithoutOrderProductInput[]
    createMany?: ProgressReportCreateManyOrderProductInputEnvelope
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
  }

  export type ProductProgressReportCreateNestedManyWithoutOrderProductInput = {
    create?: XOR<ProductProgressReportCreateWithoutOrderProductInput, ProductProgressReportUncheckedCreateWithoutOrderProductInput> | ProductProgressReportCreateWithoutOrderProductInput[] | ProductProgressReportUncheckedCreateWithoutOrderProductInput[]
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutOrderProductInput | ProductProgressReportCreateOrConnectWithoutOrderProductInput[]
    createMany?: ProductProgressReportCreateManyOrderProductInputEnvelope
    connect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
  }

  export type ProgressReportUncheckedCreateNestedManyWithoutOrderProductInput = {
    create?: XOR<ProgressReportCreateWithoutOrderProductInput, ProgressReportUncheckedCreateWithoutOrderProductInput> | ProgressReportCreateWithoutOrderProductInput[] | ProgressReportUncheckedCreateWithoutOrderProductInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutOrderProductInput | ProgressReportCreateOrConnectWithoutOrderProductInput[]
    createMany?: ProgressReportCreateManyOrderProductInputEnvelope
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
  }

  export type ProductProgressReportUncheckedCreateNestedManyWithoutOrderProductInput = {
    create?: XOR<ProductProgressReportCreateWithoutOrderProductInput, ProductProgressReportUncheckedCreateWithoutOrderProductInput> | ProductProgressReportCreateWithoutOrderProductInput[] | ProductProgressReportUncheckedCreateWithoutOrderProductInput[]
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutOrderProductInput | ProductProgressReportCreateOrConnectWithoutOrderProductInput[]
    createMany?: ProductProgressReportCreateManyOrderProductInputEnvelope
    connect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
  }

  export type EnumOrderProductStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderProductStatus
  }

  export type OrderUpdateOneRequiredWithoutOrderProductsNestedInput = {
    create?: XOR<OrderCreateWithoutOrderProductsInput, OrderUncheckedCreateWithoutOrderProductsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderProductsInput
    upsert?: OrderUpsertWithoutOrderProductsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderProductsInput, OrderUpdateWithoutOrderProductsInput>, OrderUncheckedUpdateWithoutOrderProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderProductsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderProductsInput, ProductUncheckedCreateWithoutOrderProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderProductsInput
    upsert?: ProductUpsertWithoutOrderProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderProductsInput, ProductUpdateWithoutOrderProductsInput>, ProductUncheckedUpdateWithoutOrderProductsInput>
  }

  export type ProgressReportUpdateManyWithoutOrderProductNestedInput = {
    create?: XOR<ProgressReportCreateWithoutOrderProductInput, ProgressReportUncheckedCreateWithoutOrderProductInput> | ProgressReportCreateWithoutOrderProductInput[] | ProgressReportUncheckedCreateWithoutOrderProductInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutOrderProductInput | ProgressReportCreateOrConnectWithoutOrderProductInput[]
    upsert?: ProgressReportUpsertWithWhereUniqueWithoutOrderProductInput | ProgressReportUpsertWithWhereUniqueWithoutOrderProductInput[]
    createMany?: ProgressReportCreateManyOrderProductInputEnvelope
    set?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    disconnect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    delete?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    update?: ProgressReportUpdateWithWhereUniqueWithoutOrderProductInput | ProgressReportUpdateWithWhereUniqueWithoutOrderProductInput[]
    updateMany?: ProgressReportUpdateManyWithWhereWithoutOrderProductInput | ProgressReportUpdateManyWithWhereWithoutOrderProductInput[]
    deleteMany?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
  }

  export type ProductProgressReportUpdateManyWithoutOrderProductNestedInput = {
    create?: XOR<ProductProgressReportCreateWithoutOrderProductInput, ProductProgressReportUncheckedCreateWithoutOrderProductInput> | ProductProgressReportCreateWithoutOrderProductInput[] | ProductProgressReportUncheckedCreateWithoutOrderProductInput[]
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutOrderProductInput | ProductProgressReportCreateOrConnectWithoutOrderProductInput[]
    upsert?: ProductProgressReportUpsertWithWhereUniqueWithoutOrderProductInput | ProductProgressReportUpsertWithWhereUniqueWithoutOrderProductInput[]
    createMany?: ProductProgressReportCreateManyOrderProductInputEnvelope
    set?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    disconnect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    delete?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    connect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    update?: ProductProgressReportUpdateWithWhereUniqueWithoutOrderProductInput | ProductProgressReportUpdateWithWhereUniqueWithoutOrderProductInput[]
    updateMany?: ProductProgressReportUpdateManyWithWhereWithoutOrderProductInput | ProductProgressReportUpdateManyWithWhereWithoutOrderProductInput[]
    deleteMany?: ProductProgressReportScalarWhereInput | ProductProgressReportScalarWhereInput[]
  }

  export type ProgressReportUncheckedUpdateManyWithoutOrderProductNestedInput = {
    create?: XOR<ProgressReportCreateWithoutOrderProductInput, ProgressReportUncheckedCreateWithoutOrderProductInput> | ProgressReportCreateWithoutOrderProductInput[] | ProgressReportUncheckedCreateWithoutOrderProductInput[]
    connectOrCreate?: ProgressReportCreateOrConnectWithoutOrderProductInput | ProgressReportCreateOrConnectWithoutOrderProductInput[]
    upsert?: ProgressReportUpsertWithWhereUniqueWithoutOrderProductInput | ProgressReportUpsertWithWhereUniqueWithoutOrderProductInput[]
    createMany?: ProgressReportCreateManyOrderProductInputEnvelope
    set?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    disconnect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    delete?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    connect?: ProgressReportWhereUniqueInput | ProgressReportWhereUniqueInput[]
    update?: ProgressReportUpdateWithWhereUniqueWithoutOrderProductInput | ProgressReportUpdateWithWhereUniqueWithoutOrderProductInput[]
    updateMany?: ProgressReportUpdateManyWithWhereWithoutOrderProductInput | ProgressReportUpdateManyWithWhereWithoutOrderProductInput[]
    deleteMany?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
  }

  export type ProductProgressReportUncheckedUpdateManyWithoutOrderProductNestedInput = {
    create?: XOR<ProductProgressReportCreateWithoutOrderProductInput, ProductProgressReportUncheckedCreateWithoutOrderProductInput> | ProductProgressReportCreateWithoutOrderProductInput[] | ProductProgressReportUncheckedCreateWithoutOrderProductInput[]
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutOrderProductInput | ProductProgressReportCreateOrConnectWithoutOrderProductInput[]
    upsert?: ProductProgressReportUpsertWithWhereUniqueWithoutOrderProductInput | ProductProgressReportUpsertWithWhereUniqueWithoutOrderProductInput[]
    createMany?: ProductProgressReportCreateManyOrderProductInputEnvelope
    set?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    disconnect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    delete?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    connect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    update?: ProductProgressReportUpdateWithWhereUniqueWithoutOrderProductInput | ProductProgressReportUpdateWithWhereUniqueWithoutOrderProductInput[]
    updateMany?: ProductProgressReportUpdateManyWithWhereWithoutOrderProductInput | ProductProgressReportUpdateManyWithWhereWithoutOrderProductInput[]
    deleteMany?: ProductProgressReportScalarWhereInput | ProductProgressReportScalarWhereInput[]
  }

  export type MaterialCreateNestedOneWithoutMaterialMovementsInput = {
    create?: XOR<MaterialCreateWithoutMaterialMovementsInput, MaterialUncheckedCreateWithoutMaterialMovementsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutMaterialMovementsInput
    connect?: MaterialWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutMaterialMovementsInput = {
    create?: XOR<OrderCreateWithoutMaterialMovementsInput, OrderUncheckedCreateWithoutMaterialMovementsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutMaterialMovementsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMaterialMovementsInput = {
    create?: XOR<UserCreateWithoutMaterialMovementsInput, UserUncheckedCreateWithoutMaterialMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaterialMovementsInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseLogCreateNestedOneWithoutMovementInput = {
    create?: XOR<PurchaseLogCreateWithoutMovementInput, PurchaseLogUncheckedCreateWithoutMovementInput>
    connectOrCreate?: PurchaseLogCreateOrConnectWithoutMovementInput
    connect?: PurchaseLogWhereUniqueInput
  }

  export type EnumMaterialMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.MaterialMovementType
  }

  export type MaterialUpdateOneRequiredWithoutMaterialMovementsNestedInput = {
    create?: XOR<MaterialCreateWithoutMaterialMovementsInput, MaterialUncheckedCreateWithoutMaterialMovementsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutMaterialMovementsInput
    upsert?: MaterialUpsertWithoutMaterialMovementsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutMaterialMovementsInput, MaterialUpdateWithoutMaterialMovementsInput>, MaterialUncheckedUpdateWithoutMaterialMovementsInput>
  }

  export type OrderUpdateOneWithoutMaterialMovementsNestedInput = {
    create?: XOR<OrderCreateWithoutMaterialMovementsInput, OrderUncheckedCreateWithoutMaterialMovementsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutMaterialMovementsInput
    upsert?: OrderUpsertWithoutMaterialMovementsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutMaterialMovementsInput, OrderUpdateWithoutMaterialMovementsInput>, OrderUncheckedUpdateWithoutMaterialMovementsInput>
  }

  export type UserUpdateOneRequiredWithoutMaterialMovementsNestedInput = {
    create?: XOR<UserCreateWithoutMaterialMovementsInput, UserUncheckedCreateWithoutMaterialMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaterialMovementsInput
    upsert?: UserUpsertWithoutMaterialMovementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMaterialMovementsInput, UserUpdateWithoutMaterialMovementsInput>, UserUncheckedUpdateWithoutMaterialMovementsInput>
  }

  export type PurchaseLogUpdateOneWithoutMovementNestedInput = {
    create?: XOR<PurchaseLogCreateWithoutMovementInput, PurchaseLogUncheckedCreateWithoutMovementInput>
    connectOrCreate?: PurchaseLogCreateOrConnectWithoutMovementInput
    upsert?: PurchaseLogUpsertWithoutMovementInput
    disconnect?: PurchaseLogWhereInput | boolean
    delete?: PurchaseLogWhereInput | boolean
    connect?: PurchaseLogWhereUniqueInput
    update?: XOR<XOR<PurchaseLogUpdateToOneWithWhereWithoutMovementInput, PurchaseLogUpdateWithoutMovementInput>, PurchaseLogUncheckedUpdateWithoutMovementInput>
  }

  export type OrderCreateNestedOneWithoutProgressReportsInput = {
    create?: XOR<OrderCreateWithoutProgressReportsInput, OrderUncheckedCreateWithoutProgressReportsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutProgressReportsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderProductCreateNestedOneWithoutIndividualProgressReportsInput = {
    create?: XOR<OrderProductCreateWithoutIndividualProgressReportsInput, OrderProductUncheckedCreateWithoutIndividualProgressReportsInput>
    connectOrCreate?: OrderProductCreateOrConnectWithoutIndividualProgressReportsInput
    connect?: OrderProductWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutIndividualProgressReportsInput = {
    create?: XOR<ProductCreateWithoutIndividualProgressReportsInput, ProductUncheckedCreateWithoutIndividualProgressReportsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIndividualProgressReportsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProgressReportsInput = {
    create?: XOR<UserCreateWithoutProgressReportsInput, UserUncheckedCreateWithoutProgressReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressReportsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductProgressReportCreateNestedManyWithoutProgressReportInput = {
    create?: XOR<ProductProgressReportCreateWithoutProgressReportInput, ProductProgressReportUncheckedCreateWithoutProgressReportInput> | ProductProgressReportCreateWithoutProgressReportInput[] | ProductProgressReportUncheckedCreateWithoutProgressReportInput[]
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutProgressReportInput | ProductProgressReportCreateOrConnectWithoutProgressReportInput[]
    createMany?: ProductProgressReportCreateManyProgressReportInputEnvelope
    connect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
  }

  export type ProductProgressReportUncheckedCreateNestedManyWithoutProgressReportInput = {
    create?: XOR<ProductProgressReportCreateWithoutProgressReportInput, ProductProgressReportUncheckedCreateWithoutProgressReportInput> | ProductProgressReportCreateWithoutProgressReportInput[] | ProductProgressReportUncheckedCreateWithoutProgressReportInput[]
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutProgressReportInput | ProductProgressReportCreateOrConnectWithoutProgressReportInput[]
    createMany?: ProductProgressReportCreateManyProgressReportInputEnvelope
    connect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
  }

  export type OrderUpdateOneWithoutProgressReportsNestedInput = {
    create?: XOR<OrderCreateWithoutProgressReportsInput, OrderUncheckedCreateWithoutProgressReportsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutProgressReportsInput
    upsert?: OrderUpsertWithoutProgressReportsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutProgressReportsInput, OrderUpdateWithoutProgressReportsInput>, OrderUncheckedUpdateWithoutProgressReportsInput>
  }

  export type OrderProductUpdateOneWithoutIndividualProgressReportsNestedInput = {
    create?: XOR<OrderProductCreateWithoutIndividualProgressReportsInput, OrderProductUncheckedCreateWithoutIndividualProgressReportsInput>
    connectOrCreate?: OrderProductCreateOrConnectWithoutIndividualProgressReportsInput
    upsert?: OrderProductUpsertWithoutIndividualProgressReportsInput
    disconnect?: OrderProductWhereInput | boolean
    delete?: OrderProductWhereInput | boolean
    connect?: OrderProductWhereUniqueInput
    update?: XOR<XOR<OrderProductUpdateToOneWithWhereWithoutIndividualProgressReportsInput, OrderProductUpdateWithoutIndividualProgressReportsInput>, OrderProductUncheckedUpdateWithoutIndividualProgressReportsInput>
  }

  export type ProductUpdateOneWithoutIndividualProgressReportsNestedInput = {
    create?: XOR<ProductCreateWithoutIndividualProgressReportsInput, ProductUncheckedCreateWithoutIndividualProgressReportsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIndividualProgressReportsInput
    upsert?: ProductUpsertWithoutIndividualProgressReportsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutIndividualProgressReportsInput, ProductUpdateWithoutIndividualProgressReportsInput>, ProductUncheckedUpdateWithoutIndividualProgressReportsInput>
  }

  export type UserUpdateOneRequiredWithoutProgressReportsNestedInput = {
    create?: XOR<UserCreateWithoutProgressReportsInput, UserUncheckedCreateWithoutProgressReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressReportsInput
    upsert?: UserUpsertWithoutProgressReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProgressReportsInput, UserUpdateWithoutProgressReportsInput>, UserUncheckedUpdateWithoutProgressReportsInput>
  }

  export type ProductProgressReportUpdateManyWithoutProgressReportNestedInput = {
    create?: XOR<ProductProgressReportCreateWithoutProgressReportInput, ProductProgressReportUncheckedCreateWithoutProgressReportInput> | ProductProgressReportCreateWithoutProgressReportInput[] | ProductProgressReportUncheckedCreateWithoutProgressReportInput[]
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutProgressReportInput | ProductProgressReportCreateOrConnectWithoutProgressReportInput[]
    upsert?: ProductProgressReportUpsertWithWhereUniqueWithoutProgressReportInput | ProductProgressReportUpsertWithWhereUniqueWithoutProgressReportInput[]
    createMany?: ProductProgressReportCreateManyProgressReportInputEnvelope
    set?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    disconnect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    delete?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    connect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    update?: ProductProgressReportUpdateWithWhereUniqueWithoutProgressReportInput | ProductProgressReportUpdateWithWhereUniqueWithoutProgressReportInput[]
    updateMany?: ProductProgressReportUpdateManyWithWhereWithoutProgressReportInput | ProductProgressReportUpdateManyWithWhereWithoutProgressReportInput[]
    deleteMany?: ProductProgressReportScalarWhereInput | ProductProgressReportScalarWhereInput[]
  }

  export type ProductProgressReportUncheckedUpdateManyWithoutProgressReportNestedInput = {
    create?: XOR<ProductProgressReportCreateWithoutProgressReportInput, ProductProgressReportUncheckedCreateWithoutProgressReportInput> | ProductProgressReportCreateWithoutProgressReportInput[] | ProductProgressReportUncheckedCreateWithoutProgressReportInput[]
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutProgressReportInput | ProductProgressReportCreateOrConnectWithoutProgressReportInput[]
    upsert?: ProductProgressReportUpsertWithWhereUniqueWithoutProgressReportInput | ProductProgressReportUpsertWithWhereUniqueWithoutProgressReportInput[]
    createMany?: ProductProgressReportCreateManyProgressReportInputEnvelope
    set?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    disconnect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    delete?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    connect?: ProductProgressReportWhereUniqueInput | ProductProgressReportWhereUniqueInput[]
    update?: ProductProgressReportUpdateWithWhereUniqueWithoutProgressReportInput | ProductProgressReportUpdateWithWhereUniqueWithoutProgressReportInput[]
    updateMany?: ProductProgressReportUpdateManyWithWhereWithoutProgressReportInput | ProductProgressReportUpdateManyWithWhereWithoutProgressReportInput[]
    deleteMany?: ProductProgressReportScalarWhereInput | ProductProgressReportScalarWhereInput[]
  }

  export type ProgressReportCreateNestedOneWithoutProductReportsInput = {
    create?: XOR<ProgressReportCreateWithoutProductReportsInput, ProgressReportUncheckedCreateWithoutProductReportsInput>
    connectOrCreate?: ProgressReportCreateOrConnectWithoutProductReportsInput
    connect?: ProgressReportWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProductProgressReportsInput = {
    create?: XOR<ProductCreateWithoutProductProgressReportsInput, ProductUncheckedCreateWithoutProductProgressReportsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductProgressReportsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderProductCreateNestedOneWithoutProductProgressReportsInput = {
    create?: XOR<OrderProductCreateWithoutProductProgressReportsInput, OrderProductUncheckedCreateWithoutProductProgressReportsInput>
    connectOrCreate?: OrderProductCreateOrConnectWithoutProductProgressReportsInput
    connect?: OrderProductWhereUniqueInput
  }

  export type ProductProgressPhotoCreateNestedManyWithoutProductProgressReportInput = {
    create?: XOR<ProductProgressPhotoCreateWithoutProductProgressReportInput, ProductProgressPhotoUncheckedCreateWithoutProductProgressReportInput> | ProductProgressPhotoCreateWithoutProductProgressReportInput[] | ProductProgressPhotoUncheckedCreateWithoutProductProgressReportInput[]
    connectOrCreate?: ProductProgressPhotoCreateOrConnectWithoutProductProgressReportInput | ProductProgressPhotoCreateOrConnectWithoutProductProgressReportInput[]
    createMany?: ProductProgressPhotoCreateManyProductProgressReportInputEnvelope
    connect?: ProductProgressPhotoWhereUniqueInput | ProductProgressPhotoWhereUniqueInput[]
  }

  export type ProductProgressPhotoUncheckedCreateNestedManyWithoutProductProgressReportInput = {
    create?: XOR<ProductProgressPhotoCreateWithoutProductProgressReportInput, ProductProgressPhotoUncheckedCreateWithoutProductProgressReportInput> | ProductProgressPhotoCreateWithoutProductProgressReportInput[] | ProductProgressPhotoUncheckedCreateWithoutProductProgressReportInput[]
    connectOrCreate?: ProductProgressPhotoCreateOrConnectWithoutProductProgressReportInput | ProductProgressPhotoCreateOrConnectWithoutProductProgressReportInput[]
    createMany?: ProductProgressPhotoCreateManyProductProgressReportInputEnvelope
    connect?: ProductProgressPhotoWhereUniqueInput | ProductProgressPhotoWhereUniqueInput[]
  }

  export type ProgressReportUpdateOneRequiredWithoutProductReportsNestedInput = {
    create?: XOR<ProgressReportCreateWithoutProductReportsInput, ProgressReportUncheckedCreateWithoutProductReportsInput>
    connectOrCreate?: ProgressReportCreateOrConnectWithoutProductReportsInput
    upsert?: ProgressReportUpsertWithoutProductReportsInput
    connect?: ProgressReportWhereUniqueInput
    update?: XOR<XOR<ProgressReportUpdateToOneWithWhereWithoutProductReportsInput, ProgressReportUpdateWithoutProductReportsInput>, ProgressReportUncheckedUpdateWithoutProductReportsInput>
  }

  export type ProductUpdateOneRequiredWithoutProductProgressReportsNestedInput = {
    create?: XOR<ProductCreateWithoutProductProgressReportsInput, ProductUncheckedCreateWithoutProductProgressReportsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductProgressReportsInput
    upsert?: ProductUpsertWithoutProductProgressReportsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductProgressReportsInput, ProductUpdateWithoutProductProgressReportsInput>, ProductUncheckedUpdateWithoutProductProgressReportsInput>
  }

  export type OrderProductUpdateOneWithoutProductProgressReportsNestedInput = {
    create?: XOR<OrderProductCreateWithoutProductProgressReportsInput, OrderProductUncheckedCreateWithoutProductProgressReportsInput>
    connectOrCreate?: OrderProductCreateOrConnectWithoutProductProgressReportsInput
    upsert?: OrderProductUpsertWithoutProductProgressReportsInput
    disconnect?: OrderProductWhereInput | boolean
    delete?: OrderProductWhereInput | boolean
    connect?: OrderProductWhereUniqueInput
    update?: XOR<XOR<OrderProductUpdateToOneWithWhereWithoutProductProgressReportsInput, OrderProductUpdateWithoutProductProgressReportsInput>, OrderProductUncheckedUpdateWithoutProductProgressReportsInput>
  }

  export type ProductProgressPhotoUpdateManyWithoutProductProgressReportNestedInput = {
    create?: XOR<ProductProgressPhotoCreateWithoutProductProgressReportInput, ProductProgressPhotoUncheckedCreateWithoutProductProgressReportInput> | ProductProgressPhotoCreateWithoutProductProgressReportInput[] | ProductProgressPhotoUncheckedCreateWithoutProductProgressReportInput[]
    connectOrCreate?: ProductProgressPhotoCreateOrConnectWithoutProductProgressReportInput | ProductProgressPhotoCreateOrConnectWithoutProductProgressReportInput[]
    upsert?: ProductProgressPhotoUpsertWithWhereUniqueWithoutProductProgressReportInput | ProductProgressPhotoUpsertWithWhereUniqueWithoutProductProgressReportInput[]
    createMany?: ProductProgressPhotoCreateManyProductProgressReportInputEnvelope
    set?: ProductProgressPhotoWhereUniqueInput | ProductProgressPhotoWhereUniqueInput[]
    disconnect?: ProductProgressPhotoWhereUniqueInput | ProductProgressPhotoWhereUniqueInput[]
    delete?: ProductProgressPhotoWhereUniqueInput | ProductProgressPhotoWhereUniqueInput[]
    connect?: ProductProgressPhotoWhereUniqueInput | ProductProgressPhotoWhereUniqueInput[]
    update?: ProductProgressPhotoUpdateWithWhereUniqueWithoutProductProgressReportInput | ProductProgressPhotoUpdateWithWhereUniqueWithoutProductProgressReportInput[]
    updateMany?: ProductProgressPhotoUpdateManyWithWhereWithoutProductProgressReportInput | ProductProgressPhotoUpdateManyWithWhereWithoutProductProgressReportInput[]
    deleteMany?: ProductProgressPhotoScalarWhereInput | ProductProgressPhotoScalarWhereInput[]
  }

  export type ProductProgressPhotoUncheckedUpdateManyWithoutProductProgressReportNestedInput = {
    create?: XOR<ProductProgressPhotoCreateWithoutProductProgressReportInput, ProductProgressPhotoUncheckedCreateWithoutProductProgressReportInput> | ProductProgressPhotoCreateWithoutProductProgressReportInput[] | ProductProgressPhotoUncheckedCreateWithoutProductProgressReportInput[]
    connectOrCreate?: ProductProgressPhotoCreateOrConnectWithoutProductProgressReportInput | ProductProgressPhotoCreateOrConnectWithoutProductProgressReportInput[]
    upsert?: ProductProgressPhotoUpsertWithWhereUniqueWithoutProductProgressReportInput | ProductProgressPhotoUpsertWithWhereUniqueWithoutProductProgressReportInput[]
    createMany?: ProductProgressPhotoCreateManyProductProgressReportInputEnvelope
    set?: ProductProgressPhotoWhereUniqueInput | ProductProgressPhotoWhereUniqueInput[]
    disconnect?: ProductProgressPhotoWhereUniqueInput | ProductProgressPhotoWhereUniqueInput[]
    delete?: ProductProgressPhotoWhereUniqueInput | ProductProgressPhotoWhereUniqueInput[]
    connect?: ProductProgressPhotoWhereUniqueInput | ProductProgressPhotoWhereUniqueInput[]
    update?: ProductProgressPhotoUpdateWithWhereUniqueWithoutProductProgressReportInput | ProductProgressPhotoUpdateWithWhereUniqueWithoutProductProgressReportInput[]
    updateMany?: ProductProgressPhotoUpdateManyWithWhereWithoutProductProgressReportInput | ProductProgressPhotoUpdateManyWithWhereWithoutProductProgressReportInput[]
    deleteMany?: ProductProgressPhotoScalarWhereInput | ProductProgressPhotoScalarWhereInput[]
  }

  export type ProductProgressReportCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ProductProgressReportCreateWithoutPhotosInput, ProductProgressReportUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutPhotosInput
    connect?: ProductProgressReportWhereUniqueInput
  }

  export type ProductProgressReportUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ProductProgressReportCreateWithoutPhotosInput, ProductProgressReportUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProductProgressReportCreateOrConnectWithoutPhotosInput
    upsert?: ProductProgressReportUpsertWithoutPhotosInput
    connect?: ProductProgressReportWhereUniqueInput
    update?: XOR<XOR<ProductProgressReportUpdateToOneWithWhereWithoutPhotosInput, ProductProgressReportUpdateWithoutPhotosInput>, ProductProgressReportUncheckedUpdateWithoutPhotosInput>
  }

  export type MaterialCreateNestedOneWithoutRemainingMaterialsInput = {
    create?: XOR<MaterialCreateWithoutRemainingMaterialsInput, MaterialUncheckedCreateWithoutRemainingMaterialsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutRemainingMaterialsInput
    connect?: MaterialWhereUniqueInput
  }

  export type MaterialUpdateOneRequiredWithoutRemainingMaterialsNestedInput = {
    create?: XOR<MaterialCreateWithoutRemainingMaterialsInput, MaterialUncheckedCreateWithoutRemainingMaterialsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutRemainingMaterialsInput
    upsert?: MaterialUpsertWithoutRemainingMaterialsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutRemainingMaterialsInput, MaterialUpdateWithoutRemainingMaterialsInput>, MaterialUncheckedUpdateWithoutRemainingMaterialsInput>
  }

  export type OrderCreateNestedOneWithoutOrderLinkInput = {
    create?: XOR<OrderCreateWithoutOrderLinkInput, OrderUncheckedCreateWithoutOrderLinkInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderLinkInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrderLinksInput = {
    create?: XOR<UserCreateWithoutOrderLinksInput, UserUncheckedCreateWithoutOrderLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderLinksInput
    connect?: UserWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrderLinkNestedInput = {
    create?: XOR<OrderCreateWithoutOrderLinkInput, OrderUncheckedCreateWithoutOrderLinkInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderLinkInput
    upsert?: OrderUpsertWithoutOrderLinkInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderLinkInput, OrderUpdateWithoutOrderLinkInput>, OrderUncheckedUpdateWithoutOrderLinkInput>
  }

  export type UserUpdateOneRequiredWithoutOrderLinksNestedInput = {
    create?: XOR<UserCreateWithoutOrderLinksInput, UserUncheckedCreateWithoutOrderLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderLinksInput
    upsert?: UserUpsertWithoutOrderLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrderLinksInput, UserUpdateWithoutOrderLinksInput>, UserUncheckedUpdateWithoutOrderLinksInput>
  }

  export type ProductCreateNestedOneWithoutProductMaterialsInput = {
    create?: XOR<ProductCreateWithoutProductMaterialsInput, ProductUncheckedCreateWithoutProductMaterialsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductMaterialsInput
    connect?: ProductWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutProductMaterialsInput = {
    create?: XOR<MaterialCreateWithoutProductMaterialsInput, MaterialUncheckedCreateWithoutProductMaterialsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutProductMaterialsInput
    connect?: MaterialWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductMaterialsNestedInput = {
    create?: XOR<ProductCreateWithoutProductMaterialsInput, ProductUncheckedCreateWithoutProductMaterialsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductMaterialsInput
    upsert?: ProductUpsertWithoutProductMaterialsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductMaterialsInput, ProductUpdateWithoutProductMaterialsInput>, ProductUncheckedUpdateWithoutProductMaterialsInput>
  }

  export type MaterialUpdateOneRequiredWithoutProductMaterialsNestedInput = {
    create?: XOR<MaterialCreateWithoutProductMaterialsInput, MaterialUncheckedCreateWithoutProductMaterialsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutProductMaterialsInput
    upsert?: MaterialUpsertWithoutProductMaterialsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutProductMaterialsInput, MaterialUpdateWithoutProductMaterialsInput>, MaterialUncheckedUpdateWithoutProductMaterialsInput>
  }

  export type OrderCreateNestedOneWithoutShipmentInput = {
    create?: XOR<OrderCreateWithoutShipmentInput, OrderUncheckedCreateWithoutShipmentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutShipmentInput
    connect?: OrderWhereUniqueInput
  }

  export type EnumShipmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShipmentStatus
  }

  export type OrderUpdateOneRequiredWithoutShipmentNestedInput = {
    create?: XOR<OrderCreateWithoutShipmentInput, OrderUncheckedCreateWithoutShipmentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutShipmentInput
    upsert?: OrderUpsertWithoutShipmentInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutShipmentInput, OrderUpdateWithoutShipmentInput>, OrderUncheckedUpdateWithoutShipmentInput>
  }

  export type ProductCreateNestedOneWithoutRecurringPlansInput = {
    create?: XOR<ProductCreateWithoutRecurringPlansInput, ProductUncheckedCreateWithoutRecurringPlansInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRecurringPlansInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutRecurringPlansNestedInput = {
    create?: XOR<ProductCreateWithoutRecurringPlansInput, ProductUncheckedCreateWithoutRecurringPlansInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRecurringPlansInput
    upsert?: ProductUpsertWithoutRecurringPlansInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRecurringPlansInput, ProductUpdateWithoutRecurringPlansInput>, ProductUncheckedUpdateWithoutRecurringPlansInput>
  }

  export type OrderCreateNestedOneWithoutStatusChangesInput = {
    create?: XOR<OrderCreateWithoutStatusChangesInput, OrderUncheckedCreateWithoutStatusChangesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutStatusChangesInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStatusChangesInput = {
    create?: XOR<UserCreateWithoutStatusChangesInput, UserUncheckedCreateWithoutStatusChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusChangesInput
    connect?: UserWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutStatusChangesNestedInput = {
    create?: XOR<OrderCreateWithoutStatusChangesInput, OrderUncheckedCreateWithoutStatusChangesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutStatusChangesInput
    upsert?: OrderUpsertWithoutStatusChangesInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutStatusChangesInput, OrderUpdateWithoutStatusChangesInput>, OrderUncheckedUpdateWithoutStatusChangesInput>
  }

  export type UserUpdateOneRequiredWithoutStatusChangesNestedInput = {
    create?: XOR<UserCreateWithoutStatusChangesInput, UserUncheckedCreateWithoutStatusChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusChangesInput
    upsert?: UserUpsertWithoutStatusChangesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStatusChangesInput, UserUpdateWithoutStatusChangesInput>, UserUncheckedUpdateWithoutStatusChangesInput>
  }

  export type ProductCreateNestedOneWithoutColoursInput = {
    create?: XOR<ProductCreateWithoutColoursInput, ProductUncheckedCreateWithoutColoursInput>
    connectOrCreate?: ProductCreateOrConnectWithoutColoursInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutColoursNestedInput = {
    create?: XOR<ProductCreateWithoutColoursInput, ProductUncheckedCreateWithoutColoursInput>
    connectOrCreate?: ProductCreateOrConnectWithoutColoursInput
    upsert?: ProductUpsertWithoutColoursInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutColoursInput, ProductUpdateWithoutColoursInput>, ProductUncheckedUpdateWithoutColoursInput>
  }

  export type ProductCreateNestedOneWithoutVariationsInput = {
    create?: XOR<ProductCreateWithoutVariationsInput, ProductUncheckedCreateWithoutVariationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariationsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutVariationsNestedInput = {
    create?: XOR<ProductCreateWithoutVariationsInput, ProductUncheckedCreateWithoutVariationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariationsInput
    upsert?: ProductUpsertWithoutVariationsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVariationsInput, ProductUpdateWithoutVariationsInput>, ProductUncheckedUpdateWithoutVariationsInput>
  }

  export type ProductCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ProductCreateWithoutPhotosInput, ProductUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPhotosInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ProductCreateWithoutPhotosInput, ProductUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPhotosInput
    upsert?: ProductUpsertWithoutPhotosInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPhotosInput, ProductUpdateWithoutPhotosInput>, ProductUncheckedUpdateWithoutPhotosInput>
  }

  export type MaterialCreateNestedOneWithoutPurchaseAlertsInput = {
    create?: XOR<MaterialCreateWithoutPurchaseAlertsInput, MaterialUncheckedCreateWithoutPurchaseAlertsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutPurchaseAlertsInput
    connect?: MaterialWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPurchaseAlertsInput = {
    create?: XOR<OrderCreateWithoutPurchaseAlertsInput, OrderUncheckedCreateWithoutPurchaseAlertsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPurchaseAlertsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedAlertsInput = {
    create?: XOR<UserCreateWithoutCreatedAlertsInput, UserUncheckedCreateWithoutCreatedAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResolvedAlertsInput = {
    create?: XOR<UserCreateWithoutResolvedAlertsInput, UserUncheckedCreateWithoutResolvedAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput = {
    set?: $Enums.MaterialPurchaseAlertType
  }

  export type EnumUrgencyLevelFieldUpdateOperationsInput = {
    set?: $Enums.UrgencyLevel
  }

  export type EnumAlertStatusFieldUpdateOperationsInput = {
    set?: $Enums.AlertStatus
  }

  export type MaterialUpdateOneRequiredWithoutPurchaseAlertsNestedInput = {
    create?: XOR<MaterialCreateWithoutPurchaseAlertsInput, MaterialUncheckedCreateWithoutPurchaseAlertsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutPurchaseAlertsInput
    upsert?: MaterialUpsertWithoutPurchaseAlertsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutPurchaseAlertsInput, MaterialUpdateWithoutPurchaseAlertsInput>, MaterialUncheckedUpdateWithoutPurchaseAlertsInput>
  }

  export type OrderUpdateOneWithoutPurchaseAlertsNestedInput = {
    create?: XOR<OrderCreateWithoutPurchaseAlertsInput, OrderUncheckedCreateWithoutPurchaseAlertsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPurchaseAlertsInput
    upsert?: OrderUpsertWithoutPurchaseAlertsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPurchaseAlertsInput, OrderUpdateWithoutPurchaseAlertsInput>, OrderUncheckedUpdateWithoutPurchaseAlertsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedAlertsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedAlertsInput, UserUncheckedCreateWithoutCreatedAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAlertsInput
    upsert?: UserUpsertWithoutCreatedAlertsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedAlertsInput, UserUpdateWithoutCreatedAlertsInput>, UserUncheckedUpdateWithoutCreatedAlertsInput>
  }

  export type UserUpdateOneWithoutResolvedAlertsNestedInput = {
    create?: XOR<UserCreateWithoutResolvedAlertsInput, UserUncheckedCreateWithoutResolvedAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedAlertsInput
    upsert?: UserUpsertWithoutResolvedAlertsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResolvedAlertsInput, UserUpdateWithoutResolvedAlertsInput>, UserUncheckedUpdateWithoutResolvedAlertsInput>
  }

  export type MaterialCreateNestedOneWithoutPurchaseLogsInput = {
    create?: XOR<MaterialCreateWithoutPurchaseLogsInput, MaterialUncheckedCreateWithoutPurchaseLogsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutPurchaseLogsInput
    connect?: MaterialWhereUniqueInput
  }

  export type MaterialMovementCreateNestedOneWithoutPurchaseLogInput = {
    create?: XOR<MaterialMovementCreateWithoutPurchaseLogInput, MaterialMovementUncheckedCreateWithoutPurchaseLogInput>
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutPurchaseLogInput
    connect?: MaterialMovementWhereUniqueInput
  }

  export type ContactNoteCreateNestedManyWithoutPurchaseLogInput = {
    create?: XOR<ContactNoteCreateWithoutPurchaseLogInput, ContactNoteUncheckedCreateWithoutPurchaseLogInput> | ContactNoteCreateWithoutPurchaseLogInput[] | ContactNoteUncheckedCreateWithoutPurchaseLogInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutPurchaseLogInput | ContactNoteCreateOrConnectWithoutPurchaseLogInput[]
    createMany?: ContactNoteCreateManyPurchaseLogInputEnvelope
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
  }

  export type MaterialMovementUncheckedCreateNestedOneWithoutPurchaseLogInput = {
    create?: XOR<MaterialMovementCreateWithoutPurchaseLogInput, MaterialMovementUncheckedCreateWithoutPurchaseLogInput>
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutPurchaseLogInput
    connect?: MaterialMovementWhereUniqueInput
  }

  export type ContactNoteUncheckedCreateNestedManyWithoutPurchaseLogInput = {
    create?: XOR<ContactNoteCreateWithoutPurchaseLogInput, ContactNoteUncheckedCreateWithoutPurchaseLogInput> | ContactNoteCreateWithoutPurchaseLogInput[] | ContactNoteUncheckedCreateWithoutPurchaseLogInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutPurchaseLogInput | ContactNoteCreateOrConnectWithoutPurchaseLogInput[]
    createMany?: ContactNoteCreateManyPurchaseLogInputEnvelope
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
  }

  export type EnumPurchaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseStatus
  }

  export type MaterialUpdateOneRequiredWithoutPurchaseLogsNestedInput = {
    create?: XOR<MaterialCreateWithoutPurchaseLogsInput, MaterialUncheckedCreateWithoutPurchaseLogsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutPurchaseLogsInput
    upsert?: MaterialUpsertWithoutPurchaseLogsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutPurchaseLogsInput, MaterialUpdateWithoutPurchaseLogsInput>, MaterialUncheckedUpdateWithoutPurchaseLogsInput>
  }

  export type MaterialMovementUpdateOneWithoutPurchaseLogNestedInput = {
    create?: XOR<MaterialMovementCreateWithoutPurchaseLogInput, MaterialMovementUncheckedCreateWithoutPurchaseLogInput>
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutPurchaseLogInput
    upsert?: MaterialMovementUpsertWithoutPurchaseLogInput
    disconnect?: MaterialMovementWhereInput | boolean
    delete?: MaterialMovementWhereInput | boolean
    connect?: MaterialMovementWhereUniqueInput
    update?: XOR<XOR<MaterialMovementUpdateToOneWithWhereWithoutPurchaseLogInput, MaterialMovementUpdateWithoutPurchaseLogInput>, MaterialMovementUncheckedUpdateWithoutPurchaseLogInput>
  }

  export type ContactNoteUpdateManyWithoutPurchaseLogNestedInput = {
    create?: XOR<ContactNoteCreateWithoutPurchaseLogInput, ContactNoteUncheckedCreateWithoutPurchaseLogInput> | ContactNoteCreateWithoutPurchaseLogInput[] | ContactNoteUncheckedCreateWithoutPurchaseLogInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutPurchaseLogInput | ContactNoteCreateOrConnectWithoutPurchaseLogInput[]
    upsert?: ContactNoteUpsertWithWhereUniqueWithoutPurchaseLogInput | ContactNoteUpsertWithWhereUniqueWithoutPurchaseLogInput[]
    createMany?: ContactNoteCreateManyPurchaseLogInputEnvelope
    set?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    disconnect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    delete?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    update?: ContactNoteUpdateWithWhereUniqueWithoutPurchaseLogInput | ContactNoteUpdateWithWhereUniqueWithoutPurchaseLogInput[]
    updateMany?: ContactNoteUpdateManyWithWhereWithoutPurchaseLogInput | ContactNoteUpdateManyWithWhereWithoutPurchaseLogInput[]
    deleteMany?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
  }

  export type MaterialMovementUncheckedUpdateOneWithoutPurchaseLogNestedInput = {
    create?: XOR<MaterialMovementCreateWithoutPurchaseLogInput, MaterialMovementUncheckedCreateWithoutPurchaseLogInput>
    connectOrCreate?: MaterialMovementCreateOrConnectWithoutPurchaseLogInput
    upsert?: MaterialMovementUpsertWithoutPurchaseLogInput
    disconnect?: MaterialMovementWhereInput | boolean
    delete?: MaterialMovementWhereInput | boolean
    connect?: MaterialMovementWhereUniqueInput
    update?: XOR<XOR<MaterialMovementUpdateToOneWithWhereWithoutPurchaseLogInput, MaterialMovementUpdateWithoutPurchaseLogInput>, MaterialMovementUncheckedUpdateWithoutPurchaseLogInput>
  }

  export type ContactNoteUncheckedUpdateManyWithoutPurchaseLogNestedInput = {
    create?: XOR<ContactNoteCreateWithoutPurchaseLogInput, ContactNoteUncheckedCreateWithoutPurchaseLogInput> | ContactNoteCreateWithoutPurchaseLogInput[] | ContactNoteUncheckedCreateWithoutPurchaseLogInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutPurchaseLogInput | ContactNoteCreateOrConnectWithoutPurchaseLogInput[]
    upsert?: ContactNoteUpsertWithWhereUniqueWithoutPurchaseLogInput | ContactNoteUpsertWithWhereUniqueWithoutPurchaseLogInput[]
    createMany?: ContactNoteCreateManyPurchaseLogInputEnvelope
    set?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    disconnect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    delete?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    update?: ContactNoteUpdateWithWhereUniqueWithoutPurchaseLogInput | ContactNoteUpdateWithWhereUniqueWithoutPurchaseLogInput[]
    updateMany?: ContactNoteUpdateManyWithWhereWithoutPurchaseLogInput | ContactNoteUpdateManyWithWhereWithoutPurchaseLogInput[]
    deleteMany?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutWorkerContactInput = {
    create?: XOR<OrderCreateWithoutWorkerContactInput, OrderUncheckedCreateWithoutWorkerContactInput> | OrderCreateWithoutWorkerContactInput[] | OrderUncheckedCreateWithoutWorkerContactInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkerContactInput | OrderCreateOrConnectWithoutWorkerContactInput[]
    createMany?: OrderCreateManyWorkerContactInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ContactNoteCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactNoteCreateWithoutContactInput, ContactNoteUncheckedCreateWithoutContactInput> | ContactNoteCreateWithoutContactInput[] | ContactNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutContactInput | ContactNoteCreateOrConnectWithoutContactInput[]
    createMany?: ContactNoteCreateManyContactInputEnvelope
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutWorkerContactInput = {
    create?: XOR<OrderCreateWithoutWorkerContactInput, OrderUncheckedCreateWithoutWorkerContactInput> | OrderCreateWithoutWorkerContactInput[] | OrderUncheckedCreateWithoutWorkerContactInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkerContactInput | OrderCreateOrConnectWithoutWorkerContactInput[]
    createMany?: OrderCreateManyWorkerContactInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ContactNoteUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactNoteCreateWithoutContactInput, ContactNoteUncheckedCreateWithoutContactInput> | ContactNoteCreateWithoutContactInput[] | ContactNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutContactInput | ContactNoteCreateOrConnectWithoutContactInput[]
    createMany?: ContactNoteCreateManyContactInputEnvelope
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
  }

  export type EnumContactTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContactType
  }

  export type OrderUpdateManyWithoutWorkerContactNestedInput = {
    create?: XOR<OrderCreateWithoutWorkerContactInput, OrderUncheckedCreateWithoutWorkerContactInput> | OrderCreateWithoutWorkerContactInput[] | OrderUncheckedCreateWithoutWorkerContactInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkerContactInput | OrderCreateOrConnectWithoutWorkerContactInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutWorkerContactInput | OrderUpsertWithWhereUniqueWithoutWorkerContactInput[]
    createMany?: OrderCreateManyWorkerContactInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutWorkerContactInput | OrderUpdateWithWhereUniqueWithoutWorkerContactInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutWorkerContactInput | OrderUpdateManyWithWhereWithoutWorkerContactInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ContactNoteUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactNoteCreateWithoutContactInput, ContactNoteUncheckedCreateWithoutContactInput> | ContactNoteCreateWithoutContactInput[] | ContactNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutContactInput | ContactNoteCreateOrConnectWithoutContactInput[]
    upsert?: ContactNoteUpsertWithWhereUniqueWithoutContactInput | ContactNoteUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactNoteCreateManyContactInputEnvelope
    set?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    disconnect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    delete?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    update?: ContactNoteUpdateWithWhereUniqueWithoutContactInput | ContactNoteUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactNoteUpdateManyWithWhereWithoutContactInput | ContactNoteUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutWorkerContactNestedInput = {
    create?: XOR<OrderCreateWithoutWorkerContactInput, OrderUncheckedCreateWithoutWorkerContactInput> | OrderCreateWithoutWorkerContactInput[] | OrderUncheckedCreateWithoutWorkerContactInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWorkerContactInput | OrderCreateOrConnectWithoutWorkerContactInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutWorkerContactInput | OrderUpsertWithWhereUniqueWithoutWorkerContactInput[]
    createMany?: OrderCreateManyWorkerContactInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutWorkerContactInput | OrderUpdateWithWhereUniqueWithoutWorkerContactInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutWorkerContactInput | OrderUpdateManyWithWhereWithoutWorkerContactInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ContactNoteUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactNoteCreateWithoutContactInput, ContactNoteUncheckedCreateWithoutContactInput> | ContactNoteCreateWithoutContactInput[] | ContactNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutContactInput | ContactNoteCreateOrConnectWithoutContactInput[]
    upsert?: ContactNoteUpsertWithWhereUniqueWithoutContactInput | ContactNoteUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactNoteCreateManyContactInputEnvelope
    set?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    disconnect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    delete?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    update?: ContactNoteUpdateWithWhereUniqueWithoutContactInput | ContactNoteUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactNoteUpdateManyWithWhereWithoutContactInput | ContactNoteUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
  }

  export type ContactCreateNestedOneWithoutContactNotesInput = {
    create?: XOR<ContactCreateWithoutContactNotesInput, ContactUncheckedCreateWithoutContactNotesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutContactNotesInput
    connect?: ContactWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutContactNotesInput = {
    create?: XOR<OrderCreateWithoutContactNotesInput, OrderUncheckedCreateWithoutContactNotesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutContactNotesInput
    connect?: OrderWhereUniqueInput
  }

  export type PurchaseLogCreateNestedOneWithoutContactNotesInput = {
    create?: XOR<PurchaseLogCreateWithoutContactNotesInput, PurchaseLogUncheckedCreateWithoutContactNotesInput>
    connectOrCreate?: PurchaseLogCreateOrConnectWithoutContactNotesInput
    connect?: PurchaseLogWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedContactNotesInput = {
    create?: XOR<UserCreateWithoutCreatedContactNotesInput, UserUncheckedCreateWithoutCreatedContactNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedContactNotesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNoteTypeFieldUpdateOperationsInput = {
    set?: $Enums.NoteType
  }

  export type ContactUpdateOneRequiredWithoutContactNotesNestedInput = {
    create?: XOR<ContactCreateWithoutContactNotesInput, ContactUncheckedCreateWithoutContactNotesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutContactNotesInput
    upsert?: ContactUpsertWithoutContactNotesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutContactNotesInput, ContactUpdateWithoutContactNotesInput>, ContactUncheckedUpdateWithoutContactNotesInput>
  }

  export type OrderUpdateOneWithoutContactNotesNestedInput = {
    create?: XOR<OrderCreateWithoutContactNotesInput, OrderUncheckedCreateWithoutContactNotesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutContactNotesInput
    upsert?: OrderUpsertWithoutContactNotesInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutContactNotesInput, OrderUpdateWithoutContactNotesInput>, OrderUncheckedUpdateWithoutContactNotesInput>
  }

  export type PurchaseLogUpdateOneWithoutContactNotesNestedInput = {
    create?: XOR<PurchaseLogCreateWithoutContactNotesInput, PurchaseLogUncheckedCreateWithoutContactNotesInput>
    connectOrCreate?: PurchaseLogCreateOrConnectWithoutContactNotesInput
    upsert?: PurchaseLogUpsertWithoutContactNotesInput
    disconnect?: PurchaseLogWhereInput | boolean
    delete?: PurchaseLogWhereInput | boolean
    connect?: PurchaseLogWhereUniqueInput
    update?: XOR<XOR<PurchaseLogUpdateToOneWithWhereWithoutContactNotesInput, PurchaseLogUpdateWithoutContactNotesInput>, PurchaseLogUncheckedUpdateWithoutContactNotesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedContactNotesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedContactNotesInput, UserUncheckedCreateWithoutCreatedContactNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedContactNotesInput
    upsert?: UserUpsertWithoutCreatedContactNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedContactNotesInput, UserUpdateWithoutCreatedContactNotesInput>, UserUncheckedUpdateWithoutCreatedContactNotesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumOrderProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderProductStatus | EnumOrderProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderProductStatus[] | ListEnumOrderProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderProductStatus[] | ListEnumOrderProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderProductStatusFilter<$PrismaModel> | $Enums.OrderProductStatus
  }

  export type NestedEnumOrderProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderProductStatus | EnumOrderProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderProductStatus[] | ListEnumOrderProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderProductStatus[] | ListEnumOrderProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderProductStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderProductStatusFilter<$PrismaModel>
  }

  export type NestedEnumMaterialMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialMovementType | EnumMaterialMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialMovementType[] | ListEnumMaterialMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialMovementType[] | ListEnumMaterialMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialMovementTypeFilter<$PrismaModel> | $Enums.MaterialMovementType
  }

  export type NestedEnumMaterialMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialMovementType | EnumMaterialMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialMovementType[] | ListEnumMaterialMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialMovementType[] | ListEnumMaterialMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaterialMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumMaterialMovementTypeFilter<$PrismaModel>
  }

  export type NestedEnumShipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusFilter<$PrismaModel> | $Enums.ShipmentStatus
  }

  export type NestedEnumShipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumShipmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumMaterialPurchaseAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialPurchaseAlertType | EnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialPurchaseAlertType[] | ListEnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialPurchaseAlertType[] | ListEnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialPurchaseAlertTypeFilter<$PrismaModel> | $Enums.MaterialPurchaseAlertType
  }

  export type NestedEnumUrgencyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.UrgencyLevel | EnumUrgencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumUrgencyLevelFilter<$PrismaModel> | $Enums.UrgencyLevel
  }

  export type NestedEnumAlertStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusFilter<$PrismaModel> | $Enums.AlertStatus
  }

  export type NestedEnumMaterialPurchaseAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialPurchaseAlertType | EnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialPurchaseAlertType[] | ListEnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialPurchaseAlertType[] | ListEnumMaterialPurchaseAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialPurchaseAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaterialPurchaseAlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialPurchaseAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumMaterialPurchaseAlertTypeFilter<$PrismaModel>
  }

  export type NestedEnumUrgencyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UrgencyLevel | EnumUrgencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.UrgencyLevel[] | ListEnumUrgencyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumUrgencyLevelWithAggregatesFilter<$PrismaModel> | $Enums.UrgencyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUrgencyLevelFilter<$PrismaModel>
    _max?: NestedEnumUrgencyLevelFilter<$PrismaModel>
  }

  export type NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertStatusFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type NestedEnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type NestedEnumNoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeFilter<$PrismaModel> | $Enums.NoteType
  }

  export type NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.NoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteTypeFilter<$PrismaModel>
    _max?: NestedEnumNoteTypeFilter<$PrismaModel>
  }

  export type OrderCreateWithoutUserInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    worker?: UserCreateNestedOneWithoutWorkerOrdersInput
    workerContact?: ContactCreateNestedOneWithoutWorkerOrdersInput
    orderProducts?: OrderProductCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkCreateNestedOneWithoutOrderInput
    shipment?: ShipmentCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    workerId?: number | null
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkUncheckedCreateNestedOneWithoutOrderInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutWorkerInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    workerContact?: ContactCreateNestedOneWithoutWorkerOrdersInput
    orderProducts?: OrderProductCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkCreateNestedOneWithoutOrderInput
    shipment?: ShipmentCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutWorkerInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkUncheckedCreateNestedOneWithoutOrderInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutWorkerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutWorkerInput, OrderUncheckedCreateWithoutWorkerInput>
  }

  export type OrderCreateManyWorkerInputEnvelope = {
    data: OrderCreateManyWorkerInput | OrderCreateManyWorkerInput[]
    skipDuplicates?: boolean
  }

  export type MaterialMovementCreateWithoutUserInput = {
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutMaterialMovementsInput
    order?: OrderCreateNestedOneWithoutMaterialMovementsInput
    purchaseLog?: PurchaseLogCreateNestedOneWithoutMovementInput
  }

  export type MaterialMovementUncheckedCreateWithoutUserInput = {
    id?: number
    materialId: number
    orderId?: number | null
    purchaseLogId?: number | null
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialMovementCreateOrConnectWithoutUserInput = {
    where: MaterialMovementWhereUniqueInput
    create: XOR<MaterialMovementCreateWithoutUserInput, MaterialMovementUncheckedCreateWithoutUserInput>
  }

  export type MaterialMovementCreateManyUserInputEnvelope = {
    data: MaterialMovementCreateManyUserInput | MaterialMovementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProgressReportCreateWithoutUserInput = {
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutProgressReportsInput
    orderProduct?: OrderProductCreateNestedOneWithoutIndividualProgressReportsInput
    product?: ProductCreateNestedOneWithoutIndividualProgressReportsInput
    productReports?: ProductProgressReportCreateNestedManyWithoutProgressReportInput
  }

  export type ProgressReportUncheckedCreateWithoutUserInput = {
    id?: number
    orderId?: number | null
    orderProductId?: number | null
    productId?: number | null
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProgressReportInput
  }

  export type ProgressReportCreateOrConnectWithoutUserInput = {
    where: ProgressReportWhereUniqueInput
    create: XOR<ProgressReportCreateWithoutUserInput, ProgressReportUncheckedCreateWithoutUserInput>
  }

  export type ProgressReportCreateManyUserInputEnvelope = {
    data: ProgressReportCreateManyUserInput | ProgressReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderLinkCreateWithoutUserInput = {
    linkToken: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderLinkInput
  }

  export type OrderLinkUncheckedCreateWithoutUserInput = {
    id?: number
    orderId: number
    linkToken: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderLinkCreateOrConnectWithoutUserInput = {
    where: OrderLinkWhereUniqueInput
    create: XOR<OrderLinkCreateWithoutUserInput, OrderLinkUncheckedCreateWithoutUserInput>
  }

  export type OrderLinkCreateManyUserInputEnvelope = {
    data: OrderLinkCreateManyUserInput | OrderLinkCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StatusChangeCreateWithoutUserInput = {
    fromStatus: $Enums.OrderStatus
    toStatus: $Enums.OrderStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutStatusChangesInput
  }

  export type StatusChangeUncheckedCreateWithoutUserInput = {
    id?: number
    orderId: number
    fromStatus: $Enums.OrderStatus
    toStatus: $Enums.OrderStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusChangeCreateOrConnectWithoutUserInput = {
    where: StatusChangeWhereUniqueInput
    create: XOR<StatusChangeCreateWithoutUserInput, StatusChangeUncheckedCreateWithoutUserInput>
  }

  export type StatusChangeCreateManyUserInputEnvelope = {
    data: StatusChangeCreateManyUserInput | StatusChangeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MaterialPurchaseAlertCreateWithoutCreatedByUserInput = {
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutPurchaseAlertsInput
    order?: OrderCreateNestedOneWithoutPurchaseAlertsInput
    resolvedByUser?: UserCreateNestedOneWithoutResolvedAlertsInput
  }

  export type MaterialPurchaseAlertUncheckedCreateWithoutCreatedByUserInput = {
    id?: number
    materialId: number
    orderId?: number | null
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    resolvedBy?: number | null
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialPurchaseAlertCreateOrConnectWithoutCreatedByUserInput = {
    where: MaterialPurchaseAlertWhereUniqueInput
    create: XOR<MaterialPurchaseAlertCreateWithoutCreatedByUserInput, MaterialPurchaseAlertUncheckedCreateWithoutCreatedByUserInput>
  }

  export type MaterialPurchaseAlertCreateManyCreatedByUserInputEnvelope = {
    data: MaterialPurchaseAlertCreateManyCreatedByUserInput | MaterialPurchaseAlertCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type MaterialPurchaseAlertCreateWithoutResolvedByUserInput = {
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutPurchaseAlertsInput
    order?: OrderCreateNestedOneWithoutPurchaseAlertsInput
    createdByUser: UserCreateNestedOneWithoutCreatedAlertsInput
  }

  export type MaterialPurchaseAlertUncheckedCreateWithoutResolvedByUserInput = {
    id?: number
    materialId: number
    orderId?: number | null
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    createdBy: number
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialPurchaseAlertCreateOrConnectWithoutResolvedByUserInput = {
    where: MaterialPurchaseAlertWhereUniqueInput
    create: XOR<MaterialPurchaseAlertCreateWithoutResolvedByUserInput, MaterialPurchaseAlertUncheckedCreateWithoutResolvedByUserInput>
  }

  export type MaterialPurchaseAlertCreateManyResolvedByUserInputEnvelope = {
    data: MaterialPurchaseAlertCreateManyResolvedByUserInput | MaterialPurchaseAlertCreateManyResolvedByUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactNoteCreateWithoutCreatedByUserInput = {
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutContactNotesInput
    order?: OrderCreateNestedOneWithoutContactNotesInput
    purchaseLog?: PurchaseLogCreateNestedOneWithoutContactNotesInput
  }

  export type ContactNoteUncheckedCreateWithoutCreatedByUserInput = {
    id?: number
    contactId: number
    orderId?: number | null
    purchaseLogId?: number | null
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactNoteCreateOrConnectWithoutCreatedByUserInput = {
    where: ContactNoteWhereUniqueInput
    create: XOR<ContactNoteCreateWithoutCreatedByUserInput, ContactNoteUncheckedCreateWithoutCreatedByUserInput>
  }

  export type ContactNoteCreateManyCreatedByUserInputEnvelope = {
    data: ContactNoteCreateManyCreatedByUserInput | ContactNoteCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    orderNumber?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    targetPcs?: IntFilter<"Order"> | number
    completedPcs?: IntFilter<"Order"> | number
    customerNote?: StringNullableFilter<"Order"> | string | null
    dueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    userId?: IntFilter<"Order"> | number
    workerId?: IntNullableFilter<"Order"> | number | null
    workerContactId?: IntNullableFilter<"Order"> | number | null
    description?: StringNullableFilter<"Order"> | string | null
    priority?: EnumPriorityFilter<"Order"> | $Enums.Priority
    isActive?: BoolFilter<"Order"> | boolean
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutWorkerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutWorkerInput, OrderUncheckedUpdateWithoutWorkerInput>
    create: XOR<OrderCreateWithoutWorkerInput, OrderUncheckedCreateWithoutWorkerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutWorkerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutWorkerInput, OrderUncheckedUpdateWithoutWorkerInput>
  }

  export type OrderUpdateManyWithWhereWithoutWorkerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutWorkerInput>
  }

  export type MaterialMovementUpsertWithWhereUniqueWithoutUserInput = {
    where: MaterialMovementWhereUniqueInput
    update: XOR<MaterialMovementUpdateWithoutUserInput, MaterialMovementUncheckedUpdateWithoutUserInput>
    create: XOR<MaterialMovementCreateWithoutUserInput, MaterialMovementUncheckedCreateWithoutUserInput>
  }

  export type MaterialMovementUpdateWithWhereUniqueWithoutUserInput = {
    where: MaterialMovementWhereUniqueInput
    data: XOR<MaterialMovementUpdateWithoutUserInput, MaterialMovementUncheckedUpdateWithoutUserInput>
  }

  export type MaterialMovementUpdateManyWithWhereWithoutUserInput = {
    where: MaterialMovementScalarWhereInput
    data: XOR<MaterialMovementUpdateManyMutationInput, MaterialMovementUncheckedUpdateManyWithoutUserInput>
  }

  export type MaterialMovementScalarWhereInput = {
    AND?: MaterialMovementScalarWhereInput | MaterialMovementScalarWhereInput[]
    OR?: MaterialMovementScalarWhereInput[]
    NOT?: MaterialMovementScalarWhereInput | MaterialMovementScalarWhereInput[]
    id?: IntFilter<"MaterialMovement"> | number
    materialId?: IntFilter<"MaterialMovement"> | number
    orderId?: IntNullableFilter<"MaterialMovement"> | number | null
    userId?: IntFilter<"MaterialMovement"> | number
    purchaseLogId?: IntNullableFilter<"MaterialMovement"> | number | null
    movementType?: EnumMaterialMovementTypeFilter<"MaterialMovement"> | $Enums.MaterialMovementType
    quantity?: DecimalFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"MaterialMovement"> | string
    costPerUnit?: DecimalNullableFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"MaterialMovement"> | string | null
    qtyAfter?: DecimalFilter<"MaterialMovement"> | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFilter<"MaterialMovement"> | Date | string
    isActive?: BoolFilter<"MaterialMovement"> | boolean
    createdAt?: DateTimeFilter<"MaterialMovement"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialMovement"> | Date | string
  }

  export type ProgressReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ProgressReportWhereUniqueInput
    update: XOR<ProgressReportUpdateWithoutUserInput, ProgressReportUncheckedUpdateWithoutUserInput>
    create: XOR<ProgressReportCreateWithoutUserInput, ProgressReportUncheckedCreateWithoutUserInput>
  }

  export type ProgressReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ProgressReportWhereUniqueInput
    data: XOR<ProgressReportUpdateWithoutUserInput, ProgressReportUncheckedUpdateWithoutUserInput>
  }

  export type ProgressReportUpdateManyWithWhereWithoutUserInput = {
    where: ProgressReportScalarWhereInput
    data: XOR<ProgressReportUpdateManyMutationInput, ProgressReportUncheckedUpdateManyWithoutUserInput>
  }

  export type ProgressReportScalarWhereInput = {
    AND?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
    OR?: ProgressReportScalarWhereInput[]
    NOT?: ProgressReportScalarWhereInput | ProgressReportScalarWhereInput[]
    id?: IntFilter<"ProgressReport"> | number
    orderId?: IntNullableFilter<"ProgressReport"> | number | null
    orderProductId?: IntNullableFilter<"ProgressReport"> | number | null
    productId?: IntNullableFilter<"ProgressReport"> | number | null
    userId?: IntFilter<"ProgressReport"> | number
    reportText?: StringFilter<"ProgressReport"> | string
    photoPath?: StringNullableFilter<"ProgressReport"> | string | null
    percentage?: IntFilter<"ProgressReport"> | number
    createdAt?: DateTimeFilter<"ProgressReport"> | Date | string
    updatedAt?: DateTimeFilter<"ProgressReport"> | Date | string
  }

  export type OrderLinkUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderLinkWhereUniqueInput
    update: XOR<OrderLinkUpdateWithoutUserInput, OrderLinkUncheckedUpdateWithoutUserInput>
    create: XOR<OrderLinkCreateWithoutUserInput, OrderLinkUncheckedCreateWithoutUserInput>
  }

  export type OrderLinkUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderLinkWhereUniqueInput
    data: XOR<OrderLinkUpdateWithoutUserInput, OrderLinkUncheckedUpdateWithoutUserInput>
  }

  export type OrderLinkUpdateManyWithWhereWithoutUserInput = {
    where: OrderLinkScalarWhereInput
    data: XOR<OrderLinkUpdateManyMutationInput, OrderLinkUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderLinkScalarWhereInput = {
    AND?: OrderLinkScalarWhereInput | OrderLinkScalarWhereInput[]
    OR?: OrderLinkScalarWhereInput[]
    NOT?: OrderLinkScalarWhereInput | OrderLinkScalarWhereInput[]
    id?: IntFilter<"OrderLink"> | number
    orderId?: IntFilter<"OrderLink"> | number
    userId?: IntFilter<"OrderLink"> | number
    linkToken?: StringFilter<"OrderLink"> | string
    isActive?: BoolFilter<"OrderLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"OrderLink"> | Date | string | null
    createdAt?: DateTimeFilter<"OrderLink"> | Date | string
    updatedAt?: DateTimeFilter<"OrderLink"> | Date | string
  }

  export type StatusChangeUpsertWithWhereUniqueWithoutUserInput = {
    where: StatusChangeWhereUniqueInput
    update: XOR<StatusChangeUpdateWithoutUserInput, StatusChangeUncheckedUpdateWithoutUserInput>
    create: XOR<StatusChangeCreateWithoutUserInput, StatusChangeUncheckedCreateWithoutUserInput>
  }

  export type StatusChangeUpdateWithWhereUniqueWithoutUserInput = {
    where: StatusChangeWhereUniqueInput
    data: XOR<StatusChangeUpdateWithoutUserInput, StatusChangeUncheckedUpdateWithoutUserInput>
  }

  export type StatusChangeUpdateManyWithWhereWithoutUserInput = {
    where: StatusChangeScalarWhereInput
    data: XOR<StatusChangeUpdateManyMutationInput, StatusChangeUncheckedUpdateManyWithoutUserInput>
  }

  export type StatusChangeScalarWhereInput = {
    AND?: StatusChangeScalarWhereInput | StatusChangeScalarWhereInput[]
    OR?: StatusChangeScalarWhereInput[]
    NOT?: StatusChangeScalarWhereInput | StatusChangeScalarWhereInput[]
    id?: IntFilter<"StatusChange"> | number
    orderId?: IntFilter<"StatusChange"> | number
    changedBy?: IntFilter<"StatusChange"> | number
    fromStatus?: EnumOrderStatusFilter<"StatusChange"> | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFilter<"StatusChange"> | $Enums.OrderStatus
    reason?: StringNullableFilter<"StatusChange"> | string | null
    notes?: StringNullableFilter<"StatusChange"> | string | null
    createdAt?: DateTimeFilter<"StatusChange"> | Date | string
    updatedAt?: DateTimeFilter<"StatusChange"> | Date | string
  }

  export type MaterialPurchaseAlertUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: MaterialPurchaseAlertWhereUniqueInput
    update: XOR<MaterialPurchaseAlertUpdateWithoutCreatedByUserInput, MaterialPurchaseAlertUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<MaterialPurchaseAlertCreateWithoutCreatedByUserInput, MaterialPurchaseAlertUncheckedCreateWithoutCreatedByUserInput>
  }

  export type MaterialPurchaseAlertUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: MaterialPurchaseAlertWhereUniqueInput
    data: XOR<MaterialPurchaseAlertUpdateWithoutCreatedByUserInput, MaterialPurchaseAlertUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type MaterialPurchaseAlertUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: MaterialPurchaseAlertScalarWhereInput
    data: XOR<MaterialPurchaseAlertUpdateManyMutationInput, MaterialPurchaseAlertUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type MaterialPurchaseAlertScalarWhereInput = {
    AND?: MaterialPurchaseAlertScalarWhereInput | MaterialPurchaseAlertScalarWhereInput[]
    OR?: MaterialPurchaseAlertScalarWhereInput[]
    NOT?: MaterialPurchaseAlertScalarWhereInput | MaterialPurchaseAlertScalarWhereInput[]
    id?: IntFilter<"MaterialPurchaseAlert"> | number
    materialId?: IntFilter<"MaterialPurchaseAlert"> | number
    orderId?: IntNullableFilter<"MaterialPurchaseAlert"> | number | null
    alertType?: EnumMaterialPurchaseAlertTypeFilter<"MaterialPurchaseAlert"> | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFilter<"MaterialPurchaseAlert"> | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFilter<"MaterialPurchaseAlert"> | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFilter<"MaterialPurchaseAlert"> | $Enums.UrgencyLevel
    message?: StringFilter<"MaterialPurchaseAlert"> | string
    status?: EnumAlertStatusFilter<"MaterialPurchaseAlert"> | $Enums.AlertStatus
    createdBy?: IntFilter<"MaterialPurchaseAlert"> | number
    resolvedBy?: IntNullableFilter<"MaterialPurchaseAlert"> | number | null
    resolvedAt?: DateTimeNullableFilter<"MaterialPurchaseAlert"> | Date | string | null
    resolution?: StringNullableFilter<"MaterialPurchaseAlert"> | string | null
    estimatedCost?: DecimalNullableFilter<"MaterialPurchaseAlert"> | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: StringNullableFilter<"MaterialPurchaseAlert"> | string | null
    createdAt?: DateTimeFilter<"MaterialPurchaseAlert"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialPurchaseAlert"> | Date | string
  }

  export type MaterialPurchaseAlertUpsertWithWhereUniqueWithoutResolvedByUserInput = {
    where: MaterialPurchaseAlertWhereUniqueInput
    update: XOR<MaterialPurchaseAlertUpdateWithoutResolvedByUserInput, MaterialPurchaseAlertUncheckedUpdateWithoutResolvedByUserInput>
    create: XOR<MaterialPurchaseAlertCreateWithoutResolvedByUserInput, MaterialPurchaseAlertUncheckedCreateWithoutResolvedByUserInput>
  }

  export type MaterialPurchaseAlertUpdateWithWhereUniqueWithoutResolvedByUserInput = {
    where: MaterialPurchaseAlertWhereUniqueInput
    data: XOR<MaterialPurchaseAlertUpdateWithoutResolvedByUserInput, MaterialPurchaseAlertUncheckedUpdateWithoutResolvedByUserInput>
  }

  export type MaterialPurchaseAlertUpdateManyWithWhereWithoutResolvedByUserInput = {
    where: MaterialPurchaseAlertScalarWhereInput
    data: XOR<MaterialPurchaseAlertUpdateManyMutationInput, MaterialPurchaseAlertUncheckedUpdateManyWithoutResolvedByUserInput>
  }

  export type ContactNoteUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: ContactNoteWhereUniqueInput
    update: XOR<ContactNoteUpdateWithoutCreatedByUserInput, ContactNoteUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<ContactNoteCreateWithoutCreatedByUserInput, ContactNoteUncheckedCreateWithoutCreatedByUserInput>
  }

  export type ContactNoteUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: ContactNoteWhereUniqueInput
    data: XOR<ContactNoteUpdateWithoutCreatedByUserInput, ContactNoteUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type ContactNoteUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: ContactNoteScalarWhereInput
    data: XOR<ContactNoteUpdateManyMutationInput, ContactNoteUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type ContactNoteScalarWhereInput = {
    AND?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
    OR?: ContactNoteScalarWhereInput[]
    NOT?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
    id?: IntFilter<"ContactNote"> | number
    contactId?: IntFilter<"ContactNote"> | number
    orderId?: IntNullableFilter<"ContactNote"> | number | null
    purchaseLogId?: IntNullableFilter<"ContactNote"> | number | null
    createdBy?: IntFilter<"ContactNote"> | number
    noteType?: EnumNoteTypeFilter<"ContactNote"> | $Enums.NoteType
    subject?: StringNullableFilter<"ContactNote"> | string | null
    content?: StringFilter<"ContactNote"> | string
    followUpDate?: DateTimeNullableFilter<"ContactNote"> | Date | string | null
    isImportant?: BoolFilter<"ContactNote"> | boolean
    tags?: StringNullableFilter<"ContactNote"> | string | null
    attachmentPath?: StringNullableFilter<"ContactNote"> | string | null
    isActive?: BoolFilter<"ContactNote"> | boolean
    createdAt?: DateTimeFilter<"ContactNote"> | Date | string
    updatedAt?: DateTimeFilter<"ContactNote"> | Date | string
  }

  export type MaterialMovementCreateWithoutMaterialInput = {
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutMaterialMovementsInput
    user: UserCreateNestedOneWithoutMaterialMovementsInput
    purchaseLog?: PurchaseLogCreateNestedOneWithoutMovementInput
  }

  export type MaterialMovementUncheckedCreateWithoutMaterialInput = {
    id?: number
    orderId?: number | null
    userId: number
    purchaseLogId?: number | null
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialMovementCreateOrConnectWithoutMaterialInput = {
    where: MaterialMovementWhereUniqueInput
    create: XOR<MaterialMovementCreateWithoutMaterialInput, MaterialMovementUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialMovementCreateManyMaterialInputEnvelope = {
    data: MaterialMovementCreateManyMaterialInput | MaterialMovementCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type ProductMaterialCreateWithoutMaterialInput = {
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductMaterialsInput
  }

  export type ProductMaterialUncheckedCreateWithoutMaterialInput = {
    id?: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductMaterialCreateOrConnectWithoutMaterialInput = {
    where: ProductMaterialWhereUniqueInput
    create: XOR<ProductMaterialCreateWithoutMaterialInput, ProductMaterialUncheckedCreateWithoutMaterialInput>
  }

  export type ProductMaterialCreateManyMaterialInputEnvelope = {
    data: ProductMaterialCreateManyMaterialInput | ProductMaterialCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type RemainingMaterialCreateWithoutMaterialInput = {
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RemainingMaterialUncheckedCreateWithoutMaterialInput = {
    id?: number
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RemainingMaterialCreateOrConnectWithoutMaterialInput = {
    where: RemainingMaterialWhereUniqueInput
    create: XOR<RemainingMaterialCreateWithoutMaterialInput, RemainingMaterialUncheckedCreateWithoutMaterialInput>
  }

  export type RemainingMaterialCreateManyMaterialInputEnvelope = {
    data: RemainingMaterialCreateManyMaterialInput | RemainingMaterialCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutBaseMaterialInput = {
    name: string
    code: string
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanCreateNestedManyWithoutProductInput
    colours?: ProductColourCreateNestedManyWithoutProductInput
    variations?: ProductVariationCreateNestedManyWithoutProductInput
    photos?: ProductPhotoCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBaseMaterialInput = {
    id?: number
    name: string
    code: string
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanUncheckedCreateNestedManyWithoutProductInput
    colours?: ProductColourUncheckedCreateNestedManyWithoutProductInput
    variations?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    photos?: ProductPhotoUncheckedCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBaseMaterialInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBaseMaterialInput, ProductUncheckedCreateWithoutBaseMaterialInput>
  }

  export type ProductCreateManyBaseMaterialInputEnvelope = {
    data: ProductCreateManyBaseMaterialInput | ProductCreateManyBaseMaterialInput[]
    skipDuplicates?: boolean
  }

  export type MaterialPurchaseAlertCreateWithoutMaterialInput = {
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutPurchaseAlertsInput
    createdByUser: UserCreateNestedOneWithoutCreatedAlertsInput
    resolvedByUser?: UserCreateNestedOneWithoutResolvedAlertsInput
  }

  export type MaterialPurchaseAlertUncheckedCreateWithoutMaterialInput = {
    id?: number
    orderId?: number | null
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    createdBy: number
    resolvedBy?: number | null
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialPurchaseAlertCreateOrConnectWithoutMaterialInput = {
    where: MaterialPurchaseAlertWhereUniqueInput
    create: XOR<MaterialPurchaseAlertCreateWithoutMaterialInput, MaterialPurchaseAlertUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialPurchaseAlertCreateManyMaterialInputEnvelope = {
    data: MaterialPurchaseAlertCreateManyMaterialInput | MaterialPurchaseAlertCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseLogCreateWithoutMaterialInput = {
    supplier: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    pricePerUnit?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    invoiceNumber?: string | null
    receiptPath?: string | null
    notes?: string | null
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    receivedQuantity?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movement?: MaterialMovementCreateNestedOneWithoutPurchaseLogInput
    contactNotes?: ContactNoteCreateNestedManyWithoutPurchaseLogInput
  }

  export type PurchaseLogUncheckedCreateWithoutMaterialInput = {
    id?: number
    supplier: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    pricePerUnit?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    invoiceNumber?: string | null
    receiptPath?: string | null
    notes?: string | null
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    receivedQuantity?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movement?: MaterialMovementUncheckedCreateNestedOneWithoutPurchaseLogInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutPurchaseLogInput
  }

  export type PurchaseLogCreateOrConnectWithoutMaterialInput = {
    where: PurchaseLogWhereUniqueInput
    create: XOR<PurchaseLogCreateWithoutMaterialInput, PurchaseLogUncheckedCreateWithoutMaterialInput>
  }

  export type PurchaseLogCreateManyMaterialInputEnvelope = {
    data: PurchaseLogCreateManyMaterialInput | PurchaseLogCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type MaterialMovementUpsertWithWhereUniqueWithoutMaterialInput = {
    where: MaterialMovementWhereUniqueInput
    update: XOR<MaterialMovementUpdateWithoutMaterialInput, MaterialMovementUncheckedUpdateWithoutMaterialInput>
    create: XOR<MaterialMovementCreateWithoutMaterialInput, MaterialMovementUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialMovementUpdateWithWhereUniqueWithoutMaterialInput = {
    where: MaterialMovementWhereUniqueInput
    data: XOR<MaterialMovementUpdateWithoutMaterialInput, MaterialMovementUncheckedUpdateWithoutMaterialInput>
  }

  export type MaterialMovementUpdateManyWithWhereWithoutMaterialInput = {
    where: MaterialMovementScalarWhereInput
    data: XOR<MaterialMovementUpdateManyMutationInput, MaterialMovementUncheckedUpdateManyWithoutMaterialInput>
  }

  export type ProductMaterialUpsertWithWhereUniqueWithoutMaterialInput = {
    where: ProductMaterialWhereUniqueInput
    update: XOR<ProductMaterialUpdateWithoutMaterialInput, ProductMaterialUncheckedUpdateWithoutMaterialInput>
    create: XOR<ProductMaterialCreateWithoutMaterialInput, ProductMaterialUncheckedCreateWithoutMaterialInput>
  }

  export type ProductMaterialUpdateWithWhereUniqueWithoutMaterialInput = {
    where: ProductMaterialWhereUniqueInput
    data: XOR<ProductMaterialUpdateWithoutMaterialInput, ProductMaterialUncheckedUpdateWithoutMaterialInput>
  }

  export type ProductMaterialUpdateManyWithWhereWithoutMaterialInput = {
    where: ProductMaterialScalarWhereInput
    data: XOR<ProductMaterialUpdateManyMutationInput, ProductMaterialUncheckedUpdateManyWithoutMaterialInput>
  }

  export type ProductMaterialScalarWhereInput = {
    AND?: ProductMaterialScalarWhereInput | ProductMaterialScalarWhereInput[]
    OR?: ProductMaterialScalarWhereInput[]
    NOT?: ProductMaterialScalarWhereInput | ProductMaterialScalarWhereInput[]
    id?: IntFilter<"ProductMaterial"> | number
    productId?: IntFilter<"ProductMaterial"> | number
    materialId?: IntFilter<"ProductMaterial"> | number
    quantity?: DecimalFilter<"ProductMaterial"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"ProductMaterial"> | string
    createdAt?: DateTimeFilter<"ProductMaterial"> | Date | string
    updatedAt?: DateTimeFilter<"ProductMaterial"> | Date | string
  }

  export type RemainingMaterialUpsertWithWhereUniqueWithoutMaterialInput = {
    where: RemainingMaterialWhereUniqueInput
    update: XOR<RemainingMaterialUpdateWithoutMaterialInput, RemainingMaterialUncheckedUpdateWithoutMaterialInput>
    create: XOR<RemainingMaterialCreateWithoutMaterialInput, RemainingMaterialUncheckedCreateWithoutMaterialInput>
  }

  export type RemainingMaterialUpdateWithWhereUniqueWithoutMaterialInput = {
    where: RemainingMaterialWhereUniqueInput
    data: XOR<RemainingMaterialUpdateWithoutMaterialInput, RemainingMaterialUncheckedUpdateWithoutMaterialInput>
  }

  export type RemainingMaterialUpdateManyWithWhereWithoutMaterialInput = {
    where: RemainingMaterialScalarWhereInput
    data: XOR<RemainingMaterialUpdateManyMutationInput, RemainingMaterialUncheckedUpdateManyWithoutMaterialInput>
  }

  export type RemainingMaterialScalarWhereInput = {
    AND?: RemainingMaterialScalarWhereInput | RemainingMaterialScalarWhereInput[]
    OR?: RemainingMaterialScalarWhereInput[]
    NOT?: RemainingMaterialScalarWhereInput | RemainingMaterialScalarWhereInput[]
    id?: IntFilter<"RemainingMaterial"> | number
    materialId?: IntFilter<"RemainingMaterial"> | number
    quantity?: DecimalFilter<"RemainingMaterial"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RemainingMaterial"> | string
    notes?: StringNullableFilter<"RemainingMaterial"> | string | null
    createdAt?: DateTimeFilter<"RemainingMaterial"> | Date | string
    updatedAt?: DateTimeFilter<"RemainingMaterial"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutBaseMaterialInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBaseMaterialInput, ProductUncheckedUpdateWithoutBaseMaterialInput>
    create: XOR<ProductCreateWithoutBaseMaterialInput, ProductUncheckedCreateWithoutBaseMaterialInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBaseMaterialInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBaseMaterialInput, ProductUncheckedUpdateWithoutBaseMaterialInput>
  }

  export type ProductUpdateManyWithWhereWithoutBaseMaterialInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBaseMaterialInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    code?: StringFilter<"Product"> | string
    materialId?: IntNullableFilter<"Product"> | number | null
    category?: StringNullableFilter<"Product"> | string | null
    price?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFilter<"Product"> | number
    unit?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    defaultTarget?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type MaterialPurchaseAlertUpsertWithWhereUniqueWithoutMaterialInput = {
    where: MaterialPurchaseAlertWhereUniqueInput
    update: XOR<MaterialPurchaseAlertUpdateWithoutMaterialInput, MaterialPurchaseAlertUncheckedUpdateWithoutMaterialInput>
    create: XOR<MaterialPurchaseAlertCreateWithoutMaterialInput, MaterialPurchaseAlertUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialPurchaseAlertUpdateWithWhereUniqueWithoutMaterialInput = {
    where: MaterialPurchaseAlertWhereUniqueInput
    data: XOR<MaterialPurchaseAlertUpdateWithoutMaterialInput, MaterialPurchaseAlertUncheckedUpdateWithoutMaterialInput>
  }

  export type MaterialPurchaseAlertUpdateManyWithWhereWithoutMaterialInput = {
    where: MaterialPurchaseAlertScalarWhereInput
    data: XOR<MaterialPurchaseAlertUpdateManyMutationInput, MaterialPurchaseAlertUncheckedUpdateManyWithoutMaterialInput>
  }

  export type PurchaseLogUpsertWithWhereUniqueWithoutMaterialInput = {
    where: PurchaseLogWhereUniqueInput
    update: XOR<PurchaseLogUpdateWithoutMaterialInput, PurchaseLogUncheckedUpdateWithoutMaterialInput>
    create: XOR<PurchaseLogCreateWithoutMaterialInput, PurchaseLogUncheckedCreateWithoutMaterialInput>
  }

  export type PurchaseLogUpdateWithWhereUniqueWithoutMaterialInput = {
    where: PurchaseLogWhereUniqueInput
    data: XOR<PurchaseLogUpdateWithoutMaterialInput, PurchaseLogUncheckedUpdateWithoutMaterialInput>
  }

  export type PurchaseLogUpdateManyWithWhereWithoutMaterialInput = {
    where: PurchaseLogScalarWhereInput
    data: XOR<PurchaseLogUpdateManyMutationInput, PurchaseLogUncheckedUpdateManyWithoutMaterialInput>
  }

  export type PurchaseLogScalarWhereInput = {
    AND?: PurchaseLogScalarWhereInput | PurchaseLogScalarWhereInput[]
    OR?: PurchaseLogScalarWhereInput[]
    NOT?: PurchaseLogScalarWhereInput | PurchaseLogScalarWhereInput[]
    id?: IntFilter<"PurchaseLog"> | number
    materialId?: IntFilter<"PurchaseLog"> | number
    supplier?: StringFilter<"PurchaseLog"> | string
    quantity?: DecimalFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"PurchaseLog"> | string
    pricePerUnit?: DecimalFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFilter<"PurchaseLog"> | Date | string
    invoiceNumber?: StringNullableFilter<"PurchaseLog"> | string | null
    receiptPath?: StringNullableFilter<"PurchaseLog"> | string | null
    notes?: StringNullableFilter<"PurchaseLog"> | string | null
    status?: EnumPurchaseStatusFilter<"PurchaseLog"> | $Enums.PurchaseStatus
    deliveryDate?: DateTimeNullableFilter<"PurchaseLog"> | Date | string | null
    receivedQuantity?: DecimalNullableFilter<"PurchaseLog"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"PurchaseLog"> | boolean
    createdAt?: DateTimeFilter<"PurchaseLog"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseLog"> | Date | string
  }

  export type MaterialCreateWithoutProductsInput = {
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementCreateNestedManyWithoutMaterialInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutMaterialInput
    remainingMaterials?: RemainingMaterialCreateNestedManyWithoutMaterialInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutMaterialInput
    purchaseLogs?: PurchaseLogCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutMaterialInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutMaterialInput
    remainingMaterials?: RemainingMaterialUncheckedCreateNestedManyWithoutMaterialInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutMaterialInput
    purchaseLogs?: PurchaseLogUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutProductsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutProductsInput, MaterialUncheckedCreateWithoutProductsInput>
  }

  export type OrderProductCreateWithoutProductInput = {
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderProductsInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutOrderProductInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutOrderProductInput
  }

  export type OrderProductUncheckedCreateWithoutProductInput = {
    id?: number
    orderId: number
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderProductInput
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutOrderProductInput
  }

  export type OrderProductCreateOrConnectWithoutProductInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput>
  }

  export type OrderProductCreateManyProductInputEnvelope = {
    data: OrderProductCreateManyProductInput | OrderProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductMaterialCreateWithoutProductInput = {
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutProductMaterialsInput
  }

  export type ProductMaterialUncheckedCreateWithoutProductInput = {
    id?: number
    materialId: number
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductMaterialCreateOrConnectWithoutProductInput = {
    where: ProductMaterialWhereUniqueInput
    create: XOR<ProductMaterialCreateWithoutProductInput, ProductMaterialUncheckedCreateWithoutProductInput>
  }

  export type ProductMaterialCreateManyProductInputEnvelope = {
    data: ProductMaterialCreateManyProductInput | ProductMaterialCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type RecurringPlanCreateWithoutProductInput = {
    quantity?: number
    frequency?: string
    isActive?: boolean
    nextDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringPlanUncheckedCreateWithoutProductInput = {
    id?: number
    quantity?: number
    frequency?: string
    isActive?: boolean
    nextDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringPlanCreateOrConnectWithoutProductInput = {
    where: RecurringPlanWhereUniqueInput
    create: XOR<RecurringPlanCreateWithoutProductInput, RecurringPlanUncheckedCreateWithoutProductInput>
  }

  export type RecurringPlanCreateManyProductInputEnvelope = {
    data: RecurringPlanCreateManyProductInput | RecurringPlanCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductColourCreateWithoutProductInput = {
    colorName: string
    colorCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductColourUncheckedCreateWithoutProductInput = {
    id?: number
    colorName: string
    colorCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductColourCreateOrConnectWithoutProductInput = {
    where: ProductColourWhereUniqueInput
    create: XOR<ProductColourCreateWithoutProductInput, ProductColourUncheckedCreateWithoutProductInput>
  }

  export type ProductColourCreateManyProductInputEnvelope = {
    data: ProductColourCreateManyProductInput | ProductColourCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductVariationCreateWithoutProductInput = {
    variationType: string
    variationValue: string
    priceAdjustment?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationUncheckedCreateWithoutProductInput = {
    id?: number
    variationType: string
    variationValue: string
    priceAdjustment?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationCreateOrConnectWithoutProductInput = {
    where: ProductVariationWhereUniqueInput
    create: XOR<ProductVariationCreateWithoutProductInput, ProductVariationUncheckedCreateWithoutProductInput>
  }

  export type ProductVariationCreateManyProductInputEnvelope = {
    data: ProductVariationCreateManyProductInput | ProductVariationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductPhotoCreateWithoutProductInput = {
    photoPath: string
    thumbnailPath?: string | null
    description?: string | null
    isPrimary?: boolean
    sortOrder?: number
    fileSize?: number | null
    mimeType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductPhotoUncheckedCreateWithoutProductInput = {
    id?: number
    photoPath: string
    thumbnailPath?: string | null
    description?: string | null
    isPrimary?: boolean
    sortOrder?: number
    fileSize?: number | null
    mimeType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductPhotoCreateOrConnectWithoutProductInput = {
    where: ProductPhotoWhereUniqueInput
    create: XOR<ProductPhotoCreateWithoutProductInput, ProductPhotoUncheckedCreateWithoutProductInput>
  }

  export type ProductPhotoCreateManyProductInputEnvelope = {
    data: ProductPhotoCreateManyProductInput | ProductPhotoCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProgressReportCreateWithoutProductInput = {
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutProgressReportsInput
    orderProduct?: OrderProductCreateNestedOneWithoutIndividualProgressReportsInput
    user: UserCreateNestedOneWithoutProgressReportsInput
    productReports?: ProductProgressReportCreateNestedManyWithoutProgressReportInput
  }

  export type ProgressReportUncheckedCreateWithoutProductInput = {
    id?: number
    orderId?: number | null
    orderProductId?: number | null
    userId: number
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProgressReportInput
  }

  export type ProgressReportCreateOrConnectWithoutProductInput = {
    where: ProgressReportWhereUniqueInput
    create: XOR<ProgressReportCreateWithoutProductInput, ProgressReportUncheckedCreateWithoutProductInput>
  }

  export type ProgressReportCreateManyProductInputEnvelope = {
    data: ProgressReportCreateManyProductInput | ProgressReportCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductProgressReportCreateWithoutProductInput = {
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progressReport: ProgressReportCreateNestedOneWithoutProductReportsInput
    orderProduct?: OrderProductCreateNestedOneWithoutProductProgressReportsInput
    photos?: ProductProgressPhotoCreateNestedManyWithoutProductProgressReportInput
  }

  export type ProductProgressReportUncheckedCreateWithoutProductInput = {
    id?: number
    progressReportId: number
    orderProductId?: number | null
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ProductProgressPhotoUncheckedCreateNestedManyWithoutProductProgressReportInput
  }

  export type ProductProgressReportCreateOrConnectWithoutProductInput = {
    where: ProductProgressReportWhereUniqueInput
    create: XOR<ProductProgressReportCreateWithoutProductInput, ProductProgressReportUncheckedCreateWithoutProductInput>
  }

  export type ProductProgressReportCreateManyProductInputEnvelope = {
    data: ProductProgressReportCreateManyProductInput | ProductProgressReportCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type MaterialUpsertWithoutProductsInput = {
    update: XOR<MaterialUpdateWithoutProductsInput, MaterialUncheckedUpdateWithoutProductsInput>
    create: XOR<MaterialCreateWithoutProductsInput, MaterialUncheckedCreateWithoutProductsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutProductsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutProductsInput, MaterialUncheckedUpdateWithoutProductsInput>
  }

  export type MaterialUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUpdateManyWithoutMaterialNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutMaterialNestedInput
    remainingMaterials?: RemainingMaterialUpdateManyWithoutMaterialNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutMaterialNestedInput
    purchaseLogs?: PurchaseLogUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutMaterialNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutMaterialNestedInput
    remainingMaterials?: RemainingMaterialUncheckedUpdateManyWithoutMaterialNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutMaterialNestedInput
    purchaseLogs?: PurchaseLogUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type OrderProductUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderProductWhereUniqueInput
    update: XOR<OrderProductUpdateWithoutProductInput, OrderProductUncheckedUpdateWithoutProductInput>
    create: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput>
  }

  export type OrderProductUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderProductWhereUniqueInput
    data: XOR<OrderProductUpdateWithoutProductInput, OrderProductUncheckedUpdateWithoutProductInput>
  }

  export type OrderProductUpdateManyWithWhereWithoutProductInput = {
    where: OrderProductScalarWhereInput
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderProductScalarWhereInput = {
    AND?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
    OR?: OrderProductScalarWhereInput[]
    NOT?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
    id?: IntFilter<"OrderProduct"> | number
    orderId?: IntFilter<"OrderProduct"> | number
    productId?: IntFilter<"OrderProduct"> | number
    quantity?: IntFilter<"OrderProduct"> | number
    unitPrice?: DecimalNullableFilter<"OrderProduct"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"OrderProduct"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"OrderProduct"> | string | null
    completedQty?: IntFilter<"OrderProduct"> | number
    status?: EnumOrderProductStatusFilter<"OrderProduct"> | $Enums.OrderProductStatus
    createdAt?: DateTimeFilter<"OrderProduct"> | Date | string
    updatedAt?: DateTimeFilter<"OrderProduct"> | Date | string
  }

  export type ProductMaterialUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductMaterialWhereUniqueInput
    update: XOR<ProductMaterialUpdateWithoutProductInput, ProductMaterialUncheckedUpdateWithoutProductInput>
    create: XOR<ProductMaterialCreateWithoutProductInput, ProductMaterialUncheckedCreateWithoutProductInput>
  }

  export type ProductMaterialUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductMaterialWhereUniqueInput
    data: XOR<ProductMaterialUpdateWithoutProductInput, ProductMaterialUncheckedUpdateWithoutProductInput>
  }

  export type ProductMaterialUpdateManyWithWhereWithoutProductInput = {
    where: ProductMaterialScalarWhereInput
    data: XOR<ProductMaterialUpdateManyMutationInput, ProductMaterialUncheckedUpdateManyWithoutProductInput>
  }

  export type RecurringPlanUpsertWithWhereUniqueWithoutProductInput = {
    where: RecurringPlanWhereUniqueInput
    update: XOR<RecurringPlanUpdateWithoutProductInput, RecurringPlanUncheckedUpdateWithoutProductInput>
    create: XOR<RecurringPlanCreateWithoutProductInput, RecurringPlanUncheckedCreateWithoutProductInput>
  }

  export type RecurringPlanUpdateWithWhereUniqueWithoutProductInput = {
    where: RecurringPlanWhereUniqueInput
    data: XOR<RecurringPlanUpdateWithoutProductInput, RecurringPlanUncheckedUpdateWithoutProductInput>
  }

  export type RecurringPlanUpdateManyWithWhereWithoutProductInput = {
    where: RecurringPlanScalarWhereInput
    data: XOR<RecurringPlanUpdateManyMutationInput, RecurringPlanUncheckedUpdateManyWithoutProductInput>
  }

  export type RecurringPlanScalarWhereInput = {
    AND?: RecurringPlanScalarWhereInput | RecurringPlanScalarWhereInput[]
    OR?: RecurringPlanScalarWhereInput[]
    NOT?: RecurringPlanScalarWhereInput | RecurringPlanScalarWhereInput[]
    id?: IntFilter<"RecurringPlan"> | number
    productId?: IntFilter<"RecurringPlan"> | number
    quantity?: IntFilter<"RecurringPlan"> | number
    frequency?: StringFilter<"RecurringPlan"> | string
    isActive?: BoolFilter<"RecurringPlan"> | boolean
    nextDue?: DateTimeNullableFilter<"RecurringPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"RecurringPlan"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringPlan"> | Date | string
  }

  export type ProductColourUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductColourWhereUniqueInput
    update: XOR<ProductColourUpdateWithoutProductInput, ProductColourUncheckedUpdateWithoutProductInput>
    create: XOR<ProductColourCreateWithoutProductInput, ProductColourUncheckedCreateWithoutProductInput>
  }

  export type ProductColourUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductColourWhereUniqueInput
    data: XOR<ProductColourUpdateWithoutProductInput, ProductColourUncheckedUpdateWithoutProductInput>
  }

  export type ProductColourUpdateManyWithWhereWithoutProductInput = {
    where: ProductColourScalarWhereInput
    data: XOR<ProductColourUpdateManyMutationInput, ProductColourUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductColourScalarWhereInput = {
    AND?: ProductColourScalarWhereInput | ProductColourScalarWhereInput[]
    OR?: ProductColourScalarWhereInput[]
    NOT?: ProductColourScalarWhereInput | ProductColourScalarWhereInput[]
    id?: IntFilter<"ProductColour"> | number
    productId?: IntFilter<"ProductColour"> | number
    colorName?: StringFilter<"ProductColour"> | string
    colorCode?: StringNullableFilter<"ProductColour"> | string | null
    isActive?: BoolFilter<"ProductColour"> | boolean
    createdAt?: DateTimeFilter<"ProductColour"> | Date | string
    updatedAt?: DateTimeFilter<"ProductColour"> | Date | string
  }

  export type ProductVariationUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductVariationWhereUniqueInput
    update: XOR<ProductVariationUpdateWithoutProductInput, ProductVariationUncheckedUpdateWithoutProductInput>
    create: XOR<ProductVariationCreateWithoutProductInput, ProductVariationUncheckedCreateWithoutProductInput>
  }

  export type ProductVariationUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductVariationWhereUniqueInput
    data: XOR<ProductVariationUpdateWithoutProductInput, ProductVariationUncheckedUpdateWithoutProductInput>
  }

  export type ProductVariationUpdateManyWithWhereWithoutProductInput = {
    where: ProductVariationScalarWhereInput
    data: XOR<ProductVariationUpdateManyMutationInput, ProductVariationUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductVariationScalarWhereInput = {
    AND?: ProductVariationScalarWhereInput | ProductVariationScalarWhereInput[]
    OR?: ProductVariationScalarWhereInput[]
    NOT?: ProductVariationScalarWhereInput | ProductVariationScalarWhereInput[]
    id?: IntFilter<"ProductVariation"> | number
    productId?: IntFilter<"ProductVariation"> | number
    variationType?: StringFilter<"ProductVariation"> | string
    variationValue?: StringFilter<"ProductVariation"> | string
    priceAdjustment?: DecimalNullableFilter<"ProductVariation"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"ProductVariation"> | boolean
    createdAt?: DateTimeFilter<"ProductVariation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariation"> | Date | string
  }

  export type ProductPhotoUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductPhotoWhereUniqueInput
    update: XOR<ProductPhotoUpdateWithoutProductInput, ProductPhotoUncheckedUpdateWithoutProductInput>
    create: XOR<ProductPhotoCreateWithoutProductInput, ProductPhotoUncheckedCreateWithoutProductInput>
  }

  export type ProductPhotoUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductPhotoWhereUniqueInput
    data: XOR<ProductPhotoUpdateWithoutProductInput, ProductPhotoUncheckedUpdateWithoutProductInput>
  }

  export type ProductPhotoUpdateManyWithWhereWithoutProductInput = {
    where: ProductPhotoScalarWhereInput
    data: XOR<ProductPhotoUpdateManyMutationInput, ProductPhotoUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductPhotoScalarWhereInput = {
    AND?: ProductPhotoScalarWhereInput | ProductPhotoScalarWhereInput[]
    OR?: ProductPhotoScalarWhereInput[]
    NOT?: ProductPhotoScalarWhereInput | ProductPhotoScalarWhereInput[]
    id?: IntFilter<"ProductPhoto"> | number
    productId?: IntFilter<"ProductPhoto"> | number
    photoPath?: StringFilter<"ProductPhoto"> | string
    thumbnailPath?: StringNullableFilter<"ProductPhoto"> | string | null
    description?: StringNullableFilter<"ProductPhoto"> | string | null
    isPrimary?: BoolFilter<"ProductPhoto"> | boolean
    sortOrder?: IntFilter<"ProductPhoto"> | number
    fileSize?: IntNullableFilter<"ProductPhoto"> | number | null
    mimeType?: StringNullableFilter<"ProductPhoto"> | string | null
    isActive?: BoolFilter<"ProductPhoto"> | boolean
    createdAt?: DateTimeFilter<"ProductPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ProductPhoto"> | Date | string
  }

  export type ProgressReportUpsertWithWhereUniqueWithoutProductInput = {
    where: ProgressReportWhereUniqueInput
    update: XOR<ProgressReportUpdateWithoutProductInput, ProgressReportUncheckedUpdateWithoutProductInput>
    create: XOR<ProgressReportCreateWithoutProductInput, ProgressReportUncheckedCreateWithoutProductInput>
  }

  export type ProgressReportUpdateWithWhereUniqueWithoutProductInput = {
    where: ProgressReportWhereUniqueInput
    data: XOR<ProgressReportUpdateWithoutProductInput, ProgressReportUncheckedUpdateWithoutProductInput>
  }

  export type ProgressReportUpdateManyWithWhereWithoutProductInput = {
    where: ProgressReportScalarWhereInput
    data: XOR<ProgressReportUpdateManyMutationInput, ProgressReportUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductProgressReportUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductProgressReportWhereUniqueInput
    update: XOR<ProductProgressReportUpdateWithoutProductInput, ProductProgressReportUncheckedUpdateWithoutProductInput>
    create: XOR<ProductProgressReportCreateWithoutProductInput, ProductProgressReportUncheckedCreateWithoutProductInput>
  }

  export type ProductProgressReportUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductProgressReportWhereUniqueInput
    data: XOR<ProductProgressReportUpdateWithoutProductInput, ProductProgressReportUncheckedUpdateWithoutProductInput>
  }

  export type ProductProgressReportUpdateManyWithWhereWithoutProductInput = {
    where: ProductProgressReportScalarWhereInput
    data: XOR<ProductProgressReportUpdateManyMutationInput, ProductProgressReportUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductProgressReportScalarWhereInput = {
    AND?: ProductProgressReportScalarWhereInput | ProductProgressReportScalarWhereInput[]
    OR?: ProductProgressReportScalarWhereInput[]
    NOT?: ProductProgressReportScalarWhereInput | ProductProgressReportScalarWhereInput[]
    id?: IntFilter<"ProductProgressReport"> | number
    progressReportId?: IntFilter<"ProductProgressReport"> | number
    productId?: IntFilter<"ProductProgressReport"> | number
    orderProductId?: IntNullableFilter<"ProductProgressReport"> | number | null
    itemsCompleted?: IntFilter<"ProductProgressReport"> | number
    itemsTarget?: IntFilter<"ProductProgressReport"> | number
    status?: StringFilter<"ProductProgressReport"> | string
    notes?: StringNullableFilter<"ProductProgressReport"> | string | null
    completionDate?: DateTimeNullableFilter<"ProductProgressReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductProgressReport"> | Date | string
    updatedAt?: DateTimeFilter<"ProductProgressReport"> | Date | string
  }

  export type UserCreateWithoutOrdersInput = {
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workerOrders?: OrderCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workerOrders?: OrderUncheckedCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkUncheckedCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutWorkerOrdersInput = {
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutWorkerOrdersInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkUncheckedCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutWorkerOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkerOrdersInput, UserUncheckedCreateWithoutWorkerOrdersInput>
  }

  export type ContactCreateWithoutWorkerOrdersInput = {
    name: string
    phone?: string | null
    whatsappPhone?: string | null
    email?: string | null
    address?: string | null
    contactType: $Enums.ContactType
    company?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactNotes?: ContactNoteCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutWorkerOrdersInput = {
    id?: number
    name: string
    phone?: string | null
    whatsappPhone?: string | null
    email?: string | null
    address?: string | null
    contactType: $Enums.ContactType
    company?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutWorkerOrdersInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutWorkerOrdersInput, ContactUncheckedCreateWithoutWorkerOrdersInput>
  }

  export type OrderProductCreateWithoutOrderInput = {
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutOrderProductsInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutOrderProductInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutOrderProductInput
  }

  export type OrderProductUncheckedCreateWithoutOrderInput = {
    id?: number
    productId: number
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderProductInput
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutOrderProductInput
  }

  export type OrderProductCreateOrConnectWithoutOrderInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput>
  }

  export type OrderProductCreateManyOrderInputEnvelope = {
    data: OrderProductCreateManyOrderInput | OrderProductCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type MaterialMovementCreateWithoutOrderInput = {
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutMaterialMovementsInput
    user: UserCreateNestedOneWithoutMaterialMovementsInput
    purchaseLog?: PurchaseLogCreateNestedOneWithoutMovementInput
  }

  export type MaterialMovementUncheckedCreateWithoutOrderInput = {
    id?: number
    materialId: number
    userId: number
    purchaseLogId?: number | null
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialMovementCreateOrConnectWithoutOrderInput = {
    where: MaterialMovementWhereUniqueInput
    create: XOR<MaterialMovementCreateWithoutOrderInput, MaterialMovementUncheckedCreateWithoutOrderInput>
  }

  export type MaterialMovementCreateManyOrderInputEnvelope = {
    data: MaterialMovementCreateManyOrderInput | MaterialMovementCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ProgressReportCreateWithoutOrderInput = {
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProduct?: OrderProductCreateNestedOneWithoutIndividualProgressReportsInput
    product?: ProductCreateNestedOneWithoutIndividualProgressReportsInput
    user: UserCreateNestedOneWithoutProgressReportsInput
    productReports?: ProductProgressReportCreateNestedManyWithoutProgressReportInput
  }

  export type ProgressReportUncheckedCreateWithoutOrderInput = {
    id?: number
    orderProductId?: number | null
    productId?: number | null
    userId: number
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProgressReportInput
  }

  export type ProgressReportCreateOrConnectWithoutOrderInput = {
    where: ProgressReportWhereUniqueInput
    create: XOR<ProgressReportCreateWithoutOrderInput, ProgressReportUncheckedCreateWithoutOrderInput>
  }

  export type ProgressReportCreateManyOrderInputEnvelope = {
    data: ProgressReportCreateManyOrderInput | ProgressReportCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderLinkCreateWithoutOrderInput = {
    linkToken: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrderLinksInput
  }

  export type OrderLinkUncheckedCreateWithoutOrderInput = {
    id?: number
    userId: number
    linkToken: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderLinkCreateOrConnectWithoutOrderInput = {
    where: OrderLinkWhereUniqueInput
    create: XOR<OrderLinkCreateWithoutOrderInput, OrderLinkUncheckedCreateWithoutOrderInput>
  }

  export type ShipmentCreateWithoutOrderInput = {
    trackingNumber?: string | null
    carrier?: string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    status?: $Enums.ShipmentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShipmentUncheckedCreateWithoutOrderInput = {
    id?: number
    trackingNumber?: string | null
    carrier?: string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    status?: $Enums.ShipmentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShipmentCreateOrConnectWithoutOrderInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutOrderInput, ShipmentUncheckedCreateWithoutOrderInput>
  }

  export type StatusChangeCreateWithoutOrderInput = {
    fromStatus: $Enums.OrderStatus
    toStatus: $Enums.OrderStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStatusChangesInput
  }

  export type StatusChangeUncheckedCreateWithoutOrderInput = {
    id?: number
    changedBy: number
    fromStatus: $Enums.OrderStatus
    toStatus: $Enums.OrderStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusChangeCreateOrConnectWithoutOrderInput = {
    where: StatusChangeWhereUniqueInput
    create: XOR<StatusChangeCreateWithoutOrderInput, StatusChangeUncheckedCreateWithoutOrderInput>
  }

  export type StatusChangeCreateManyOrderInputEnvelope = {
    data: StatusChangeCreateManyOrderInput | StatusChangeCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type MaterialPurchaseAlertCreateWithoutOrderInput = {
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutPurchaseAlertsInput
    createdByUser: UserCreateNestedOneWithoutCreatedAlertsInput
    resolvedByUser?: UserCreateNestedOneWithoutResolvedAlertsInput
  }

  export type MaterialPurchaseAlertUncheckedCreateWithoutOrderInput = {
    id?: number
    materialId: number
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    createdBy: number
    resolvedBy?: number | null
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialPurchaseAlertCreateOrConnectWithoutOrderInput = {
    where: MaterialPurchaseAlertWhereUniqueInput
    create: XOR<MaterialPurchaseAlertCreateWithoutOrderInput, MaterialPurchaseAlertUncheckedCreateWithoutOrderInput>
  }

  export type MaterialPurchaseAlertCreateManyOrderInputEnvelope = {
    data: MaterialPurchaseAlertCreateManyOrderInput | MaterialPurchaseAlertCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ContactNoteCreateWithoutOrderInput = {
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutContactNotesInput
    purchaseLog?: PurchaseLogCreateNestedOneWithoutContactNotesInput
    createdByUser: UserCreateNestedOneWithoutCreatedContactNotesInput
  }

  export type ContactNoteUncheckedCreateWithoutOrderInput = {
    id?: number
    contactId: number
    purchaseLogId?: number | null
    createdBy: number
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactNoteCreateOrConnectWithoutOrderInput = {
    where: ContactNoteWhereUniqueInput
    create: XOR<ContactNoteCreateWithoutOrderInput, ContactNoteUncheckedCreateWithoutOrderInput>
  }

  export type ContactNoteCreateManyOrderInputEnvelope = {
    data: ContactNoteCreateManyOrderInput | ContactNoteCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workerOrders?: OrderUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workerOrders?: OrderUncheckedUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUncheckedUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUpsertWithoutWorkerOrdersInput = {
    update: XOR<UserUpdateWithoutWorkerOrdersInput, UserUncheckedUpdateWithoutWorkerOrdersInput>
    create: XOR<UserCreateWithoutWorkerOrdersInput, UserUncheckedCreateWithoutWorkerOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkerOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkerOrdersInput, UserUncheckedUpdateWithoutWorkerOrdersInput>
  }

  export type UserUpdateWithoutWorkerOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkerOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUncheckedUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type ContactUpsertWithoutWorkerOrdersInput = {
    update: XOR<ContactUpdateWithoutWorkerOrdersInput, ContactUncheckedUpdateWithoutWorkerOrdersInput>
    create: XOR<ContactCreateWithoutWorkerOrdersInput, ContactUncheckedCreateWithoutWorkerOrdersInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutWorkerOrdersInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutWorkerOrdersInput, ContactUncheckedUpdateWithoutWorkerOrdersInput>
  }

  export type ContactUpdateWithoutWorkerOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactNotes?: ContactNoteUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutWorkerOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutContactNestedInput
  }

  export type OrderProductUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderProductWhereUniqueInput
    update: XOR<OrderProductUpdateWithoutOrderInput, OrderProductUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput>
  }

  export type OrderProductUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderProductWhereUniqueInput
    data: XOR<OrderProductUpdateWithoutOrderInput, OrderProductUncheckedUpdateWithoutOrderInput>
  }

  export type OrderProductUpdateManyWithWhereWithoutOrderInput = {
    where: OrderProductScalarWhereInput
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyWithoutOrderInput>
  }

  export type MaterialMovementUpsertWithWhereUniqueWithoutOrderInput = {
    where: MaterialMovementWhereUniqueInput
    update: XOR<MaterialMovementUpdateWithoutOrderInput, MaterialMovementUncheckedUpdateWithoutOrderInput>
    create: XOR<MaterialMovementCreateWithoutOrderInput, MaterialMovementUncheckedCreateWithoutOrderInput>
  }

  export type MaterialMovementUpdateWithWhereUniqueWithoutOrderInput = {
    where: MaterialMovementWhereUniqueInput
    data: XOR<MaterialMovementUpdateWithoutOrderInput, MaterialMovementUncheckedUpdateWithoutOrderInput>
  }

  export type MaterialMovementUpdateManyWithWhereWithoutOrderInput = {
    where: MaterialMovementScalarWhereInput
    data: XOR<MaterialMovementUpdateManyMutationInput, MaterialMovementUncheckedUpdateManyWithoutOrderInput>
  }

  export type ProgressReportUpsertWithWhereUniqueWithoutOrderInput = {
    where: ProgressReportWhereUniqueInput
    update: XOR<ProgressReportUpdateWithoutOrderInput, ProgressReportUncheckedUpdateWithoutOrderInput>
    create: XOR<ProgressReportCreateWithoutOrderInput, ProgressReportUncheckedCreateWithoutOrderInput>
  }

  export type ProgressReportUpdateWithWhereUniqueWithoutOrderInput = {
    where: ProgressReportWhereUniqueInput
    data: XOR<ProgressReportUpdateWithoutOrderInput, ProgressReportUncheckedUpdateWithoutOrderInput>
  }

  export type ProgressReportUpdateManyWithWhereWithoutOrderInput = {
    where: ProgressReportScalarWhereInput
    data: XOR<ProgressReportUpdateManyMutationInput, ProgressReportUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderLinkUpsertWithoutOrderInput = {
    update: XOR<OrderLinkUpdateWithoutOrderInput, OrderLinkUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderLinkCreateWithoutOrderInput, OrderLinkUncheckedCreateWithoutOrderInput>
    where?: OrderLinkWhereInput
  }

  export type OrderLinkUpdateToOneWithWhereWithoutOrderInput = {
    where?: OrderLinkWhereInput
    data: XOR<OrderLinkUpdateWithoutOrderInput, OrderLinkUncheckedUpdateWithoutOrderInput>
  }

  export type OrderLinkUpdateWithoutOrderInput = {
    linkToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrderLinksNestedInput
  }

  export type OrderLinkUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    linkToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentUpsertWithoutOrderInput = {
    update: XOR<ShipmentUpdateWithoutOrderInput, ShipmentUncheckedUpdateWithoutOrderInput>
    create: XOR<ShipmentCreateWithoutOrderInput, ShipmentUncheckedCreateWithoutOrderInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutOrderInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutOrderInput, ShipmentUncheckedUpdateWithoutOrderInput>
  }

  export type ShipmentUpdateWithoutOrderInput = {
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusChangeUpsertWithWhereUniqueWithoutOrderInput = {
    where: StatusChangeWhereUniqueInput
    update: XOR<StatusChangeUpdateWithoutOrderInput, StatusChangeUncheckedUpdateWithoutOrderInput>
    create: XOR<StatusChangeCreateWithoutOrderInput, StatusChangeUncheckedCreateWithoutOrderInput>
  }

  export type StatusChangeUpdateWithWhereUniqueWithoutOrderInput = {
    where: StatusChangeWhereUniqueInput
    data: XOR<StatusChangeUpdateWithoutOrderInput, StatusChangeUncheckedUpdateWithoutOrderInput>
  }

  export type StatusChangeUpdateManyWithWhereWithoutOrderInput = {
    where: StatusChangeScalarWhereInput
    data: XOR<StatusChangeUpdateManyMutationInput, StatusChangeUncheckedUpdateManyWithoutOrderInput>
  }

  export type MaterialPurchaseAlertUpsertWithWhereUniqueWithoutOrderInput = {
    where: MaterialPurchaseAlertWhereUniqueInput
    update: XOR<MaterialPurchaseAlertUpdateWithoutOrderInput, MaterialPurchaseAlertUncheckedUpdateWithoutOrderInput>
    create: XOR<MaterialPurchaseAlertCreateWithoutOrderInput, MaterialPurchaseAlertUncheckedCreateWithoutOrderInput>
  }

  export type MaterialPurchaseAlertUpdateWithWhereUniqueWithoutOrderInput = {
    where: MaterialPurchaseAlertWhereUniqueInput
    data: XOR<MaterialPurchaseAlertUpdateWithoutOrderInput, MaterialPurchaseAlertUncheckedUpdateWithoutOrderInput>
  }

  export type MaterialPurchaseAlertUpdateManyWithWhereWithoutOrderInput = {
    where: MaterialPurchaseAlertScalarWhereInput
    data: XOR<MaterialPurchaseAlertUpdateManyMutationInput, MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderInput>
  }

  export type ContactNoteUpsertWithWhereUniqueWithoutOrderInput = {
    where: ContactNoteWhereUniqueInput
    update: XOR<ContactNoteUpdateWithoutOrderInput, ContactNoteUncheckedUpdateWithoutOrderInput>
    create: XOR<ContactNoteCreateWithoutOrderInput, ContactNoteUncheckedCreateWithoutOrderInput>
  }

  export type ContactNoteUpdateWithWhereUniqueWithoutOrderInput = {
    where: ContactNoteWhereUniqueInput
    data: XOR<ContactNoteUpdateWithoutOrderInput, ContactNoteUncheckedUpdateWithoutOrderInput>
  }

  export type ContactNoteUpdateManyWithWhereWithoutOrderInput = {
    where: ContactNoteScalarWhereInput
    data: XOR<ContactNoteUpdateManyMutationInput, ContactNoteUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutOrderProductsInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    worker?: UserCreateNestedOneWithoutWorkerOrdersInput
    workerContact?: ContactCreateNestedOneWithoutWorkerOrdersInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkCreateNestedOneWithoutOrderInput
    shipment?: ShipmentCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderProductsInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerId?: number | null
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkUncheckedCreateNestedOneWithoutOrderInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderProductsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderProductsInput, OrderUncheckedCreateWithoutOrderProductsInput>
  }

  export type ProductCreateWithoutOrderProductsInput = {
    name: string
    code: string
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseMaterial?: MaterialCreateNestedOneWithoutProductsInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanCreateNestedManyWithoutProductInput
    colours?: ProductColourCreateNestedManyWithoutProductInput
    variations?: ProductVariationCreateNestedManyWithoutProductInput
    photos?: ProductPhotoCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderProductsInput = {
    id?: number
    name: string
    code: string
    materialId?: number | null
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanUncheckedCreateNestedManyWithoutProductInput
    colours?: ProductColourUncheckedCreateNestedManyWithoutProductInput
    variations?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    photos?: ProductPhotoUncheckedCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderProductsInput, ProductUncheckedCreateWithoutOrderProductsInput>
  }

  export type ProgressReportCreateWithoutOrderProductInput = {
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutProgressReportsInput
    product?: ProductCreateNestedOneWithoutIndividualProgressReportsInput
    user: UserCreateNestedOneWithoutProgressReportsInput
    productReports?: ProductProgressReportCreateNestedManyWithoutProgressReportInput
  }

  export type ProgressReportUncheckedCreateWithoutOrderProductInput = {
    id?: number
    orderId?: number | null
    productId?: number | null
    userId: number
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProgressReportInput
  }

  export type ProgressReportCreateOrConnectWithoutOrderProductInput = {
    where: ProgressReportWhereUniqueInput
    create: XOR<ProgressReportCreateWithoutOrderProductInput, ProgressReportUncheckedCreateWithoutOrderProductInput>
  }

  export type ProgressReportCreateManyOrderProductInputEnvelope = {
    data: ProgressReportCreateManyOrderProductInput | ProgressReportCreateManyOrderProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductProgressReportCreateWithoutOrderProductInput = {
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progressReport: ProgressReportCreateNestedOneWithoutProductReportsInput
    product: ProductCreateNestedOneWithoutProductProgressReportsInput
    photos?: ProductProgressPhotoCreateNestedManyWithoutProductProgressReportInput
  }

  export type ProductProgressReportUncheckedCreateWithoutOrderProductInput = {
    id?: number
    progressReportId: number
    productId: number
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ProductProgressPhotoUncheckedCreateNestedManyWithoutProductProgressReportInput
  }

  export type ProductProgressReportCreateOrConnectWithoutOrderProductInput = {
    where: ProductProgressReportWhereUniqueInput
    create: XOR<ProductProgressReportCreateWithoutOrderProductInput, ProductProgressReportUncheckedCreateWithoutOrderProductInput>
  }

  export type ProductProgressReportCreateManyOrderProductInputEnvelope = {
    data: ProductProgressReportCreateManyOrderProductInput | ProductProgressReportCreateManyOrderProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutOrderProductsInput = {
    update: XOR<OrderUpdateWithoutOrderProductsInput, OrderUncheckedUpdateWithoutOrderProductsInput>
    create: XOR<OrderCreateWithoutOrderProductsInput, OrderUncheckedCreateWithoutOrderProductsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderProductsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderProductsInput, OrderUncheckedUpdateWithoutOrderProductsInput>
  }

  export type OrderUpdateWithoutOrderProductsInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    worker?: UserUpdateOneWithoutWorkerOrdersNestedInput
    workerContact?: ContactUpdateOneWithoutWorkerOrdersNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUncheckedUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderProductsInput = {
    update: XOR<ProductUpdateWithoutOrderProductsInput, ProductUncheckedUpdateWithoutOrderProductsInput>
    create: XOR<ProductCreateWithoutOrderProductsInput, ProductUncheckedCreateWithoutOrderProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderProductsInput, ProductUncheckedUpdateWithoutOrderProductsInput>
  }

  export type ProductUpdateWithoutOrderProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseMaterial?: MaterialUpdateOneWithoutProductsNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUpdateManyWithoutProductNestedInput
    colours?: ProductColourUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUncheckedUpdateManyWithoutProductNestedInput
    colours?: ProductColourUncheckedUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUncheckedUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProgressReportUpsertWithWhereUniqueWithoutOrderProductInput = {
    where: ProgressReportWhereUniqueInput
    update: XOR<ProgressReportUpdateWithoutOrderProductInput, ProgressReportUncheckedUpdateWithoutOrderProductInput>
    create: XOR<ProgressReportCreateWithoutOrderProductInput, ProgressReportUncheckedCreateWithoutOrderProductInput>
  }

  export type ProgressReportUpdateWithWhereUniqueWithoutOrderProductInput = {
    where: ProgressReportWhereUniqueInput
    data: XOR<ProgressReportUpdateWithoutOrderProductInput, ProgressReportUncheckedUpdateWithoutOrderProductInput>
  }

  export type ProgressReportUpdateManyWithWhereWithoutOrderProductInput = {
    where: ProgressReportScalarWhereInput
    data: XOR<ProgressReportUpdateManyMutationInput, ProgressReportUncheckedUpdateManyWithoutOrderProductInput>
  }

  export type ProductProgressReportUpsertWithWhereUniqueWithoutOrderProductInput = {
    where: ProductProgressReportWhereUniqueInput
    update: XOR<ProductProgressReportUpdateWithoutOrderProductInput, ProductProgressReportUncheckedUpdateWithoutOrderProductInput>
    create: XOR<ProductProgressReportCreateWithoutOrderProductInput, ProductProgressReportUncheckedCreateWithoutOrderProductInput>
  }

  export type ProductProgressReportUpdateWithWhereUniqueWithoutOrderProductInput = {
    where: ProductProgressReportWhereUniqueInput
    data: XOR<ProductProgressReportUpdateWithoutOrderProductInput, ProductProgressReportUncheckedUpdateWithoutOrderProductInput>
  }

  export type ProductProgressReportUpdateManyWithWhereWithoutOrderProductInput = {
    where: ProductProgressReportScalarWhereInput
    data: XOR<ProductProgressReportUpdateManyMutationInput, ProductProgressReportUncheckedUpdateManyWithoutOrderProductInput>
  }

  export type MaterialCreateWithoutMaterialMovementsInput = {
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productMaterials?: ProductMaterialCreateNestedManyWithoutMaterialInput
    remainingMaterials?: RemainingMaterialCreateNestedManyWithoutMaterialInput
    products?: ProductCreateNestedManyWithoutBaseMaterialInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutMaterialInput
    purchaseLogs?: PurchaseLogCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutMaterialMovementsInput = {
    id?: number
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutMaterialInput
    remainingMaterials?: RemainingMaterialUncheckedCreateNestedManyWithoutMaterialInput
    products?: ProductUncheckedCreateNestedManyWithoutBaseMaterialInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutMaterialInput
    purchaseLogs?: PurchaseLogUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutMaterialMovementsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutMaterialMovementsInput, MaterialUncheckedCreateWithoutMaterialMovementsInput>
  }

  export type OrderCreateWithoutMaterialMovementsInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    worker?: UserCreateNestedOneWithoutWorkerOrdersInput
    workerContact?: ContactCreateNestedOneWithoutWorkerOrdersInput
    orderProducts?: OrderProductCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkCreateNestedOneWithoutOrderInput
    shipment?: ShipmentCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutMaterialMovementsInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerId?: number | null
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkUncheckedCreateNestedOneWithoutOrderInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutMaterialMovementsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutMaterialMovementsInput, OrderUncheckedCreateWithoutMaterialMovementsInput>
  }

  export type UserCreateWithoutMaterialMovementsInput = {
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    workerOrders?: OrderCreateNestedManyWithoutWorkerInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutMaterialMovementsInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerOrders?: OrderUncheckedCreateNestedManyWithoutWorkerInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkUncheckedCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutMaterialMovementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMaterialMovementsInput, UserUncheckedCreateWithoutMaterialMovementsInput>
  }

  export type PurchaseLogCreateWithoutMovementInput = {
    supplier: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    pricePerUnit?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    invoiceNumber?: string | null
    receiptPath?: string | null
    notes?: string | null
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    receivedQuantity?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutPurchaseLogsInput
    contactNotes?: ContactNoteCreateNestedManyWithoutPurchaseLogInput
  }

  export type PurchaseLogUncheckedCreateWithoutMovementInput = {
    id?: number
    materialId: number
    supplier: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    pricePerUnit?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    invoiceNumber?: string | null
    receiptPath?: string | null
    notes?: string | null
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    receivedQuantity?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutPurchaseLogInput
  }

  export type PurchaseLogCreateOrConnectWithoutMovementInput = {
    where: PurchaseLogWhereUniqueInput
    create: XOR<PurchaseLogCreateWithoutMovementInput, PurchaseLogUncheckedCreateWithoutMovementInput>
  }

  export type MaterialUpsertWithoutMaterialMovementsInput = {
    update: XOR<MaterialUpdateWithoutMaterialMovementsInput, MaterialUncheckedUpdateWithoutMaterialMovementsInput>
    create: XOR<MaterialCreateWithoutMaterialMovementsInput, MaterialUncheckedCreateWithoutMaterialMovementsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutMaterialMovementsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutMaterialMovementsInput, MaterialUncheckedUpdateWithoutMaterialMovementsInput>
  }

  export type MaterialUpdateWithoutMaterialMovementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productMaterials?: ProductMaterialUpdateManyWithoutMaterialNestedInput
    remainingMaterials?: RemainingMaterialUpdateManyWithoutMaterialNestedInput
    products?: ProductUpdateManyWithoutBaseMaterialNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutMaterialNestedInput
    purchaseLogs?: PurchaseLogUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutMaterialMovementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutMaterialNestedInput
    remainingMaterials?: RemainingMaterialUncheckedUpdateManyWithoutMaterialNestedInput
    products?: ProductUncheckedUpdateManyWithoutBaseMaterialNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutMaterialNestedInput
    purchaseLogs?: PurchaseLogUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type OrderUpsertWithoutMaterialMovementsInput = {
    update: XOR<OrderUpdateWithoutMaterialMovementsInput, OrderUncheckedUpdateWithoutMaterialMovementsInput>
    create: XOR<OrderCreateWithoutMaterialMovementsInput, OrderUncheckedCreateWithoutMaterialMovementsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutMaterialMovementsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutMaterialMovementsInput, OrderUncheckedUpdateWithoutMaterialMovementsInput>
  }

  export type OrderUpdateWithoutMaterialMovementsInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    worker?: UserUpdateOneWithoutWorkerOrdersNestedInput
    workerContact?: ContactUpdateOneWithoutWorkerOrdersNestedInput
    orderProducts?: OrderProductUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutMaterialMovementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUncheckedUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserUpsertWithoutMaterialMovementsInput = {
    update: XOR<UserUpdateWithoutMaterialMovementsInput, UserUncheckedUpdateWithoutMaterialMovementsInput>
    create: XOR<UserCreateWithoutMaterialMovementsInput, UserUncheckedCreateWithoutMaterialMovementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMaterialMovementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMaterialMovementsInput, UserUncheckedUpdateWithoutMaterialMovementsInput>
  }

  export type UserUpdateWithoutMaterialMovementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUpdateManyWithoutWorkerNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMaterialMovementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUncheckedUpdateManyWithoutWorkerNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUncheckedUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type PurchaseLogUpsertWithoutMovementInput = {
    update: XOR<PurchaseLogUpdateWithoutMovementInput, PurchaseLogUncheckedUpdateWithoutMovementInput>
    create: XOR<PurchaseLogCreateWithoutMovementInput, PurchaseLogUncheckedCreateWithoutMovementInput>
    where?: PurchaseLogWhereInput
  }

  export type PurchaseLogUpdateToOneWithWhereWithoutMovementInput = {
    where?: PurchaseLogWhereInput
    data: XOR<PurchaseLogUpdateWithoutMovementInput, PurchaseLogUncheckedUpdateWithoutMovementInput>
  }

  export type PurchaseLogUpdateWithoutMovementInput = {
    supplier?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    pricePerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedQuantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutPurchaseLogsNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutPurchaseLogNestedInput
  }

  export type PurchaseLogUncheckedUpdateWithoutMovementInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    supplier?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    pricePerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedQuantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutPurchaseLogNestedInput
  }

  export type OrderCreateWithoutProgressReportsInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    worker?: UserCreateNestedOneWithoutWorkerOrdersInput
    workerContact?: ContactCreateNestedOneWithoutWorkerOrdersInput
    orderProducts?: OrderProductCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkCreateNestedOneWithoutOrderInput
    shipment?: ShipmentCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutProgressReportsInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerId?: number | null
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkUncheckedCreateNestedOneWithoutOrderInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutProgressReportsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProgressReportsInput, OrderUncheckedCreateWithoutProgressReportsInput>
  }

  export type OrderProductCreateWithoutIndividualProgressReportsInput = {
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderProductsInput
    product: ProductCreateNestedOneWithoutOrderProductsInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutOrderProductInput
  }

  export type OrderProductUncheckedCreateWithoutIndividualProgressReportsInput = {
    id?: number
    orderId: number
    productId: number
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutOrderProductInput
  }

  export type OrderProductCreateOrConnectWithoutIndividualProgressReportsInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutIndividualProgressReportsInput, OrderProductUncheckedCreateWithoutIndividualProgressReportsInput>
  }

  export type ProductCreateWithoutIndividualProgressReportsInput = {
    name: string
    code: string
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseMaterial?: MaterialCreateNestedOneWithoutProductsInput
    orderProducts?: OrderProductCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanCreateNestedManyWithoutProductInput
    colours?: ProductColourCreateNestedManyWithoutProductInput
    variations?: ProductVariationCreateNestedManyWithoutProductInput
    photos?: ProductPhotoCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutIndividualProgressReportsInput = {
    id?: number
    name: string
    code: string
    materialId?: number | null
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanUncheckedCreateNestedManyWithoutProductInput
    colours?: ProductColourUncheckedCreateNestedManyWithoutProductInput
    variations?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    photos?: ProductPhotoUncheckedCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutIndividualProgressReportsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutIndividualProgressReportsInput, ProductUncheckedCreateWithoutIndividualProgressReportsInput>
  }

  export type UserCreateWithoutProgressReportsInput = {
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    workerOrders?: OrderCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutProgressReportsInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerOrders?: OrderUncheckedCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkUncheckedCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutProgressReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProgressReportsInput, UserUncheckedCreateWithoutProgressReportsInput>
  }

  export type ProductProgressReportCreateWithoutProgressReportInput = {
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductProgressReportsInput
    orderProduct?: OrderProductCreateNestedOneWithoutProductProgressReportsInput
    photos?: ProductProgressPhotoCreateNestedManyWithoutProductProgressReportInput
  }

  export type ProductProgressReportUncheckedCreateWithoutProgressReportInput = {
    id?: number
    productId: number
    orderProductId?: number | null
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ProductProgressPhotoUncheckedCreateNestedManyWithoutProductProgressReportInput
  }

  export type ProductProgressReportCreateOrConnectWithoutProgressReportInput = {
    where: ProductProgressReportWhereUniqueInput
    create: XOR<ProductProgressReportCreateWithoutProgressReportInput, ProductProgressReportUncheckedCreateWithoutProgressReportInput>
  }

  export type ProductProgressReportCreateManyProgressReportInputEnvelope = {
    data: ProductProgressReportCreateManyProgressReportInput | ProductProgressReportCreateManyProgressReportInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutProgressReportsInput = {
    update: XOR<OrderUpdateWithoutProgressReportsInput, OrderUncheckedUpdateWithoutProgressReportsInput>
    create: XOR<OrderCreateWithoutProgressReportsInput, OrderUncheckedCreateWithoutProgressReportsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutProgressReportsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutProgressReportsInput, OrderUncheckedUpdateWithoutProgressReportsInput>
  }

  export type OrderUpdateWithoutProgressReportsInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    worker?: UserUpdateOneWithoutWorkerOrdersNestedInput
    workerContact?: ContactUpdateOneWithoutWorkerOrdersNestedInput
    orderProducts?: OrderProductUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutProgressReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUncheckedUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderProductUpsertWithoutIndividualProgressReportsInput = {
    update: XOR<OrderProductUpdateWithoutIndividualProgressReportsInput, OrderProductUncheckedUpdateWithoutIndividualProgressReportsInput>
    create: XOR<OrderProductCreateWithoutIndividualProgressReportsInput, OrderProductUncheckedCreateWithoutIndividualProgressReportsInput>
    where?: OrderProductWhereInput
  }

  export type OrderProductUpdateToOneWithWhereWithoutIndividualProgressReportsInput = {
    where?: OrderProductWhereInput
    data: XOR<OrderProductUpdateWithoutIndividualProgressReportsInput, OrderProductUncheckedUpdateWithoutIndividualProgressReportsInput>
  }

  export type OrderProductUpdateWithoutIndividualProgressReportsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderProductsNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutOrderProductNestedInput
  }

  export type OrderProductUncheckedUpdateWithoutIndividualProgressReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutOrderProductNestedInput
  }

  export type ProductUpsertWithoutIndividualProgressReportsInput = {
    update: XOR<ProductUpdateWithoutIndividualProgressReportsInput, ProductUncheckedUpdateWithoutIndividualProgressReportsInput>
    create: XOR<ProductCreateWithoutIndividualProgressReportsInput, ProductUncheckedCreateWithoutIndividualProgressReportsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutIndividualProgressReportsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutIndividualProgressReportsInput, ProductUncheckedUpdateWithoutIndividualProgressReportsInput>
  }

  export type ProductUpdateWithoutIndividualProgressReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseMaterial?: MaterialUpdateOneWithoutProductsNestedInput
    orderProducts?: OrderProductUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUpdateManyWithoutProductNestedInput
    colours?: ProductColourUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutIndividualProgressReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUncheckedUpdateManyWithoutProductNestedInput
    colours?: ProductColourUncheckedUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUncheckedUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutProgressReportsInput = {
    update: XOR<UserUpdateWithoutProgressReportsInput, UserUncheckedUpdateWithoutProgressReportsInput>
    create: XOR<UserCreateWithoutProgressReportsInput, UserUncheckedCreateWithoutProgressReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProgressReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProgressReportsInput, UserUncheckedUpdateWithoutProgressReportsInput>
  }

  export type UserUpdateWithoutProgressReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProgressReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUncheckedUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUncheckedUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type ProductProgressReportUpsertWithWhereUniqueWithoutProgressReportInput = {
    where: ProductProgressReportWhereUniqueInput
    update: XOR<ProductProgressReportUpdateWithoutProgressReportInput, ProductProgressReportUncheckedUpdateWithoutProgressReportInput>
    create: XOR<ProductProgressReportCreateWithoutProgressReportInput, ProductProgressReportUncheckedCreateWithoutProgressReportInput>
  }

  export type ProductProgressReportUpdateWithWhereUniqueWithoutProgressReportInput = {
    where: ProductProgressReportWhereUniqueInput
    data: XOR<ProductProgressReportUpdateWithoutProgressReportInput, ProductProgressReportUncheckedUpdateWithoutProgressReportInput>
  }

  export type ProductProgressReportUpdateManyWithWhereWithoutProgressReportInput = {
    where: ProductProgressReportScalarWhereInput
    data: XOR<ProductProgressReportUpdateManyMutationInput, ProductProgressReportUncheckedUpdateManyWithoutProgressReportInput>
  }

  export type ProgressReportCreateWithoutProductReportsInput = {
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutProgressReportsInput
    orderProduct?: OrderProductCreateNestedOneWithoutIndividualProgressReportsInput
    product?: ProductCreateNestedOneWithoutIndividualProgressReportsInput
    user: UserCreateNestedOneWithoutProgressReportsInput
  }

  export type ProgressReportUncheckedCreateWithoutProductReportsInput = {
    id?: number
    orderId?: number | null
    orderProductId?: number | null
    productId?: number | null
    userId: number
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgressReportCreateOrConnectWithoutProductReportsInput = {
    where: ProgressReportWhereUniqueInput
    create: XOR<ProgressReportCreateWithoutProductReportsInput, ProgressReportUncheckedCreateWithoutProductReportsInput>
  }

  export type ProductCreateWithoutProductProgressReportsInput = {
    name: string
    code: string
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseMaterial?: MaterialCreateNestedOneWithoutProductsInput
    orderProducts?: OrderProductCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanCreateNestedManyWithoutProductInput
    colours?: ProductColourCreateNestedManyWithoutProductInput
    variations?: ProductVariationCreateNestedManyWithoutProductInput
    photos?: ProductPhotoCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductProgressReportsInput = {
    id?: number
    name: string
    code: string
    materialId?: number | null
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanUncheckedCreateNestedManyWithoutProductInput
    colours?: ProductColourUncheckedCreateNestedManyWithoutProductInput
    variations?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    photos?: ProductPhotoUncheckedCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductProgressReportsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductProgressReportsInput, ProductUncheckedCreateWithoutProductProgressReportsInput>
  }

  export type OrderProductCreateWithoutProductProgressReportsInput = {
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderProductsInput
    product: ProductCreateNestedOneWithoutOrderProductsInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutOrderProductInput
  }

  export type OrderProductUncheckedCreateWithoutProductProgressReportsInput = {
    id?: number
    orderId: number
    productId: number
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderProductInput
  }

  export type OrderProductCreateOrConnectWithoutProductProgressReportsInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutProductProgressReportsInput, OrderProductUncheckedCreateWithoutProductProgressReportsInput>
  }

  export type ProductProgressPhotoCreateWithoutProductProgressReportInput = {
    photoPath: string
    thumbnailPath?: string | null
    description?: string | null
    uploadDate?: Date | string
    fileSize?: number | null
    mimeType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProgressPhotoUncheckedCreateWithoutProductProgressReportInput = {
    id?: number
    photoPath: string
    thumbnailPath?: string | null
    description?: string | null
    uploadDate?: Date | string
    fileSize?: number | null
    mimeType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProgressPhotoCreateOrConnectWithoutProductProgressReportInput = {
    where: ProductProgressPhotoWhereUniqueInput
    create: XOR<ProductProgressPhotoCreateWithoutProductProgressReportInput, ProductProgressPhotoUncheckedCreateWithoutProductProgressReportInput>
  }

  export type ProductProgressPhotoCreateManyProductProgressReportInputEnvelope = {
    data: ProductProgressPhotoCreateManyProductProgressReportInput | ProductProgressPhotoCreateManyProductProgressReportInput[]
    skipDuplicates?: boolean
  }

  export type ProgressReportUpsertWithoutProductReportsInput = {
    update: XOR<ProgressReportUpdateWithoutProductReportsInput, ProgressReportUncheckedUpdateWithoutProductReportsInput>
    create: XOR<ProgressReportCreateWithoutProductReportsInput, ProgressReportUncheckedCreateWithoutProductReportsInput>
    where?: ProgressReportWhereInput
  }

  export type ProgressReportUpdateToOneWithWhereWithoutProductReportsInput = {
    where?: ProgressReportWhereInput
    data: XOR<ProgressReportUpdateWithoutProductReportsInput, ProgressReportUncheckedUpdateWithoutProductReportsInput>
  }

  export type ProgressReportUpdateWithoutProductReportsInput = {
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutProgressReportsNestedInput
    orderProduct?: OrderProductUpdateOneWithoutIndividualProgressReportsNestedInput
    product?: ProductUpdateOneWithoutIndividualProgressReportsNestedInput
    user?: UserUpdateOneRequiredWithoutProgressReportsNestedInput
  }

  export type ProgressReportUncheckedUpdateWithoutProductReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutProductProgressReportsInput = {
    update: XOR<ProductUpdateWithoutProductProgressReportsInput, ProductUncheckedUpdateWithoutProductProgressReportsInput>
    create: XOR<ProductCreateWithoutProductProgressReportsInput, ProductUncheckedCreateWithoutProductProgressReportsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductProgressReportsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductProgressReportsInput, ProductUncheckedUpdateWithoutProductProgressReportsInput>
  }

  export type ProductUpdateWithoutProductProgressReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseMaterial?: MaterialUpdateOneWithoutProductsNestedInput
    orderProducts?: OrderProductUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUpdateManyWithoutProductNestedInput
    colours?: ProductColourUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductProgressReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUncheckedUpdateManyWithoutProductNestedInput
    colours?: ProductColourUncheckedUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUncheckedUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderProductUpsertWithoutProductProgressReportsInput = {
    update: XOR<OrderProductUpdateWithoutProductProgressReportsInput, OrderProductUncheckedUpdateWithoutProductProgressReportsInput>
    create: XOR<OrderProductCreateWithoutProductProgressReportsInput, OrderProductUncheckedCreateWithoutProductProgressReportsInput>
    where?: OrderProductWhereInput
  }

  export type OrderProductUpdateToOneWithWhereWithoutProductProgressReportsInput = {
    where?: OrderProductWhereInput
    data: XOR<OrderProductUpdateWithoutProductProgressReportsInput, OrderProductUncheckedUpdateWithoutProductProgressReportsInput>
  }

  export type OrderProductUpdateWithoutProductProgressReportsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderProductsNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutOrderProductNestedInput
  }

  export type OrderProductUncheckedUpdateWithoutProductProgressReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutOrderProductNestedInput
  }

  export type ProductProgressPhotoUpsertWithWhereUniqueWithoutProductProgressReportInput = {
    where: ProductProgressPhotoWhereUniqueInput
    update: XOR<ProductProgressPhotoUpdateWithoutProductProgressReportInput, ProductProgressPhotoUncheckedUpdateWithoutProductProgressReportInput>
    create: XOR<ProductProgressPhotoCreateWithoutProductProgressReportInput, ProductProgressPhotoUncheckedCreateWithoutProductProgressReportInput>
  }

  export type ProductProgressPhotoUpdateWithWhereUniqueWithoutProductProgressReportInput = {
    where: ProductProgressPhotoWhereUniqueInput
    data: XOR<ProductProgressPhotoUpdateWithoutProductProgressReportInput, ProductProgressPhotoUncheckedUpdateWithoutProductProgressReportInput>
  }

  export type ProductProgressPhotoUpdateManyWithWhereWithoutProductProgressReportInput = {
    where: ProductProgressPhotoScalarWhereInput
    data: XOR<ProductProgressPhotoUpdateManyMutationInput, ProductProgressPhotoUncheckedUpdateManyWithoutProductProgressReportInput>
  }

  export type ProductProgressPhotoScalarWhereInput = {
    AND?: ProductProgressPhotoScalarWhereInput | ProductProgressPhotoScalarWhereInput[]
    OR?: ProductProgressPhotoScalarWhereInput[]
    NOT?: ProductProgressPhotoScalarWhereInput | ProductProgressPhotoScalarWhereInput[]
    id?: IntFilter<"ProductProgressPhoto"> | number
    productProgressReportId?: IntFilter<"ProductProgressPhoto"> | number
    photoPath?: StringFilter<"ProductProgressPhoto"> | string
    thumbnailPath?: StringNullableFilter<"ProductProgressPhoto"> | string | null
    description?: StringNullableFilter<"ProductProgressPhoto"> | string | null
    uploadDate?: DateTimeFilter<"ProductProgressPhoto"> | Date | string
    fileSize?: IntNullableFilter<"ProductProgressPhoto"> | number | null
    mimeType?: StringNullableFilter<"ProductProgressPhoto"> | string | null
    isActive?: BoolFilter<"ProductProgressPhoto"> | boolean
    createdAt?: DateTimeFilter<"ProductProgressPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ProductProgressPhoto"> | Date | string
  }

  export type ProductProgressReportCreateWithoutPhotosInput = {
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progressReport: ProgressReportCreateNestedOneWithoutProductReportsInput
    product: ProductCreateNestedOneWithoutProductProgressReportsInput
    orderProduct?: OrderProductCreateNestedOneWithoutProductProgressReportsInput
  }

  export type ProductProgressReportUncheckedCreateWithoutPhotosInput = {
    id?: number
    progressReportId: number
    productId: number
    orderProductId?: number | null
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProgressReportCreateOrConnectWithoutPhotosInput = {
    where: ProductProgressReportWhereUniqueInput
    create: XOR<ProductProgressReportCreateWithoutPhotosInput, ProductProgressReportUncheckedCreateWithoutPhotosInput>
  }

  export type ProductProgressReportUpsertWithoutPhotosInput = {
    update: XOR<ProductProgressReportUpdateWithoutPhotosInput, ProductProgressReportUncheckedUpdateWithoutPhotosInput>
    create: XOR<ProductProgressReportCreateWithoutPhotosInput, ProductProgressReportUncheckedCreateWithoutPhotosInput>
    where?: ProductProgressReportWhereInput
  }

  export type ProductProgressReportUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ProductProgressReportWhereInput
    data: XOR<ProductProgressReportUpdateWithoutPhotosInput, ProductProgressReportUncheckedUpdateWithoutPhotosInput>
  }

  export type ProductProgressReportUpdateWithoutPhotosInput = {
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressReport?: ProgressReportUpdateOneRequiredWithoutProductReportsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductProgressReportsNestedInput
    orderProduct?: OrderProductUpdateOneWithoutProductProgressReportsNestedInput
  }

  export type ProductProgressReportUncheckedUpdateWithoutPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    progressReportId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateWithoutRemainingMaterialsInput = {
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementCreateNestedManyWithoutMaterialInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutMaterialInput
    products?: ProductCreateNestedManyWithoutBaseMaterialInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutMaterialInput
    purchaseLogs?: PurchaseLogCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutRemainingMaterialsInput = {
    id?: number
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutMaterialInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutMaterialInput
    products?: ProductUncheckedCreateNestedManyWithoutBaseMaterialInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutMaterialInput
    purchaseLogs?: PurchaseLogUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutRemainingMaterialsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutRemainingMaterialsInput, MaterialUncheckedCreateWithoutRemainingMaterialsInput>
  }

  export type MaterialUpsertWithoutRemainingMaterialsInput = {
    update: XOR<MaterialUpdateWithoutRemainingMaterialsInput, MaterialUncheckedUpdateWithoutRemainingMaterialsInput>
    create: XOR<MaterialCreateWithoutRemainingMaterialsInput, MaterialUncheckedCreateWithoutRemainingMaterialsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutRemainingMaterialsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutRemainingMaterialsInput, MaterialUncheckedUpdateWithoutRemainingMaterialsInput>
  }

  export type MaterialUpdateWithoutRemainingMaterialsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUpdateManyWithoutMaterialNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutMaterialNestedInput
    products?: ProductUpdateManyWithoutBaseMaterialNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutMaterialNestedInput
    purchaseLogs?: PurchaseLogUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutRemainingMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutMaterialNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutMaterialNestedInput
    products?: ProductUncheckedUpdateManyWithoutBaseMaterialNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutMaterialNestedInput
    purchaseLogs?: PurchaseLogUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type OrderCreateWithoutOrderLinkInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    worker?: UserCreateNestedOneWithoutWorkerOrdersInput
    workerContact?: ContactCreateNestedOneWithoutWorkerOrdersInput
    orderProducts?: OrderProductCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportCreateNestedManyWithoutOrderInput
    shipment?: ShipmentCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderLinkInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerId?: number | null
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderLinkInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderLinkInput, OrderUncheckedCreateWithoutOrderLinkInput>
  }

  export type UserCreateWithoutOrderLinksInput = {
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    workerOrders?: OrderCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutOrderLinksInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerOrders?: OrderUncheckedCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutOrderLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderLinksInput, UserUncheckedCreateWithoutOrderLinksInput>
  }

  export type OrderUpsertWithoutOrderLinkInput = {
    update: XOR<OrderUpdateWithoutOrderLinkInput, OrderUncheckedUpdateWithoutOrderLinkInput>
    create: XOR<OrderCreateWithoutOrderLinkInput, OrderUncheckedCreateWithoutOrderLinkInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderLinkInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderLinkInput, OrderUncheckedUpdateWithoutOrderLinkInput>
  }

  export type OrderUpdateWithoutOrderLinkInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    worker?: UserUpdateOneWithoutWorkerOrdersNestedInput
    workerContact?: ContactUpdateOneWithoutWorkerOrdersNestedInput
    orderProducts?: OrderProductUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUpdateManyWithoutOrderNestedInput
    shipment?: ShipmentUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderLinkInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutOrderNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserUpsertWithoutOrderLinksInput = {
    update: XOR<UserUpdateWithoutOrderLinksInput, UserUncheckedUpdateWithoutOrderLinksInput>
    create: XOR<UserCreateWithoutOrderLinksInput, UserUncheckedCreateWithoutOrderLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrderLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrderLinksInput, UserUncheckedUpdateWithoutOrderLinksInput>
  }

  export type UserUpdateWithoutOrderLinksInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrderLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUncheckedUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type ProductCreateWithoutProductMaterialsInput = {
    name: string
    code: string
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseMaterial?: MaterialCreateNestedOneWithoutProductsInput
    orderProducts?: OrderProductCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanCreateNestedManyWithoutProductInput
    colours?: ProductColourCreateNestedManyWithoutProductInput
    variations?: ProductVariationCreateNestedManyWithoutProductInput
    photos?: ProductPhotoCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductMaterialsInput = {
    id?: number
    name: string
    code: string
    materialId?: number | null
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanUncheckedCreateNestedManyWithoutProductInput
    colours?: ProductColourUncheckedCreateNestedManyWithoutProductInput
    variations?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    photos?: ProductPhotoUncheckedCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductMaterialsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductMaterialsInput, ProductUncheckedCreateWithoutProductMaterialsInput>
  }

  export type MaterialCreateWithoutProductMaterialsInput = {
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementCreateNestedManyWithoutMaterialInput
    remainingMaterials?: RemainingMaterialCreateNestedManyWithoutMaterialInput
    products?: ProductCreateNestedManyWithoutBaseMaterialInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutMaterialInput
    purchaseLogs?: PurchaseLogCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutProductMaterialsInput = {
    id?: number
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutMaterialInput
    remainingMaterials?: RemainingMaterialUncheckedCreateNestedManyWithoutMaterialInput
    products?: ProductUncheckedCreateNestedManyWithoutBaseMaterialInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutMaterialInput
    purchaseLogs?: PurchaseLogUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutProductMaterialsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutProductMaterialsInput, MaterialUncheckedCreateWithoutProductMaterialsInput>
  }

  export type ProductUpsertWithoutProductMaterialsInput = {
    update: XOR<ProductUpdateWithoutProductMaterialsInput, ProductUncheckedUpdateWithoutProductMaterialsInput>
    create: XOR<ProductCreateWithoutProductMaterialsInput, ProductUncheckedCreateWithoutProductMaterialsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductMaterialsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductMaterialsInput, ProductUncheckedUpdateWithoutProductMaterialsInput>
  }

  export type ProductUpdateWithoutProductMaterialsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseMaterial?: MaterialUpdateOneWithoutProductsNestedInput
    orderProducts?: OrderProductUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUpdateManyWithoutProductNestedInput
    colours?: ProductColourUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUncheckedUpdateManyWithoutProductNestedInput
    colours?: ProductColourUncheckedUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUncheckedUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutProductNestedInput
  }

  export type MaterialUpsertWithoutProductMaterialsInput = {
    update: XOR<MaterialUpdateWithoutProductMaterialsInput, MaterialUncheckedUpdateWithoutProductMaterialsInput>
    create: XOR<MaterialCreateWithoutProductMaterialsInput, MaterialUncheckedCreateWithoutProductMaterialsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutProductMaterialsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutProductMaterialsInput, MaterialUncheckedUpdateWithoutProductMaterialsInput>
  }

  export type MaterialUpdateWithoutProductMaterialsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUpdateManyWithoutMaterialNestedInput
    remainingMaterials?: RemainingMaterialUpdateManyWithoutMaterialNestedInput
    products?: ProductUpdateManyWithoutBaseMaterialNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutMaterialNestedInput
    purchaseLogs?: PurchaseLogUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutProductMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutMaterialNestedInput
    remainingMaterials?: RemainingMaterialUncheckedUpdateManyWithoutMaterialNestedInput
    products?: ProductUncheckedUpdateManyWithoutBaseMaterialNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutMaterialNestedInput
    purchaseLogs?: PurchaseLogUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type OrderCreateWithoutShipmentInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    worker?: UserCreateNestedOneWithoutWorkerOrdersInput
    workerContact?: ContactCreateNestedOneWithoutWorkerOrdersInput
    orderProducts?: OrderProductCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutShipmentInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerId?: number | null
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkUncheckedCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutShipmentInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutShipmentInput, OrderUncheckedCreateWithoutShipmentInput>
  }

  export type OrderUpsertWithoutShipmentInput = {
    update: XOR<OrderUpdateWithoutShipmentInput, OrderUncheckedUpdateWithoutShipmentInput>
    create: XOR<OrderCreateWithoutShipmentInput, OrderUncheckedCreateWithoutShipmentInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutShipmentInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutShipmentInput, OrderUncheckedUpdateWithoutShipmentInput>
  }

  export type OrderUpdateWithoutShipmentInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    worker?: UserUpdateOneWithoutWorkerOrdersNestedInput
    workerContact?: ContactUpdateOneWithoutWorkerOrdersNestedInput
    orderProducts?: OrderProductUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUncheckedUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductCreateWithoutRecurringPlansInput = {
    name: string
    code: string
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseMaterial?: MaterialCreateNestedOneWithoutProductsInput
    orderProducts?: OrderProductCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutProductInput
    colours?: ProductColourCreateNestedManyWithoutProductInput
    variations?: ProductVariationCreateNestedManyWithoutProductInput
    photos?: ProductPhotoCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutRecurringPlansInput = {
    id?: number
    name: string
    code: string
    materialId?: number | null
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutProductInput
    colours?: ProductColourUncheckedCreateNestedManyWithoutProductInput
    variations?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    photos?: ProductPhotoUncheckedCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRecurringPlansInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRecurringPlansInput, ProductUncheckedCreateWithoutRecurringPlansInput>
  }

  export type ProductUpsertWithoutRecurringPlansInput = {
    update: XOR<ProductUpdateWithoutRecurringPlansInput, ProductUncheckedUpdateWithoutRecurringPlansInput>
    create: XOR<ProductCreateWithoutRecurringPlansInput, ProductUncheckedCreateWithoutRecurringPlansInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRecurringPlansInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRecurringPlansInput, ProductUncheckedUpdateWithoutRecurringPlansInput>
  }

  export type ProductUpdateWithoutRecurringPlansInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseMaterial?: MaterialUpdateOneWithoutProductsNestedInput
    orderProducts?: OrderProductUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutProductNestedInput
    colours?: ProductColourUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutRecurringPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutProductNestedInput
    colours?: ProductColourUncheckedUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUncheckedUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutStatusChangesInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    worker?: UserCreateNestedOneWithoutWorkerOrdersInput
    workerContact?: ContactCreateNestedOneWithoutWorkerOrdersInput
    orderProducts?: OrderProductCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkCreateNestedOneWithoutOrderInput
    shipment?: ShipmentCreateNestedOneWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutStatusChangesInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerId?: number | null
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkUncheckedCreateNestedOneWithoutOrderInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutStatusChangesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStatusChangesInput, OrderUncheckedCreateWithoutStatusChangesInput>
  }

  export type UserCreateWithoutStatusChangesInput = {
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    workerOrders?: OrderCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutStatusChangesInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerOrders?: OrderUncheckedCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkUncheckedCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutStatusChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStatusChangesInput, UserUncheckedCreateWithoutStatusChangesInput>
  }

  export type OrderUpsertWithoutStatusChangesInput = {
    update: XOR<OrderUpdateWithoutStatusChangesInput, OrderUncheckedUpdateWithoutStatusChangesInput>
    create: XOR<OrderCreateWithoutStatusChangesInput, OrderUncheckedCreateWithoutStatusChangesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutStatusChangesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutStatusChangesInput, OrderUncheckedUpdateWithoutStatusChangesInput>
  }

  export type OrderUpdateWithoutStatusChangesInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    worker?: UserUpdateOneWithoutWorkerOrdersNestedInput
    workerContact?: ContactUpdateOneWithoutWorkerOrdersNestedInput
    orderProducts?: OrderProductUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUpdateOneWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutStatusChangesInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUncheckedUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserUpsertWithoutStatusChangesInput = {
    update: XOR<UserUpdateWithoutStatusChangesInput, UserUncheckedUpdateWithoutStatusChangesInput>
    create: XOR<UserCreateWithoutStatusChangesInput, UserUncheckedCreateWithoutStatusChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStatusChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStatusChangesInput, UserUncheckedUpdateWithoutStatusChangesInput>
  }

  export type UserUpdateWithoutStatusChangesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStatusChangesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUncheckedUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUncheckedUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type ProductCreateWithoutColoursInput = {
    name: string
    code: string
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseMaterial?: MaterialCreateNestedOneWithoutProductsInput
    orderProducts?: OrderProductCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanCreateNestedManyWithoutProductInput
    variations?: ProductVariationCreateNestedManyWithoutProductInput
    photos?: ProductPhotoCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutColoursInput = {
    id?: number
    name: string
    code: string
    materialId?: number | null
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanUncheckedCreateNestedManyWithoutProductInput
    variations?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    photos?: ProductPhotoUncheckedCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutColoursInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutColoursInput, ProductUncheckedCreateWithoutColoursInput>
  }

  export type ProductUpsertWithoutColoursInput = {
    update: XOR<ProductUpdateWithoutColoursInput, ProductUncheckedUpdateWithoutColoursInput>
    create: XOR<ProductCreateWithoutColoursInput, ProductUncheckedCreateWithoutColoursInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutColoursInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutColoursInput, ProductUncheckedUpdateWithoutColoursInput>
  }

  export type ProductUpdateWithoutColoursInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseMaterial?: MaterialUpdateOneWithoutProductsNestedInput
    orderProducts?: OrderProductUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutColoursInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUncheckedUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUncheckedUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutVariationsInput = {
    name: string
    code: string
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseMaterial?: MaterialCreateNestedOneWithoutProductsInput
    orderProducts?: OrderProductCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanCreateNestedManyWithoutProductInput
    colours?: ProductColourCreateNestedManyWithoutProductInput
    photos?: ProductPhotoCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVariationsInput = {
    id?: number
    name: string
    code: string
    materialId?: number | null
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanUncheckedCreateNestedManyWithoutProductInput
    colours?: ProductColourUncheckedCreateNestedManyWithoutProductInput
    photos?: ProductPhotoUncheckedCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVariationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariationsInput, ProductUncheckedCreateWithoutVariationsInput>
  }

  export type ProductUpsertWithoutVariationsInput = {
    update: XOR<ProductUpdateWithoutVariationsInput, ProductUncheckedUpdateWithoutVariationsInput>
    create: XOR<ProductCreateWithoutVariationsInput, ProductUncheckedCreateWithoutVariationsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVariationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVariationsInput, ProductUncheckedUpdateWithoutVariationsInput>
  }

  export type ProductUpdateWithoutVariationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseMaterial?: MaterialUpdateOneWithoutProductsNestedInput
    orderProducts?: OrderProductUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUpdateManyWithoutProductNestedInput
    colours?: ProductColourUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutVariationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUncheckedUpdateManyWithoutProductNestedInput
    colours?: ProductColourUncheckedUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUncheckedUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutPhotosInput = {
    name: string
    code: string
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseMaterial?: MaterialCreateNestedOneWithoutProductsInput
    orderProducts?: OrderProductCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanCreateNestedManyWithoutProductInput
    colours?: ProductColourCreateNestedManyWithoutProductInput
    variations?: ProductVariationCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPhotosInput = {
    id?: number
    name: string
    code: string
    materialId?: number | null
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutProductInput
    recurringPlans?: RecurringPlanUncheckedCreateNestedManyWithoutProductInput
    colours?: ProductColourUncheckedCreateNestedManyWithoutProductInput
    variations?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    individualProgressReports?: ProgressReportUncheckedCreateNestedManyWithoutProductInput
    productProgressReports?: ProductProgressReportUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPhotosInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPhotosInput, ProductUncheckedCreateWithoutPhotosInput>
  }

  export type ProductUpsertWithoutPhotosInput = {
    update: XOR<ProductUpdateWithoutPhotosInput, ProductUncheckedUpdateWithoutPhotosInput>
    create: XOR<ProductCreateWithoutPhotosInput, ProductUncheckedCreateWithoutPhotosInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPhotosInput, ProductUncheckedUpdateWithoutPhotosInput>
  }

  export type ProductUpdateWithoutPhotosInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseMaterial?: MaterialUpdateOneWithoutProductsNestedInput
    orderProducts?: OrderProductUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUpdateManyWithoutProductNestedInput
    colours?: ProductColourUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUncheckedUpdateManyWithoutProductNestedInput
    colours?: ProductColourUncheckedUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutProductNestedInput
  }

  export type MaterialCreateWithoutPurchaseAlertsInput = {
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementCreateNestedManyWithoutMaterialInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutMaterialInput
    remainingMaterials?: RemainingMaterialCreateNestedManyWithoutMaterialInput
    products?: ProductCreateNestedManyWithoutBaseMaterialInput
    purchaseLogs?: PurchaseLogCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutPurchaseAlertsInput = {
    id?: number
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutMaterialInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutMaterialInput
    remainingMaterials?: RemainingMaterialUncheckedCreateNestedManyWithoutMaterialInput
    products?: ProductUncheckedCreateNestedManyWithoutBaseMaterialInput
    purchaseLogs?: PurchaseLogUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutPurchaseAlertsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutPurchaseAlertsInput, MaterialUncheckedCreateWithoutPurchaseAlertsInput>
  }

  export type OrderCreateWithoutPurchaseAlertsInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    worker?: UserCreateNestedOneWithoutWorkerOrdersInput
    workerContact?: ContactCreateNestedOneWithoutWorkerOrdersInput
    orderProducts?: OrderProductCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkCreateNestedOneWithoutOrderInput
    shipment?: ShipmentCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPurchaseAlertsInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerId?: number | null
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkUncheckedCreateNestedOneWithoutOrderInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPurchaseAlertsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPurchaseAlertsInput, OrderUncheckedCreateWithoutPurchaseAlertsInput>
  }

  export type UserCreateWithoutCreatedAlertsInput = {
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    workerOrders?: OrderCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeCreateNestedManyWithoutUserInput
    resolvedAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutCreatedAlertsInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerOrders?: OrderUncheckedCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkUncheckedCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutUserInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutResolvedByUserInput
    createdContactNotes?: ContactNoteUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutCreatedAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedAlertsInput, UserUncheckedCreateWithoutCreatedAlertsInput>
  }

  export type UserCreateWithoutResolvedAlertsInput = {
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    workerOrders?: OrderCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutCreatedByUserInput
    createdContactNotes?: ContactNoteCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutResolvedAlertsInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerOrders?: OrderUncheckedCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkUncheckedCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdContactNotes?: ContactNoteUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutResolvedAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResolvedAlertsInput, UserUncheckedCreateWithoutResolvedAlertsInput>
  }

  export type MaterialUpsertWithoutPurchaseAlertsInput = {
    update: XOR<MaterialUpdateWithoutPurchaseAlertsInput, MaterialUncheckedUpdateWithoutPurchaseAlertsInput>
    create: XOR<MaterialCreateWithoutPurchaseAlertsInput, MaterialUncheckedCreateWithoutPurchaseAlertsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutPurchaseAlertsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutPurchaseAlertsInput, MaterialUncheckedUpdateWithoutPurchaseAlertsInput>
  }

  export type MaterialUpdateWithoutPurchaseAlertsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUpdateManyWithoutMaterialNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutMaterialNestedInput
    remainingMaterials?: RemainingMaterialUpdateManyWithoutMaterialNestedInput
    products?: ProductUpdateManyWithoutBaseMaterialNestedInput
    purchaseLogs?: PurchaseLogUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutPurchaseAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutMaterialNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutMaterialNestedInput
    remainingMaterials?: RemainingMaterialUncheckedUpdateManyWithoutMaterialNestedInput
    products?: ProductUncheckedUpdateManyWithoutBaseMaterialNestedInput
    purchaseLogs?: PurchaseLogUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type OrderUpsertWithoutPurchaseAlertsInput = {
    update: XOR<OrderUpdateWithoutPurchaseAlertsInput, OrderUncheckedUpdateWithoutPurchaseAlertsInput>
    create: XOR<OrderCreateWithoutPurchaseAlertsInput, OrderUncheckedCreateWithoutPurchaseAlertsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPurchaseAlertsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPurchaseAlertsInput, OrderUncheckedUpdateWithoutPurchaseAlertsInput>
  }

  export type OrderUpdateWithoutPurchaseAlertsInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    worker?: UserUpdateOneWithoutWorkerOrdersNestedInput
    workerContact?: ContactUpdateOneWithoutWorkerOrdersNestedInput
    orderProducts?: OrderProductUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPurchaseAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUncheckedUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserUpsertWithoutCreatedAlertsInput = {
    update: XOR<UserUpdateWithoutCreatedAlertsInput, UserUncheckedUpdateWithoutCreatedAlertsInput>
    create: XOR<UserCreateWithoutCreatedAlertsInput, UserUncheckedCreateWithoutCreatedAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedAlertsInput, UserUncheckedUpdateWithoutCreatedAlertsInput>
  }

  export type UserUpdateWithoutCreatedAlertsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUncheckedUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUncheckedUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutResolvedByUserNestedInput
    createdContactNotes?: ContactNoteUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUpsertWithoutResolvedAlertsInput = {
    update: XOR<UserUpdateWithoutResolvedAlertsInput, UserUncheckedUpdateWithoutResolvedAlertsInput>
    create: XOR<UserCreateWithoutResolvedAlertsInput, UserUncheckedCreateWithoutResolvedAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResolvedAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResolvedAlertsInput, UserUncheckedUpdateWithoutResolvedAlertsInput>
  }

  export type UserUpdateWithoutResolvedAlertsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUpdateManyWithoutCreatedByUserNestedInput
    createdContactNotes?: ContactNoteUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResolvedAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUncheckedUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUncheckedUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdContactNotes?: ContactNoteUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type MaterialCreateWithoutPurchaseLogsInput = {
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementCreateNestedManyWithoutMaterialInput
    productMaterials?: ProductMaterialCreateNestedManyWithoutMaterialInput
    remainingMaterials?: RemainingMaterialCreateNestedManyWithoutMaterialInput
    products?: ProductCreateNestedManyWithoutBaseMaterialInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutPurchaseLogsInput = {
    id?: number
    name: string
    description?: string | null
    code: string
    unit?: string
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string
    reorderPoint?: Decimal | DecimalJsLike | number | string
    reorderQty?: Decimal | DecimalJsLike | number | string
    location?: string | null
    attributeType?: string | null
    attributeValue?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutMaterialInput
    productMaterials?: ProductMaterialUncheckedCreateNestedManyWithoutMaterialInput
    remainingMaterials?: RemainingMaterialUncheckedCreateNestedManyWithoutMaterialInput
    products?: ProductUncheckedCreateNestedManyWithoutBaseMaterialInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutPurchaseLogsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutPurchaseLogsInput, MaterialUncheckedCreateWithoutPurchaseLogsInput>
  }

  export type MaterialMovementCreateWithoutPurchaseLogInput = {
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutMaterialMovementsInput
    order?: OrderCreateNestedOneWithoutMaterialMovementsInput
    user: UserCreateNestedOneWithoutMaterialMovementsInput
  }

  export type MaterialMovementUncheckedCreateWithoutPurchaseLogInput = {
    id?: number
    materialId: number
    orderId?: number | null
    userId: number
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialMovementCreateOrConnectWithoutPurchaseLogInput = {
    where: MaterialMovementWhereUniqueInput
    create: XOR<MaterialMovementCreateWithoutPurchaseLogInput, MaterialMovementUncheckedCreateWithoutPurchaseLogInput>
  }

  export type ContactNoteCreateWithoutPurchaseLogInput = {
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutContactNotesInput
    order?: OrderCreateNestedOneWithoutContactNotesInput
    createdByUser: UserCreateNestedOneWithoutCreatedContactNotesInput
  }

  export type ContactNoteUncheckedCreateWithoutPurchaseLogInput = {
    id?: number
    contactId: number
    orderId?: number | null
    createdBy: number
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactNoteCreateOrConnectWithoutPurchaseLogInput = {
    where: ContactNoteWhereUniqueInput
    create: XOR<ContactNoteCreateWithoutPurchaseLogInput, ContactNoteUncheckedCreateWithoutPurchaseLogInput>
  }

  export type ContactNoteCreateManyPurchaseLogInputEnvelope = {
    data: ContactNoteCreateManyPurchaseLogInput | ContactNoteCreateManyPurchaseLogInput[]
    skipDuplicates?: boolean
  }

  export type MaterialUpsertWithoutPurchaseLogsInput = {
    update: XOR<MaterialUpdateWithoutPurchaseLogsInput, MaterialUncheckedUpdateWithoutPurchaseLogsInput>
    create: XOR<MaterialCreateWithoutPurchaseLogsInput, MaterialUncheckedCreateWithoutPurchaseLogsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutPurchaseLogsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutPurchaseLogsInput, MaterialUncheckedUpdateWithoutPurchaseLogsInput>
  }

  export type MaterialUpdateWithoutPurchaseLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUpdateManyWithoutMaterialNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutMaterialNestedInput
    remainingMaterials?: RemainingMaterialUpdateManyWithoutMaterialNestedInput
    products?: ProductUpdateManyWithoutBaseMaterialNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutPurchaseLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attributeType?: NullableStringFieldUpdateOperationsInput | string | null
    attributeValue?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutMaterialNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutMaterialNestedInput
    remainingMaterials?: RemainingMaterialUncheckedUpdateManyWithoutMaterialNestedInput
    products?: ProductUncheckedUpdateManyWithoutBaseMaterialNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialMovementUpsertWithoutPurchaseLogInput = {
    update: XOR<MaterialMovementUpdateWithoutPurchaseLogInput, MaterialMovementUncheckedUpdateWithoutPurchaseLogInput>
    create: XOR<MaterialMovementCreateWithoutPurchaseLogInput, MaterialMovementUncheckedCreateWithoutPurchaseLogInput>
    where?: MaterialMovementWhereInput
  }

  export type MaterialMovementUpdateToOneWithWhereWithoutPurchaseLogInput = {
    where?: MaterialMovementWhereInput
    data: XOR<MaterialMovementUpdateWithoutPurchaseLogInput, MaterialMovementUncheckedUpdateWithoutPurchaseLogInput>
  }

  export type MaterialMovementUpdateWithoutPurchaseLogInput = {
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutMaterialMovementsNestedInput
    order?: OrderUpdateOneWithoutMaterialMovementsNestedInput
    user?: UserUpdateOneRequiredWithoutMaterialMovementsNestedInput
  }

  export type MaterialMovementUncheckedUpdateWithoutPurchaseLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteUpsertWithWhereUniqueWithoutPurchaseLogInput = {
    where: ContactNoteWhereUniqueInput
    update: XOR<ContactNoteUpdateWithoutPurchaseLogInput, ContactNoteUncheckedUpdateWithoutPurchaseLogInput>
    create: XOR<ContactNoteCreateWithoutPurchaseLogInput, ContactNoteUncheckedCreateWithoutPurchaseLogInput>
  }

  export type ContactNoteUpdateWithWhereUniqueWithoutPurchaseLogInput = {
    where: ContactNoteWhereUniqueInput
    data: XOR<ContactNoteUpdateWithoutPurchaseLogInput, ContactNoteUncheckedUpdateWithoutPurchaseLogInput>
  }

  export type ContactNoteUpdateManyWithWhereWithoutPurchaseLogInput = {
    where: ContactNoteScalarWhereInput
    data: XOR<ContactNoteUpdateManyMutationInput, ContactNoteUncheckedUpdateManyWithoutPurchaseLogInput>
  }

  export type OrderCreateWithoutWorkerContactInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    worker?: UserCreateNestedOneWithoutWorkerOrdersInput
    orderProducts?: OrderProductCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkCreateNestedOneWithoutOrderInput
    shipment?: ShipmentCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutWorkerContactInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkUncheckedCreateNestedOneWithoutOrderInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutOrderInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutWorkerContactInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutWorkerContactInput, OrderUncheckedCreateWithoutWorkerContactInput>
  }

  export type OrderCreateManyWorkerContactInputEnvelope = {
    data: OrderCreateManyWorkerContactInput | OrderCreateManyWorkerContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactNoteCreateWithoutContactInput = {
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutContactNotesInput
    purchaseLog?: PurchaseLogCreateNestedOneWithoutContactNotesInput
    createdByUser: UserCreateNestedOneWithoutCreatedContactNotesInput
  }

  export type ContactNoteUncheckedCreateWithoutContactInput = {
    id?: number
    orderId?: number | null
    purchaseLogId?: number | null
    createdBy: number
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactNoteCreateOrConnectWithoutContactInput = {
    where: ContactNoteWhereUniqueInput
    create: XOR<ContactNoteCreateWithoutContactInput, ContactNoteUncheckedCreateWithoutContactInput>
  }

  export type ContactNoteCreateManyContactInputEnvelope = {
    data: ContactNoteCreateManyContactInput | ContactNoteCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutWorkerContactInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutWorkerContactInput, OrderUncheckedUpdateWithoutWorkerContactInput>
    create: XOR<OrderCreateWithoutWorkerContactInput, OrderUncheckedCreateWithoutWorkerContactInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutWorkerContactInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutWorkerContactInput, OrderUncheckedUpdateWithoutWorkerContactInput>
  }

  export type OrderUpdateManyWithWhereWithoutWorkerContactInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutWorkerContactInput>
  }

  export type ContactNoteUpsertWithWhereUniqueWithoutContactInput = {
    where: ContactNoteWhereUniqueInput
    update: XOR<ContactNoteUpdateWithoutContactInput, ContactNoteUncheckedUpdateWithoutContactInput>
    create: XOR<ContactNoteCreateWithoutContactInput, ContactNoteUncheckedCreateWithoutContactInput>
  }

  export type ContactNoteUpdateWithWhereUniqueWithoutContactInput = {
    where: ContactNoteWhereUniqueInput
    data: XOR<ContactNoteUpdateWithoutContactInput, ContactNoteUncheckedUpdateWithoutContactInput>
  }

  export type ContactNoteUpdateManyWithWhereWithoutContactInput = {
    where: ContactNoteScalarWhereInput
    data: XOR<ContactNoteUpdateManyMutationInput, ContactNoteUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactCreateWithoutContactNotesInput = {
    name: string
    phone?: string | null
    whatsappPhone?: string | null
    email?: string | null
    address?: string | null
    contactType: $Enums.ContactType
    company?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workerOrders?: OrderCreateNestedManyWithoutWorkerContactInput
  }

  export type ContactUncheckedCreateWithoutContactNotesInput = {
    id?: number
    name: string
    phone?: string | null
    whatsappPhone?: string | null
    email?: string | null
    address?: string | null
    contactType: $Enums.ContactType
    company?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workerOrders?: OrderUncheckedCreateNestedManyWithoutWorkerContactInput
  }

  export type ContactCreateOrConnectWithoutContactNotesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutContactNotesInput, ContactUncheckedCreateWithoutContactNotesInput>
  }

  export type OrderCreateWithoutContactNotesInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    worker?: UserCreateNestedOneWithoutWorkerOrdersInput
    workerContact?: ContactCreateNestedOneWithoutWorkerOrdersInput
    orderProducts?: OrderProductCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkCreateNestedOneWithoutOrderInput
    shipment?: ShipmentCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutContactNotesInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerId?: number | null
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutOrderInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutOrderInput
    orderLink?: OrderLinkUncheckedCreateNestedOneWithoutOrderInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutOrderInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutOrderInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutContactNotesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutContactNotesInput, OrderUncheckedCreateWithoutContactNotesInput>
  }

  export type PurchaseLogCreateWithoutContactNotesInput = {
    supplier: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    pricePerUnit?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    invoiceNumber?: string | null
    receiptPath?: string | null
    notes?: string | null
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    receivedQuantity?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    material: MaterialCreateNestedOneWithoutPurchaseLogsInput
    movement?: MaterialMovementCreateNestedOneWithoutPurchaseLogInput
  }

  export type PurchaseLogUncheckedCreateWithoutContactNotesInput = {
    id?: number
    materialId: number
    supplier: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    pricePerUnit?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    invoiceNumber?: string | null
    receiptPath?: string | null
    notes?: string | null
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    receivedQuantity?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    movement?: MaterialMovementUncheckedCreateNestedOneWithoutPurchaseLogInput
  }

  export type PurchaseLogCreateOrConnectWithoutContactNotesInput = {
    where: PurchaseLogWhereUniqueInput
    create: XOR<PurchaseLogCreateWithoutContactNotesInput, PurchaseLogUncheckedCreateWithoutContactNotesInput>
  }

  export type UserCreateWithoutCreatedContactNotesInput = {
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    workerOrders?: OrderCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertCreateNestedManyWithoutResolvedByUserInput
  }

  export type UserUncheckedCreateWithoutCreatedContactNotesInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    whatsappPhone?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    loginEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerOrders?: OrderUncheckedCreateNestedManyWithoutWorkerInput
    materialMovements?: MaterialMovementUncheckedCreateNestedManyWithoutUserInput
    progressReports?: ProgressReportUncheckedCreateNestedManyWithoutUserInput
    orderLinks?: OrderLinkUncheckedCreateNestedManyWithoutUserInput
    statusChanges?: StatusChangeUncheckedCreateNestedManyWithoutUserInput
    createdAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutCreatedByUserInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedCreateNestedManyWithoutResolvedByUserInput
  }

  export type UserCreateOrConnectWithoutCreatedContactNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedContactNotesInput, UserUncheckedCreateWithoutCreatedContactNotesInput>
  }

  export type ContactUpsertWithoutContactNotesInput = {
    update: XOR<ContactUpdateWithoutContactNotesInput, ContactUncheckedUpdateWithoutContactNotesInput>
    create: XOR<ContactCreateWithoutContactNotesInput, ContactUncheckedCreateWithoutContactNotesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutContactNotesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutContactNotesInput, ContactUncheckedUpdateWithoutContactNotesInput>
  }

  export type ContactUpdateWithoutContactNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workerOrders?: OrderUpdateManyWithoutWorkerContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutContactNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactType?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workerOrders?: OrderUncheckedUpdateManyWithoutWorkerContactNestedInput
  }

  export type OrderUpsertWithoutContactNotesInput = {
    update: XOR<OrderUpdateWithoutContactNotesInput, OrderUncheckedUpdateWithoutContactNotesInput>
    create: XOR<OrderCreateWithoutContactNotesInput, OrderUncheckedCreateWithoutContactNotesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutContactNotesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutContactNotesInput, OrderUncheckedUpdateWithoutContactNotesInput>
  }

  export type OrderUpdateWithoutContactNotesInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    worker?: UserUpdateOneWithoutWorkerOrdersNestedInput
    workerContact?: ContactUpdateOneWithoutWorkerOrdersNestedInput
    orderProducts?: OrderProductUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutContactNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUncheckedUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PurchaseLogUpsertWithoutContactNotesInput = {
    update: XOR<PurchaseLogUpdateWithoutContactNotesInput, PurchaseLogUncheckedUpdateWithoutContactNotesInput>
    create: XOR<PurchaseLogCreateWithoutContactNotesInput, PurchaseLogUncheckedCreateWithoutContactNotesInput>
    where?: PurchaseLogWhereInput
  }

  export type PurchaseLogUpdateToOneWithWhereWithoutContactNotesInput = {
    where?: PurchaseLogWhereInput
    data: XOR<PurchaseLogUpdateWithoutContactNotesInput, PurchaseLogUncheckedUpdateWithoutContactNotesInput>
  }

  export type PurchaseLogUpdateWithoutContactNotesInput = {
    supplier?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    pricePerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedQuantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutPurchaseLogsNestedInput
    movement?: MaterialMovementUpdateOneWithoutPurchaseLogNestedInput
  }

  export type PurchaseLogUncheckedUpdateWithoutContactNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    supplier?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    pricePerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedQuantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movement?: MaterialMovementUncheckedUpdateOneWithoutPurchaseLogNestedInput
  }

  export type UserUpsertWithoutCreatedContactNotesInput = {
    update: XOR<UserUpdateWithoutCreatedContactNotesInput, UserUncheckedUpdateWithoutCreatedContactNotesInput>
    create: XOR<UserCreateWithoutCreatedContactNotesInput, UserUncheckedCreateWithoutCreatedContactNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedContactNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedContactNotesInput, UserUncheckedUpdateWithoutCreatedContactNotesInput>
  }

  export type UserUpdateWithoutCreatedContactNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUpdateManyWithoutResolvedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedContactNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loginEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerOrders?: OrderUncheckedUpdateManyWithoutWorkerNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutUserNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutUserNestedInput
    orderLinks?: OrderLinkUncheckedUpdateManyWithoutUserNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput
    createdAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutCreatedByUserNestedInput
    resolvedAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutResolvedByUserNestedInput
  }

  export type OrderCreateManyUserInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    workerId?: number | null
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyWorkerInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerContactId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialMovementCreateManyUserInput = {
    id?: number
    materialId: number
    orderId?: number | null
    purchaseLogId?: number | null
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgressReportCreateManyUserInput = {
    id?: number
    orderId?: number | null
    orderProductId?: number | null
    productId?: number | null
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderLinkCreateManyUserInput = {
    id?: number
    orderId: number
    linkToken: string
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusChangeCreateManyUserInput = {
    id?: number
    orderId: number
    fromStatus: $Enums.OrderStatus
    toStatus: $Enums.OrderStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialPurchaseAlertCreateManyCreatedByUserInput = {
    id?: number
    materialId: number
    orderId?: number | null
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    resolvedBy?: number | null
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialPurchaseAlertCreateManyResolvedByUserInput = {
    id?: number
    materialId: number
    orderId?: number | null
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    createdBy: number
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactNoteCreateManyCreatedByUserInput = {
    id?: number
    contactId: number
    orderId?: number | null
    purchaseLogId?: number | null
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    worker?: UserUpdateOneWithoutWorkerOrdersNestedInput
    workerContact?: ContactUpdateOneWithoutWorkerOrdersNestedInput
    orderProducts?: OrderProductUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUncheckedUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutWorkerInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    workerContact?: ContactUpdateOneWithoutWorkerOrdersNestedInput
    orderProducts?: OrderProductUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutWorkerInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUncheckedUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutWorkerInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerContactId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialMovementUpdateWithoutUserInput = {
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutMaterialMovementsNestedInput
    order?: OrderUpdateOneWithoutMaterialMovementsNestedInput
    purchaseLog?: PurchaseLogUpdateOneWithoutMovementNestedInput
  }

  export type MaterialMovementUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialMovementUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressReportUpdateWithoutUserInput = {
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutProgressReportsNestedInput
    orderProduct?: OrderProductUpdateOneWithoutIndividualProgressReportsNestedInput
    product?: ProductUpdateOneWithoutIndividualProgressReportsNestedInput
    productReports?: ProductProgressReportUpdateManyWithoutProgressReportNestedInput
  }

  export type ProgressReportUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productReports?: ProductProgressReportUncheckedUpdateManyWithoutProgressReportNestedInput
  }

  export type ProgressReportUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderLinkUpdateWithoutUserInput = {
    linkToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderLinkNestedInput
  }

  export type OrderLinkUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    linkToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderLinkUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    linkToken?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusChangeUpdateWithoutUserInput = {
    fromStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutStatusChangesNestedInput
  }

  export type StatusChangeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    fromStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusChangeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    fromStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialPurchaseAlertUpdateWithoutCreatedByUserInput = {
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutPurchaseAlertsNestedInput
    order?: OrderUpdateOneWithoutPurchaseAlertsNestedInput
    resolvedByUser?: UserUpdateOneWithoutResolvedAlertsNestedInput
  }

  export type MaterialPurchaseAlertUncheckedUpdateWithoutCreatedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    resolvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialPurchaseAlertUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    resolvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialPurchaseAlertUpdateWithoutResolvedByUserInput = {
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutPurchaseAlertsNestedInput
    order?: OrderUpdateOneWithoutPurchaseAlertsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutCreatedAlertsNestedInput
  }

  export type MaterialPurchaseAlertUncheckedUpdateWithoutResolvedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    createdBy?: IntFieldUpdateOperationsInput | number
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialPurchaseAlertUncheckedUpdateManyWithoutResolvedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    createdBy?: IntFieldUpdateOperationsInput | number
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteUpdateWithoutCreatedByUserInput = {
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutContactNotesNestedInput
    order?: OrderUpdateOneWithoutContactNotesNestedInput
    purchaseLog?: PurchaseLogUpdateOneWithoutContactNotesNestedInput
  }

  export type ContactNoteUncheckedUpdateWithoutCreatedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialMovementCreateManyMaterialInput = {
    id?: number
    orderId?: number | null
    userId: number
    purchaseLogId?: number | null
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductMaterialCreateManyMaterialInput = {
    id?: number
    productId: number
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RemainingMaterialCreateManyMaterialInput = {
    id?: number
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyBaseMaterialInput = {
    id?: number
    name: string
    code: string
    category?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: number
    unit?: string
    description?: string | null
    defaultTarget?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialPurchaseAlertCreateManyMaterialInput = {
    id?: number
    orderId?: number | null
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    createdBy: number
    resolvedBy?: number | null
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseLogCreateManyMaterialInput = {
    id?: number
    supplier: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    pricePerUnit?: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    invoiceNumber?: string | null
    receiptPath?: string | null
    notes?: string | null
    status?: $Enums.PurchaseStatus
    deliveryDate?: Date | string | null
    receivedQuantity?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialMovementUpdateWithoutMaterialInput = {
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutMaterialMovementsNestedInput
    user?: UserUpdateOneRequiredWithoutMaterialMovementsNestedInput
    purchaseLog?: PurchaseLogUpdateOneWithoutMovementNestedInput
  }

  export type MaterialMovementUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialMovementUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMaterialUpdateWithoutMaterialInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductMaterialsNestedInput
  }

  export type ProductMaterialUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMaterialUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemainingMaterialUpdateWithoutMaterialInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemainingMaterialUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemainingMaterialUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutBaseMaterialInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUpdateManyWithoutProductNestedInput
    colours?: ProductColourUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBaseMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    productMaterials?: ProductMaterialUncheckedUpdateManyWithoutProductNestedInput
    recurringPlans?: RecurringPlanUncheckedUpdateManyWithoutProductNestedInput
    colours?: ProductColourUncheckedUpdateManyWithoutProductNestedInput
    variations?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    photos?: ProductPhotoUncheckedUpdateManyWithoutProductNestedInput
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutProductNestedInput
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBaseMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qtyOnHand?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultTarget?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialPurchaseAlertUpdateWithoutMaterialInput = {
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutPurchaseAlertsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutCreatedAlertsNestedInput
    resolvedByUser?: UserUpdateOneWithoutResolvedAlertsNestedInput
  }

  export type MaterialPurchaseAlertUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    createdBy?: IntFieldUpdateOperationsInput | number
    resolvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialPurchaseAlertUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    createdBy?: IntFieldUpdateOperationsInput | number
    resolvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseLogUpdateWithoutMaterialInput = {
    supplier?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    pricePerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedQuantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movement?: MaterialMovementUpdateOneWithoutPurchaseLogNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutPurchaseLogNestedInput
  }

  export type PurchaseLogUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    pricePerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedQuantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movement?: MaterialMovementUncheckedUpdateOneWithoutPurchaseLogNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutPurchaseLogNestedInput
  }

  export type PurchaseLogUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    pricePerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedQuantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderProductCreateManyProductInput = {
    id?: number
    orderId: number
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductMaterialCreateManyProductInput = {
    id?: number
    materialId: number
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringPlanCreateManyProductInput = {
    id?: number
    quantity?: number
    frequency?: string
    isActive?: boolean
    nextDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductColourCreateManyProductInput = {
    id?: number
    colorName: string
    colorCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationCreateManyProductInput = {
    id?: number
    variationType: string
    variationValue: string
    priceAdjustment?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductPhotoCreateManyProductInput = {
    id?: number
    photoPath: string
    thumbnailPath?: string | null
    description?: string | null
    isPrimary?: boolean
    sortOrder?: number
    fileSize?: number | null
    mimeType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgressReportCreateManyProductInput = {
    id?: number
    orderId?: number | null
    orderProductId?: number | null
    userId: number
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProgressReportCreateManyProductInput = {
    id?: number
    progressReportId: number
    orderProductId?: number | null
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderProductUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderProductsNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutOrderProductNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutOrderProductNestedInput
  }

  export type OrderProductUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutOrderProductNestedInput
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutOrderProductNestedInput
  }

  export type OrderProductUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMaterialUpdateWithoutProductInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutProductMaterialsNestedInput
  }

  export type ProductMaterialUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMaterialUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringPlanUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringPlanUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringPlanUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nextDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductColourUpdateWithoutProductInput = {
    colorName?: StringFieldUpdateOperationsInput | string
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductColourUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    colorName?: StringFieldUpdateOperationsInput | string
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductColourUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    colorName?: StringFieldUpdateOperationsInput | string
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationUpdateWithoutProductInput = {
    variationType?: StringFieldUpdateOperationsInput | string
    variationValue?: StringFieldUpdateOperationsInput | string
    priceAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    variationType?: StringFieldUpdateOperationsInput | string
    variationValue?: StringFieldUpdateOperationsInput | string
    priceAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    variationType?: StringFieldUpdateOperationsInput | string
    variationValue?: StringFieldUpdateOperationsInput | string
    priceAdjustment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPhotoUpdateWithoutProductInput = {
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPhotoUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPhotoUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressReportUpdateWithoutProductInput = {
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutProgressReportsNestedInput
    orderProduct?: OrderProductUpdateOneWithoutIndividualProgressReportsNestedInput
    user?: UserUpdateOneRequiredWithoutProgressReportsNestedInput
    productReports?: ProductProgressReportUpdateManyWithoutProgressReportNestedInput
  }

  export type ProgressReportUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productReports?: ProductProgressReportUncheckedUpdateManyWithoutProgressReportNestedInput
  }

  export type ProgressReportUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProgressReportUpdateWithoutProductInput = {
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressReport?: ProgressReportUpdateOneRequiredWithoutProductReportsNestedInput
    orderProduct?: OrderProductUpdateOneWithoutProductProgressReportsNestedInput
    photos?: ProductProgressPhotoUpdateManyWithoutProductProgressReportNestedInput
  }

  export type ProductProgressReportUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    progressReportId?: IntFieldUpdateOperationsInput | number
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ProductProgressPhotoUncheckedUpdateManyWithoutProductProgressReportNestedInput
  }

  export type ProductProgressReportUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    progressReportId?: IntFieldUpdateOperationsInput | number
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderProductCreateManyOrderInput = {
    id?: number
    productId: number
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    completedQty?: number
    status?: $Enums.OrderProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialMovementCreateManyOrderInput = {
    id?: number
    materialId: number
    userId: number
    purchaseLogId?: number | null
    movementType: $Enums.MaterialMovementType
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    qtyAfter: Decimal | DecimalJsLike | number | string
    movementDate?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgressReportCreateManyOrderInput = {
    id?: number
    orderProductId?: number | null
    productId?: number | null
    userId: number
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusChangeCreateManyOrderInput = {
    id?: number
    changedBy: number
    fromStatus: $Enums.OrderStatus
    toStatus: $Enums.OrderStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialPurchaseAlertCreateManyOrderInput = {
    id?: number
    materialId: number
    alertType: $Enums.MaterialPurchaseAlertType
    requiredQuantity: Decimal | DecimalJsLike | number | string
    currentStock: Decimal | DecimalJsLike | number | string
    urgencyLevel?: $Enums.UrgencyLevel
    message: string
    status?: $Enums.AlertStatus
    createdBy: number
    resolvedBy?: number | null
    resolvedAt?: Date | string | null
    resolution?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactNoteCreateManyOrderInput = {
    id?: number
    contactId: number
    purchaseLogId?: number | null
    createdBy: number
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderProductUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOrderProductsNestedInput
    individualProgressReports?: ProgressReportUpdateManyWithoutOrderProductNestedInput
    productProgressReports?: ProductProgressReportUpdateManyWithoutOrderProductNestedInput
  }

  export type OrderProductUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    individualProgressReports?: ProgressReportUncheckedUpdateManyWithoutOrderProductNestedInput
    productProgressReports?: ProductProgressReportUncheckedUpdateManyWithoutOrderProductNestedInput
  }

  export type OrderProductUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedQty?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderProductStatusFieldUpdateOperationsInput | $Enums.OrderProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialMovementUpdateWithoutOrderInput = {
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutMaterialMovementsNestedInput
    user?: UserUpdateOneRequiredWithoutMaterialMovementsNestedInput
    purchaseLog?: PurchaseLogUpdateOneWithoutMovementNestedInput
  }

  export type MaterialMovementUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialMovementUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    movementType?: EnumMaterialMovementTypeFieldUpdateOperationsInput | $Enums.MaterialMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    qtyAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressReportUpdateWithoutOrderInput = {
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProduct?: OrderProductUpdateOneWithoutIndividualProgressReportsNestedInput
    product?: ProductUpdateOneWithoutIndividualProgressReportsNestedInput
    user?: UserUpdateOneRequiredWithoutProgressReportsNestedInput
    productReports?: ProductProgressReportUpdateManyWithoutProgressReportNestedInput
  }

  export type ProgressReportUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productReports?: ProductProgressReportUncheckedUpdateManyWithoutProgressReportNestedInput
  }

  export type ProgressReportUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusChangeUpdateWithoutOrderInput = {
    fromStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStatusChangesNestedInput
  }

  export type StatusChangeUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    changedBy?: IntFieldUpdateOperationsInput | number
    fromStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusChangeUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    changedBy?: IntFieldUpdateOperationsInput | number
    fromStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    toStatus?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialPurchaseAlertUpdateWithoutOrderInput = {
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutPurchaseAlertsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutCreatedAlertsNestedInput
    resolvedByUser?: UserUpdateOneWithoutResolvedAlertsNestedInput
  }

  export type MaterialPurchaseAlertUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    createdBy?: IntFieldUpdateOperationsInput | number
    resolvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    alertType?: EnumMaterialPurchaseAlertTypeFieldUpdateOperationsInput | $Enums.MaterialPurchaseAlertType
    requiredQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    urgencyLevel?: EnumUrgencyLevelFieldUpdateOperationsInput | $Enums.UrgencyLevel
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    createdBy?: IntFieldUpdateOperationsInput | number
    resolvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    suggestedSupplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteUpdateWithoutOrderInput = {
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutContactNotesNestedInput
    purchaseLog?: PurchaseLogUpdateOneWithoutContactNotesNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutCreatedContactNotesNestedInput
  }

  export type ContactNoteUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: IntFieldUpdateOperationsInput | number
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: IntFieldUpdateOperationsInput | number
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressReportCreateManyOrderProductInput = {
    id?: number
    orderId?: number | null
    productId?: number | null
    userId: number
    reportText: string
    photoPath?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProgressReportCreateManyOrderProductInput = {
    id?: number
    progressReportId: number
    productId: number
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgressReportUpdateWithoutOrderProductInput = {
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutProgressReportsNestedInput
    product?: ProductUpdateOneWithoutIndividualProgressReportsNestedInput
    user?: UserUpdateOneRequiredWithoutProgressReportsNestedInput
    productReports?: ProductProgressReportUpdateManyWithoutProgressReportNestedInput
  }

  export type ProgressReportUncheckedUpdateWithoutOrderProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productReports?: ProductProgressReportUncheckedUpdateManyWithoutProgressReportNestedInput
  }

  export type ProgressReportUncheckedUpdateManyWithoutOrderProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    reportText?: StringFieldUpdateOperationsInput | string
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProgressReportUpdateWithoutOrderProductInput = {
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressReport?: ProgressReportUpdateOneRequiredWithoutProductReportsNestedInput
    product?: ProductUpdateOneRequiredWithoutProductProgressReportsNestedInput
    photos?: ProductProgressPhotoUpdateManyWithoutProductProgressReportNestedInput
  }

  export type ProductProgressReportUncheckedUpdateWithoutOrderProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    progressReportId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ProductProgressPhotoUncheckedUpdateManyWithoutProductProgressReportNestedInput
  }

  export type ProductProgressReportUncheckedUpdateManyWithoutOrderProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    progressReportId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProgressReportCreateManyProgressReportInput = {
    id?: number
    productId: number
    orderProductId?: number | null
    itemsCompleted?: number
    itemsTarget?: number
    status?: string
    notes?: string | null
    completionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProgressReportUpdateWithoutProgressReportInput = {
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductProgressReportsNestedInput
    orderProduct?: OrderProductUpdateOneWithoutProductProgressReportsNestedInput
    photos?: ProductProgressPhotoUpdateManyWithoutProductProgressReportNestedInput
  }

  export type ProductProgressReportUncheckedUpdateWithoutProgressReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ProductProgressPhotoUncheckedUpdateManyWithoutProductProgressReportNestedInput
  }

  export type ProductProgressReportUncheckedUpdateManyWithoutProgressReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    orderProductId?: NullableIntFieldUpdateOperationsInput | number | null
    itemsCompleted?: IntFieldUpdateOperationsInput | number
    itemsTarget?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProgressPhotoCreateManyProductProgressReportInput = {
    id?: number
    photoPath: string
    thumbnailPath?: string | null
    description?: string | null
    uploadDate?: Date | string
    fileSize?: number | null
    mimeType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProgressPhotoUpdateWithoutProductProgressReportInput = {
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProgressPhotoUncheckedUpdateWithoutProductProgressReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProgressPhotoUncheckedUpdateManyWithoutProductProgressReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    photoPath?: StringFieldUpdateOperationsInput | string
    thumbnailPath?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteCreateManyPurchaseLogInput = {
    id?: number
    contactId: number
    orderId?: number | null
    createdBy: number
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactNoteUpdateWithoutPurchaseLogInput = {
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutContactNotesNestedInput
    order?: OrderUpdateOneWithoutContactNotesNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutCreatedContactNotesNestedInput
  }

  export type ContactNoteUncheckedUpdateWithoutPurchaseLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: IntFieldUpdateOperationsInput | number
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteUncheckedUpdateManyWithoutPurchaseLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: IntFieldUpdateOperationsInput | number
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyWorkerContactInput = {
    id?: number
    orderNumber: string
    status?: $Enums.OrderStatus
    targetPcs?: number
    completedPcs?: number
    customerNote?: string | null
    dueDate?: Date | string | null
    userId: number
    workerId?: number | null
    description?: string | null
    priority?: $Enums.Priority
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactNoteCreateManyContactInput = {
    id?: number
    orderId?: number | null
    purchaseLogId?: number | null
    createdBy: number
    noteType: $Enums.NoteType
    subject?: string | null
    content: string
    followUpDate?: Date | string | null
    isImportant?: boolean
    tags?: string | null
    attachmentPath?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutWorkerContactInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    worker?: UserUpdateOneWithoutWorkerOrdersNestedInput
    orderProducts?: OrderProductUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutWorkerContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderProducts?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    materialMovements?: MaterialMovementUncheckedUpdateManyWithoutOrderNestedInput
    progressReports?: ProgressReportUncheckedUpdateManyWithoutOrderNestedInput
    orderLink?: OrderLinkUncheckedUpdateOneWithoutOrderNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutOrderNestedInput
    statusChanges?: StatusChangeUncheckedUpdateManyWithoutOrderNestedInput
    purchaseAlerts?: MaterialPurchaseAlertUncheckedUpdateManyWithoutOrderNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutWorkerContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    targetPcs?: IntFieldUpdateOperationsInput | number
    completedPcs?: IntFieldUpdateOperationsInput | number
    customerNote?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: IntFieldUpdateOperationsInput | number
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteUpdateWithoutContactInput = {
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutContactNotesNestedInput
    purchaseLog?: PurchaseLogUpdateOneWithoutContactNotesNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutCreatedContactNotesNestedInput
  }

  export type ContactNoteUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: IntFieldUpdateOperationsInput | number
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    purchaseLogId?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: IntFieldUpdateOperationsInput | number
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentPath?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}